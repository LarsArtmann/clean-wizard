<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 2 clones</h1>
<h2>internal/adapters/ui_adapter.go:82</h2>
<pre>func (ui *UIAdapter) ScanTypeDescription(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "Nix store garbage collection and cleanup"
	case domain.ScanTypeHomebrewType:
		return "Homebrew package cleanup and maintenance"
	case domain.ScanTypeSystemType:
		return "System-level temporary files cleanup"
	case domain.ScanTypeTempType:
		return "Temporary files and cache cleanup"
	default:
		return "Unknown scan type"
	}
}

// CleanStrategyDescription returns human-readable description for strategy
func (ui *UIAdapter) CleanStrategyDescription(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "Aggressive cleanup with maximum disk space recovery"
	case domain.StrategyConservativeType:
		return "Conservative cleanup with safety-first approach"
	case domain.StrategyDryRunType:
		return "Preview mode - shows what would be cleaned without making changes"
	default:
		return "Unknown cleaning strategy"
	}
}

// StatusIcon returns appropriate emoji icon for status
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) StatusIcon(status domain.StatusType) string {
	switch status {
	case domain.StatusDisabled:
		return "üî¥"
	case domain.StatusEnabled:
		return "üü¢"
	case domain.StatusInherited:
		return "üîµ"
	default:
		return "‚ö™"
	}
}

// EnforcementLevelIcon returns appropriate emoji icon for enforcement level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:160</h2>
<pre>func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}

// OptimizationLevelIcon returns appropriate emoji icon for optimization level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) OptimizationLevelIcon(level domain.OptimizationLevelType) string {
	switch level {
	case domain.OptimizationLevelNone:
		return "‚ö™"
	case domain.OptimizationLevelConservative:
		return "üü°"
	case domain.OptimizationLevelAggressive:
		return "üî¥"
	default:
		return "‚ùì"
	}
}

// FileSelectionStrategyIcon returns appropriate emoji icon for file selection strategy
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) FileSelectionStrategyIcon(strategy domain.FileSelectionStrategyType) string {
	switch strategy {
	case domain.FileSelectionStrategyAll:
		return "üìÅ"
	case domain.FileSelectionStrategyUnusedOnly:
		return "üóëÔ∏è"
	case domain.FileSelectionStrategyManual:
		return "‚úèÔ∏è"
	default:
		return "‚ùì"
	}
}

// SafetyLevelIcon returns appropriate emoji icon for safety level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) SafetyLevelIcon(level domain.SafetyLevelType) string {
	switch level {
	case domain.SafetyLevelDisabled:
		return "üî¥"
	case domain.SafetyLevelEnabled:
		return "üü¢"
	case domain.SafetyLevelStrict:
		return "üü°"
	case domain.SafetyLevelParanoid:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#2 found 2 clones</h1>
<h2>internal/config/validation_middleware_analysis.go:16</h2>
<pre>if current.SafetyLevel != proposed.SafetyLevel {
	changes = append(changes, ConfigChange{
		Field:     "safe_mode",
		OldValue:  current.SafetyLevel,
		NewValue:  proposed.SafetyLevel,
		Operation: vm.getChangeOperation(current.SafetyLevel, proposed.SafetyLevel),
		Risk:      vm.assessChangeRisk("safe_mode", current.SafetyLevel, proposed.SafetyLevel),
	})
}</pre>
<h2>internal/config/validation_middleware_analysis.go:26</h2>
<pre>if current.MaxDiskUsage != proposed.MaxDiskUsage {
	changes = append(changes, ConfigChange{
		Field:     "max_disk_usage",
		OldValue:  current.MaxDiskUsage,
		NewValue:  proposed.MaxDiskUsage,
		Operation: vm.getChangeOperation(current.MaxDiskUsage, proposed.MaxDiskUsage),
		Risk:      vm.assessChangeRisk("max_disk_usage", current.MaxDiskUsage, proposed.MaxDiskUsage),
	})
}</pre>
<h1>#3 found 2 clones</h1>
<h2>internal/config/sanitizer_paths.go:41</h2>
<pre>                         {
	result.Warnings = append(result.Warnings, SanitizationWarning{
		Field:     fmt.Sprintf("protected[%d]", i),
		Original:  original,
		Sanitized: path,
		Reason:    fmt.Sprintf("protected path must be absolute: %s", original),
	})
	continue // Skip processing invalid path
}</pre>
<h2>internal/config/sanitizer_profile_main.go:14</h2>
<pre>                  {
	result.Warnings = append(result.Warnings, SanitizationWarning{
		Field:     fmt.Sprintf("profiles.%s", name),
		Original:  nil,
		Sanitized: nil,
		Reason:    fmt.Sprintf("Profile '%s' is nil, skipping sanitization", name),
	})
	continue
}</pre>
<h1>#4 found 7 clones</h1>
<h2>internal/adapters/ui_adapter.go:18</h2>
<pre>func (ui *UIAdapter) RiskLevelIcon(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "üü¢"
	case domain.RiskLevelMediumType:
		return "üü°"
	case domain.RiskLevelHighType:
		return "üü†"
	case domain.RiskLevelCriticalType:
		return "üî¥"
	default:
		return "‚ö™"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:49</h2>
<pre>func (ui *UIAdapter) RiskLevelColor(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "#22c55e" // green
	case domain.RiskLevelMediumType:
		return "#eab308" // yellow
	case domain.RiskLevelHighType:
		return "#f97316" // orange
	case domain.RiskLevelCriticalType:
		return "#ef4444" // red
	default:
		return "#6b7280" // gray
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:66</h2>
<pre>func (ui *UIAdapter) ScanTypeIcon(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "üì¶"
	case domain.ScanTypeHomebrewType:
		return "üç∫"
	case domain.ScanTypeSystemType:
		return "üíª"
	case domain.ScanTypeTempType:
		return "üóëÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:82</h2>
<pre>func (ui *UIAdapter) ScanTypeDescription(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "Nix store garbage collection and cleanup"
	case domain.ScanTypeHomebrewType:
		return "Homebrew package cleanup and maintenance"
	case domain.ScanTypeSystemType:
		return "System-level temporary files cleanup"
	case domain.ScanTypeTempType:
		return "Temporary files and cache cleanup"
	default:
		return "Unknown scan type"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:128</h2>
<pre>func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:160</h2>
<pre>func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:207</h2>
<pre>func (ui *UIAdapter) SafetyLevelIcon(level domain.SafetyLevelType) string {
	switch level {
	case domain.SafetyLevelDisabled:
		return "üî¥"
	case domain.SafetyLevelEnabled:
		return "üü¢"
	case domain.SafetyLevelStrict:
		return "üü°"
	case domain.SafetyLevelParanoid:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#5 found 4 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:314</h2>
<pre>func (c *ConfigurationWorkflowContext) shouldSeeScanResults() error {
	if !strings.Contains(c.commandOutput, "Total generations:") {
		return fmt.Errorf("expected scan results with generations, but got:\n%s", c.commandOutput)
	}
	return nil
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:328</h2>
<pre>func (c *ConfigurationWorkflowContext) shouldSeeDailyProfile() error {
	if !strings.Contains(c.commandOutput, "Using daily profile configuration") {
		return fmt.Errorf("expected to see daily profile usage, but got:\n%s", c.commandOutput)
	}
	return nil
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:335</h2>
<pre>func (c *ConfigurationWorkflowContext) shouldSeeDryRunMode() error {
	if !strings.Contains(c.commandOutput, "DRY-RUN mode") {
		return fmt.Errorf("expected to see dry-run mode, but got:\n%s", c.commandOutput)
	}
	return nil
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:378</h2>
<pre>func (c *ConfigurationWorkflowContext) shouldSeeScanResultsReflectingDailyProfile() error {
	if !strings.Contains(c.commandOutput, "Using daily profile configuration") {
		return fmt.Errorf("expected scan results to reflect daily profile, but got:\n%s", c.commandOutput)
	}
	return nil
}</pre>
<h1>#6 found 2 clones</h1>
<h2>internal/adapters/http_client.go:102</h2>
<pre>func (hc *HTTPClient) Post(ctx context.Context, url string, body any) (*HTTPResponse, error) {
	return hc.doRequest(ctx, "POST", url, body)
}</pre>
<h2>internal/adapters/http_client.go:107</h2>
<pre>func (hc *HTTPClient) Put(ctx context.Context, url string, body any) (*HTTPResponse, error) {
	return hc.doRequest(ctx, "PUT", url, body)
}</pre>
<h1>#7 found 4 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:179</h2>
<pre>func (c *ConfigurationWorkflowContext) haveUnsafeConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: false
max_disk_usage: 50
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "unsafe-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:198</h2>
<pre>func (c *ConfigurationWorkflowContext) haveBasicConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true`

	configPath := filepath.Join(c.tempDir, "basic-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:212</h2>
<pre>func (c *ConfigurationWorkflowContext) haveIncompleteConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected: []`

	configPath := filepath.Join(c.tempDir, "incomplete-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:221</h2>
<pre>func (c *ConfigurationWorkflowContext) haveMultiProfileConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
  - "/Library"
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true
  weekly:
    name: "weekly"
    description: "Weekly cleanup"
    enabled: true
    operations:
      - name: "package-caches"
        risk_level: "MEDIUM"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "multi-profile-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h1>#8 found 2 clones</h1>
<h2>internal/adapters/ui_adapter.go:18</h2>
<pre>func (ui *UIAdapter) RiskLevelIcon(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "üü¢"
	case domain.RiskLevelMediumType:
		return "üü°"
	case domain.RiskLevelHighType:
		return "üü†"
	case domain.RiskLevelCriticalType:
		return "üî¥"
	default:
		return "‚ö™"
	}
}

// CleanStrategyIcon returns the appropriate emoji icon for a clean strategy
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) CleanStrategyIcon(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "üî•"
	case domain.StrategyConservativeType:
		return "üõ°Ô∏è"
	case domain.StrategyDryRunType:
		return "üîç"
	default:
		return "‚ùì"
	}
}

// RiskLevelColor returns CSS color for risk level
func (ui *UIAdapter) RiskLevelColor(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "#22c55e" // green
	case domain.RiskLevelMediumType:
		return "#eab308" // yellow
	case domain.RiskLevelHighType:
		return "#f97316" // orange
	case domain.RiskLevelCriticalType:
		return "#ef4444" // red
	default:
		return "#6b7280" // gray
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:128</h2>
<pre>func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}

// SelectedStatusIcon returns appropriate emoji icon for selected status
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}

// RecursionLevelIcon returns appropriate emoji icon for recursion level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#9 found 4 clones</h1>
<h2>internal/adapters/ui_adapter.go:18</h2>
<pre>func (ui *UIAdapter) RiskLevelIcon(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "üü¢"
	case domain.RiskLevelMediumType:
		return "üü°"
	case domain.RiskLevelHighType:
		return "üü†"
	case domain.RiskLevelCriticalType:
		return "üî¥"
	default:
		return "‚ö™"
	}
}

// CleanStrategyIcon returns the appropriate emoji icon for a clean strategy
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) CleanStrategyIcon(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "üî•"
	case domain.StrategyConservativeType:
		return "üõ°Ô∏è"
	case domain.StrategyDryRunType:
		return "üîç"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:82</h2>
<pre>func (ui *UIAdapter) ScanTypeDescription(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "Nix store garbage collection and cleanup"
	case domain.ScanTypeHomebrewType:
		return "Homebrew package cleanup and maintenance"
	case domain.ScanTypeSystemType:
		return "System-level temporary files cleanup"
	case domain.ScanTypeTempType:
		return "Temporary files and cache cleanup"
	default:
		return "Unknown scan type"
	}
}

// CleanStrategyDescription returns human-readable description for strategy
func (ui *UIAdapter) CleanStrategyDescription(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "Aggressive cleanup with maximum disk space recovery"
	case domain.StrategyConservativeType:
		return "Conservative cleanup with safety-first approach"
	case domain.StrategyDryRunType:
		return "Preview mode - shows what would be cleaned without making changes"
	default:
		return "Unknown cleaning strategy"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:128</h2>
<pre>func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}

// SelectedStatusIcon returns appropriate emoji icon for selected status
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:160</h2>
<pre>func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}

// OptimizationLevelIcon returns appropriate emoji icon for optimization level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) OptimizationLevelIcon(level domain.OptimizationLevelType) string {
	switch level {
	case domain.OptimizationLevelNone:
		return "‚ö™"
	case domain.OptimizationLevelConservative:
		return "üü°"
	case domain.OptimizationLevelAggressive:
		return "üî¥"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#10 found 3 clones</h1>
<h2>internal/config/factories/profile_factory.go:10</h2>
<pre>       &domain.Profile{
	Name:        "daily",
	Description: "Daily cleanup",
	Operations: []domain.CleanupOperation{
		{
			Name:        "nix-generations",
			Description: "Clean Nix generations",
			RiskLevel:   domain.RiskLow,
			Status:      domain.StatusEnabled,
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h2>tests/bdd/nix_operations_test.go:158</h2>
<pre>              &domain.Profile{
	Name:        "dangerous-cleanup",
	Description: "High risk cleanup operation",
	Operations: []domain.CleanupOperation{
		{
			Name:        "delete-system-files",
			Description: "Delete system files (DANGEROUS)",
			RiskLevel:   ctx.riskLevel,
			Status:      domain.StatusEnabled,
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h2>tests/bdd/nix_operations_test.go:278</h2>
<pre>              &domain.Profile{
	Name:        "failing-cleanup",
	Description: "Profile that will fail",
	Operations: []domain.CleanupOperation{
		{
			Name:        "simulate-failure",
			Description: "Operation that fails",
			RiskLevel:   domain.RiskLow,
			Status:      domain.StatusEnabled,
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h1>#11 found 6 clones</h1>
<h2>internal/domain/type_safe_enums.go:110</h2>
<pre>var riskLevelHelper = NewEnumHelper(map[RiskLevelType]string{
	RiskLevelLowType:      "LOW",
	RiskLevelMediumType:   "MEDIUM",
	RiskLevelHighType:     "HIGH",
	RiskLevelCriticalType: "CRITICAL",
}, func(rl RiskLevelType) bool {
	return rl >= RiskLevelLowType && rl <= RiskLevelCriticalType
}, func() []RiskLevelType {
	return []RiskLevelType{
		RiskLevelLowType,
		RiskLevelMediumType,
		RiskLevelHighType,
		RiskLevelCriticalType,
	}
}, true)</pre>
<h2>internal/domain/type_safe_enums.go:228</h2>
<pre>var validationLevelHelper = NewEnumHelper(map[ValidationLevelType]string{
	ValidationLevelNoneType:          "NONE",
	ValidationLevelBasicType:         "BASIC",
	ValidationLevelComprehensiveType: "COMPREHENSIVE",
	ValidationLevelStrictType:        "STRICT",
}, func(vl ValidationLevelType) bool {
	return vl >= ValidationLevelNoneType && vl <= ValidationLevelStrictType
}, func() []ValidationLevelType {
	return []ValidationLevelType{
		ValidationLevelNoneType,
		ValidationLevelBasicType,
		ValidationLevelComprehensiveType,
		ValidationLevelStrictType,
	}
}, true)</pre>
<h2>internal/domain/type_safe_enums.go:395</h2>
<pre>var scanTypeHelper = NewEnumHelper(map[ScanTypeType]string{
	ScanTypeNixStoreType: "nix_store",
	ScanTypeHomebrewType: "homebrew",
	ScanTypeSystemType:   "system",
	ScanTypeTempType:     "temp_files",
}, func(st ScanTypeType) bool {
	return st >= ScanTypeNixStoreType && st <= ScanTypeTempType
}, func() []ScanTypeType {
	return []ScanTypeType{
		ScanTypeNixStoreType,
		ScanTypeHomebrewType,
		ScanTypeSystemType,
		ScanTypeTempType,
	}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:474</h2>
<pre>var enforcementLevelTypeHelper = NewEnumHelper(map[EnforcementLevelType]string{
	EnforcementLevelNone:    "none",
	EnforcementLevelWarning: "warning",
	EnforcementLevelError:   "error",
	EnforcementLevelStrict:  "strict",
}, func(el EnforcementLevelType) bool {
	return el >= EnforcementLevelNone && el <= EnforcementLevelStrict
}, func() []EnforcementLevelType {
	return []EnforcementLevelType{EnforcementLevelNone, EnforcementLevelWarning, EnforcementLevelError, EnforcementLevelStrict}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:587</h2>
<pre>var recursionLevelTypeHelper = NewEnumHelper(map[RecursionLevelType]string{
	RecursionLevelNone:     "none",
	RecursionLevelDirect:   "direct",
	RecursionLevelFull:     "full",
	RecursionLevelInfinite: "infinite",
}, func(rl RecursionLevelType) bool {
	return rl >= RecursionLevelNone && rl <= RecursionLevelInfinite
}, func() []RecursionLevelType {
	return []RecursionLevelType{RecursionLevelNone, RecursionLevelDirect, RecursionLevelFull, RecursionLevelInfinite}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:772</h2>
<pre>var safetyLevelTypeHelper = NewEnumHelper(map[SafetyLevelType]string{
	SafetyLevelDisabled: "disabled",
	SafetyLevelEnabled:  "enabled",
	SafetyLevelStrict:   "strict",
	SafetyLevelParanoid: "paranoid",
}, func(sl SafetyLevelType) bool {
	return sl >= SafetyLevelDisabled && sl <= SafetyLevelParanoid
}, func() []SafetyLevelType {
	return []SafetyLevelType{SafetyLevelDisabled, SafetyLevelEnabled, SafetyLevelStrict, SafetyLevelParanoid}
}, false)</pre>
<h1>#12 found 3 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:179</h2>
<pre>func (c *ConfigurationWorkflowContext) haveUnsafeConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: false
max_disk_usage: 50
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "unsafe-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveBasicConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true`

	configPath := filepath.Join(c.tempDir, "basic-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:198</h2>
<pre>func (c *ConfigurationWorkflowContext) haveBasicConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true`

	configPath := filepath.Join(c.tempDir, "basic-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveIncompleteConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected: []`

	configPath := filepath.Join(c.tempDir, "incomplete-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:212</h2>
<pre>func (c *ConfigurationWorkflowContext) haveIncompleteConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected: []`

	configPath := filepath.Join(c.tempDir, "incomplete-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveMultiProfileConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
  - "/Library"
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true
  weekly:
    name: "weekly"
    description: "Weekly cleanup"
    enabled: true
    operations:
      - name: "package-caches"
        risk_level: "MEDIUM"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "multi-profile-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h1>#13 found 14 clones</h1>
<h2>internal/config/safety_level_test.go:22</h2>
<pre>{
	name: "string enabled",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "enabled")
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:30</h2>
<pre>{
	name: "string disabled",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "disabled")
	},
	expected:         domain.SafetyLevelDisabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:38</h2>
<pre>{
	name: "string strict",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "strict")
	},
	expected:         domain.SafetyLevelStrict,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:46</h2>
<pre>{
	name: "string paranoid",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "paranoid")
	},
	expected:         domain.SafetyLevelParanoid,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:54</h2>
<pre>{
	name: "string with whitespace",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "  enabled  ")
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:62</h2>
<pre>{
	name: "string uppercase",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "ENABLED")
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:70</h2>
<pre>{
	name: "numeric 0",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 0)
	},
	expected:         domain.SafetyLevelDisabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:78</h2>
<pre>{
	name: "numeric 1",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 1)
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:86</h2>
<pre>{
	name: "numeric 2",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 2)
	},
	expected:         domain.SafetyLevelStrict,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:94</h2>
<pre>{
	name: "numeric 3",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 3)
	},
	expected:         domain.SafetyLevelParanoid,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:102</h2>
<pre>{
	name: "float64 1.0",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 1.0)
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:110</h2>
<pre>{
	name: "float64 1.5 (invalid float)",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 1.5)
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:143</h2>
<pre>{
	name: "invalid string defaults to enabled",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", "invalid")
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:151</h2>
<pre>{
	name: "invalid numeric defaults to enabled",
	setup: func(v *viper.Viper) {
		v.Set("safety_level", 999)
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h1>#14 found 2 clones</h1>
<h2>internal/config/config_fixer.go:81</h2>
<pre>if err := cf.v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.risk_level", profileName, opIndex), &riskLevelStr); err != nil {
	slog.Warn("Failed to unmarshal risk level", "err", err, "profile", profileName, "operation", opIndex)
}</pre>
<h2>internal/config/config_fixer.go:119</h2>
<pre>if err := cf.v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.status", profileName, opIndex), &opStatusStr); err != nil {
	slog.Warn("Failed to unmarshal operation status", "err", err, "profile", profileName, "operation", opIndex)
}</pre>
<h1>#15 found 2 clones</h1>
<h2>tests/bdd/nix_bdd_test.go:255</h2>
<pre>func (ctx *BDDTestContext) shouldSeeEstimatedSpace() error {
	if ctx.cleanResult.IsErr() {
		return ctx.cleanResult.Error()
	}

	result := ctx.cleanResult.Value()
	if result.FreedBytes <= 0 {
		return fmt.Errorf("expected positive estimated space but got: %d", result.FreedBytes)
	}

	return nil
}</pre>
<h2>tests/bdd/nix_bdd_test.go:268</h2>
<pre>func (ctx *BDDTestContext) shouldSeeGenerationsCount() error {
	if ctx.cleanResult.IsErr() {
		return ctx.cleanResult.Error()
	}

	result := ctx.cleanResult.Value()
	if result.ItemsRemoved < 0 {
		return fmt.Errorf("expected non-negative item count but got: %d", result.ItemsRemoved)
	}

	return nil
}</pre>
<h1>#16 found 2 clones</h1>
<h2>internal/cleaner/nix.go:95</h2>
<pre>cleanResult := domain.CleanResult{
	FreedBytes:   uint64(estimatedBytes),
	ItemsRemoved: uint(toRemove),
	ItemsFailed:  0,
	CleanTime:    0,
	CleanedAt:    time.Now(),
	Strategy:     domain.StrategyDryRun,
}</pre>
<h2>internal/cleaner/nix.go:158</h2>
<pre>cleanResult := domain.CleanResult{
	FreedBytes:   uint64(estimatedBytes),
	ItemsRemoved: uint(toRemove),
	ItemsFailed:  0,
	CleanTime:    0,
	CleanedAt:    time.Now(),
	Strategy:     domain.StrategyDryRun,
}</pre>
<h1>#17 found 6 clones</h1>
<h2>internal/adapters/ui_adapter.go:35</h2>
<pre>func (ui *UIAdapter) CleanStrategyIcon(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "üî•"
	case domain.StrategyConservativeType:
		return "üõ°Ô∏è"
	case domain.StrategyDryRunType:
		return "üîç"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:98</h2>
<pre>func (ui *UIAdapter) CleanStrategyDescription(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "Aggressive cleanup with maximum disk space recovery"
	case domain.StrategyConservativeType:
		return "Conservative cleanup with safety-first approach"
	case domain.StrategyDryRunType:
		return "Preview mode - shows what would be cleaned without making changes"
	default:
		return "Unknown cleaning strategy"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:113</h2>
<pre>func (ui *UIAdapter) StatusIcon(status domain.StatusType) string {
	switch status {
	case domain.StatusDisabled:
		return "üî¥"
	case domain.StatusEnabled:
		return "üü¢"
	case domain.StatusInherited:
		return "üîµ"
	default:
		return "‚ö™"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:145</h2>
<pre>func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:177</h2>
<pre>func (ui *UIAdapter) OptimizationLevelIcon(level domain.OptimizationLevelType) string {
	switch level {
	case domain.OptimizationLevelNone:
		return "‚ö™"
	case domain.OptimizationLevelConservative:
		return "üü°"
	case domain.OptimizationLevelAggressive:
		return "üî¥"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:192</h2>
<pre>func (ui *UIAdapter) FileSelectionStrategyIcon(strategy domain.FileSelectionStrategyType) string {
	switch strategy {
	case domain.FileSelectionStrategyAll:
		return "üìÅ"
	case domain.FileSelectionStrategyUnusedOnly:
		return "üóëÔ∏è"
	case domain.FileSelectionStrategyManual:
		return "‚úèÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#18 found 2 clones</h1>
<h2>internal/config/bdd_nix_validation_test.go:243</h2>
<pre>{
	Name:        "Invalid Nix generations below minimum",
	Description: "Should reject Nix generations below minimum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations below minimum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 0), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action:      whenConfigValidated,
		},
	},
	Then: thenValidationFailsWithError("generations constraint"),
}</pre>
<h2>internal/config/bdd_nix_validation_test.go:262</h2>
<pre>{
	Name:        "Invalid Nix generations above maximum",
	Description: "Should reject Nix generations above maximum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations above maximum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 15), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action:      whenConfigValidated,
		},
	},
	Then: thenValidationFailsWithError("generations constraint"),
}</pre>
<h1>#19 found 2 clones</h1>
<h2>internal/adapters/ui_adapter.go:49</h2>
<pre>func (ui *UIAdapter) RiskLevelColor(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "#22c55e" // green
	case domain.RiskLevelMediumType:
		return "#eab308" // yellow
	case domain.RiskLevelHighType:
		return "#f97316" // orange
	case domain.RiskLevelCriticalType:
		return "#ef4444" // red
	default:
		return "#6b7280" // gray
	}
}

// ScanTypeIcon returns appropriate emoji icon for a scan type
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) ScanTypeIcon(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "üì¶"
	case domain.ScanTypeHomebrewType:
		return "üç∫"
	case domain.ScanTypeSystemType:
		return "üíª"
	case domain.ScanTypeTempType:
		return "üóëÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:66</h2>
<pre>func (ui *UIAdapter) ScanTypeIcon(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "üì¶"
	case domain.ScanTypeHomebrewType:
		return "üç∫"
	case domain.ScanTypeSystemType:
		return "üíª"
	case domain.ScanTypeTempType:
		return "üóëÔ∏è"
	default:
		return "‚ùì"
	}
}

// ScanTypeDescription returns human-readable description for scan type
func (ui *UIAdapter) ScanTypeDescription(scanType domain.ScanTypeType) string {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "Nix store garbage collection and cleanup"
	case domain.ScanTypeHomebrewType:
		return "Homebrew package cleanup and maintenance"
	case domain.ScanTypeSystemType:
		return "System-level temporary files cleanup"
	case domain.ScanTypeTempType:
		return "Temporary files and cache cleanup"
	default:
		return "Unknown scan type"
	}
}</pre>
<h1>#20 found 2 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:141</h2>
<pre>func (c *ConfigurationWorkflowContext) haveValidConfigFile(filename string) error {
	configContent := `version: "1.0.0"
safe_mode: true
max_disk_usage: 50
protected:
  - "/System"
  - "/Library"
  - "/Applications"
  - "/usr"
  - "/etc"
  - "/var"
  - "/bin"
  - "/sbin"
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup"
    enabled: true
    operations:
      - name: "nix-generations"
        description: "Clean Nix generations"
        risk_level: "LOW"
        enabled: true`

	configPath := filepath.Join(c.tempDir, filename)
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:169</h2>
<pre>func (c *ConfigurationWorkflowContext) haveInvalidConfigFile(filename string) error {
	configContent := `version: "1.0.0"
safe_mode: true
invalid_field: true
profiles: []`

	configPath := filepath.Join(c.tempDir, filename)
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h1>#21 found 2 clones</h1>
<h2>internal/errors/adapters.go:131</h2>
<pre>func (nea *NetworkErrorAdapter) Adapt(err error, operation string) *CleanWizardError {
	if err == nil {
		return nil
	}

	// Only handle actual network errors
	if !isNetworkError(err) {
		return nil
	}

	return WrapError(err, ErrCodeConnectionFailed,
		"Network operation failed: "+operation).WithCaller()
}</pre>
<h2>internal/errors/adapters.go:172</h2>
<pre>func (sea *SystemErrorAdapter) Adapt(err error, component string) *CleanWizardError {
	if err == nil {
		return nil
	}

	// Only handle actual system errors
	if !isSystemError(err) {
		return nil
	}

	return WrapError(err, ErrCodeProcessFailed,
		"System component failed: "+component).WithCaller()
}</pre>
<h1>#22 found 2 clones</h1>
<h2>internal/config/test_data.go:53</h2>
<pre>           {
	baseConfig.Version = "  1.0.0  "
	baseConfig.Protected = []string{"/System", "/Library"}
	baseConfig.Profiles = map[string]*domain.Profile{
		"daily": {
			Name:        "  daily  ",
			Description: "Daily cleanup",
			Operations: []domain.CleanupOperation{
				{
					Name:        "nix-generations",
					Description: "Clean Nix generations",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
				},
			},
			Status: domain.StatusEnabled,
		},
	}
}</pre>
<h2>internal/config/test_data.go:71</h2>
<pre>       {
	baseConfig.Version = " 1.0.0 "                           // Extra spaces
	baseConfig.Protected = []string{"/System ", " /Library"} // Trailing/leading spaces
	baseConfig.Profiles = map[string]*domain.Profile{
		"daily": { // Normal key - sanitizer should clean up name field inside
			Name:        " daily cleanup ", // Extra spaces
			Description: " Daily cleanup ",
			Operations: []domain.CleanupOperation{
				{
					Name:        " nix-generations ",
					Description: " Clean Nix generations ",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
				},
			},
			Status: domain.StatusEnabled,
		},
	}
}</pre>
<h1>#23 found 2 clones</h1>
<h2>internal/errors/errors_test.go:119</h2>
<pre>t.Run("File not found", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrNotExist, Path: "/tmp/missing"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeFileNotFound, cwErr.Code)
	assert.Equal(t, ErrorTypeFileSystem, cwErr.Type)
	assert.Equal(t, SeverityWarning, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/missing")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h2>internal/errors/errors_test.go:131</h2>
<pre>t.Run("Permission denied", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrPermission, Path: "/tmp/protected"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodePermissionError, cwErr.Code)
	assert.Equal(t, ErrorTypePermission, cwErr.Type)
	assert.Equal(t, SeverityError, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/protected")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h1>#24 found 3 clones</h1>
<h2>internal/pkg/errors/errors.go:241</h2>
<pre>case "value":
	if v, ok := value.(string); ok {
		e.Details.Value = v
	} else {
		e.Details.Value = fmt.Sprintf("%v", value)
	}</pre>
<h2>internal/pkg/errors/errors.go:247</h2>
<pre>case "expected":
	if v, ok := value.(string); ok {
		e.Details.Expected = v
	} else {
		e.Details.Expected = fmt.Sprintf("%v", value)
	}</pre>
<h2>internal/pkg/errors/errors.go:253</h2>
<pre>case "actual":
	if v, ok := value.(string); ok {
		e.Details.Actual = v
	} else {
		e.Details.Actual = fmt.Sprintf("%v", value)
	}</pre>
<h1>#25 found 2 clones</h1>
<h2>internal/api/mapper_test.go:607</h2>
<pre>{
	name: "Unknown Operation Type",
	publicOp: PublicOperation{
		Name:        "unknown-operation",
		Description: "Unknown operation",
		RiskLevel:   PublicRiskLow,
		Enabled:     true,
		Settings:    OperationSettings{},
	},
	expectedType: domain.OperationType("unknown-operation"),
	shouldError:  false, // Should not error with custom operation support
}</pre>
<h2>internal/api/mapper_test.go:619</h2>
<pre>{
	name: "Custom Operation with hyphens",
	publicOp: PublicOperation{
		Name:        "my-custom-op",
		Description: "My custom operation",
		RiskLevel:   PublicRiskMedium,
		Enabled:     true,
		Settings:    OperationSettings{},
	},
	expectedType: domain.OperationType("my-custom-op"),
	shouldError:  false, // Should not error with custom operation support
}</pre>
<h1>#26 found 2 clones</h1>
<h2>internal/adapters/ui_adapter.go:113</h2>
<pre>func (ui *UIAdapter) StatusIcon(status domain.StatusType) string {
	switch status {
	case domain.StatusDisabled:
		return "üî¥"
	case domain.StatusEnabled:
		return "üü¢"
	case domain.StatusInherited:
		return "üîµ"
	default:
		return "‚ö™"
	}
}

// EnforcementLevelIcon returns appropriate emoji icon for enforcement level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}

// SelectedStatusIcon returns appropriate emoji icon for selected status
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:145</h2>
<pre>func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}

// RecursionLevelIcon returns appropriate emoji icon for recursion level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}

// OptimizationLevelIcon returns appropriate emoji icon for optimization level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) OptimizationLevelIcon(level domain.OptimizationLevelType) string {
	switch level {
	case domain.OptimizationLevelNone:
		return "‚ö™"
	case domain.OptimizationLevelConservative:
		return "üü°"
	case domain.OptimizationLevelAggressive:
		return "üî¥"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#27 found 3 clones</h1>
<h2>internal/api/mapper_test.go:559</h2>
<pre>{
	name: "Valid Nix Generations",
	publicOp: PublicOperation{
		Name:        "nix-generations",
		Description: "Clean Nix generations",
		RiskLevel:   PublicRiskLow,
		Enabled:     true,
		Settings:    OperationSettings{},
	},
	expectedType: domain.OperationTypeNixGenerations,
	shouldError:  false,
}</pre>
<h2>internal/api/mapper_test.go:571</h2>
<pre>{
	name: "Valid Temp Files",
	publicOp: PublicOperation{
		Name:        "temp-files",
		Description: "Clean temporary files",
		RiskLevel:   PublicRiskMedium,
		Enabled:     true,
		Settings:    OperationSettings{},
	},
	expectedType: domain.OperationTypeTempFiles,
	shouldError:  false,
}</pre>
<h2>internal/api/mapper_test.go:583</h2>
<pre>{
	name: "Valid Homebrew",
	publicOp: PublicOperation{
		Name:        "homebrew-cleanup",
		Description: "Clean Homebrew",
		RiskLevel:   PublicRiskHigh,
		Enabled:     true,
		Settings:    OperationSettings{},
	},
	expectedType: domain.OperationTypeHomebrew,
	shouldError:  false,
}</pre>
<h1>#28 found 2 clones</h1>
<h2>internal/result/type_test.go:115</h2>
<pre>func TestResult_IsOk(t *testing.T) {
	testResultMethod(t, "IsOk", func(r Result[int]) bool { return r.IsOk() }, true, false)
}</pre>
<h2>internal/result/type_test.go:119</h2>
<pre>func TestResult_IsErr(t *testing.T) {
	testResultMethod(t, "IsErr", func(r Result[int]) bool { return r.IsErr() }, false, true)
}</pre>
<h1>#29 found 6 clones</h1>
<h2>internal/domain/type_safe_enums.go:286</h2>
<pre>var changeOperationHelper = NewEnumHelper(map[ChangeOperationType]string{
	ChangeOperationAddedType:    "ADDED",
	ChangeOperationRemovedType:  "REMOVED",
	ChangeOperationModifiedType: "MODIFIED",
}, func(co ChangeOperationType) bool {
	return co >= ChangeOperationAddedType && co <= ChangeOperationModifiedType
}, func() []ChangeOperationType {
	return []ChangeOperationType{
		ChangeOperationAddedType,
		ChangeOperationRemovedType,
		ChangeOperationModifiedType,
	}
}, true)</pre>
<h2>internal/domain/type_safe_enums.go:340</h2>
<pre>var cleanStrategyHelper = NewEnumHelper(map[CleanStrategyType]string{
	StrategyAggressiveType:   "aggressive",
	StrategyConservativeType: "conservative",
	StrategyDryRunType:       "dry-run",
}, func(cs CleanStrategyType) bool {
	return cs >= StrategyAggressiveType && cs <= StrategyDryRunType
}, func() []CleanStrategyType {
	return []CleanStrategyType{
		StrategyAggressiveType,
		StrategyConservativeType,
		StrategyDryRunType,
	}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:422</h2>
<pre>var statusTypeHelper = NewEnumHelper(map[StatusType]string{
	StatusDisabled:  "disabled",
	StatusEnabled:   "enabled",
	StatusInherited: "inherited",
}, func(s StatusType) bool {
	return s >= StatusDisabled && s <= StatusInherited
}, func() []StatusType {
	return []StatusType{StatusDisabled, StatusEnabled, StatusInherited}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:526</h2>
<pre>var selectedStatusTypeHelper = NewEnumHelper(map[SelectedStatusType]string{
	SelectedStatusNotSelected: "not_selected",
	SelectedStatusSelected:    "selected",
	SelectedStatusDefault:     "default",
}, func(ss SelectedStatusType) bool {
	return ss >= SelectedStatusNotSelected && ss <= SelectedStatusDefault
}, func() []SelectedStatusType {
	return []SelectedStatusType{SelectedStatusNotSelected, SelectedStatusSelected, SelectedStatusDefault}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:639</h2>
<pre>var optimizationLevelTypeHelper = NewEnumHelper(map[OptimizationLevelType]string{
	OptimizationLevelNone:         "none",
	OptimizationLevelConservative: "conservative",
	OptimizationLevelAggressive:   "aggressive",
}, func(ol OptimizationLevelType) bool {
	return ol >= OptimizationLevelNone && ol <= OptimizationLevelAggressive
}, func() []OptimizationLevelType {
	return []OptimizationLevelType{OptimizationLevelNone, OptimizationLevelConservative, OptimizationLevelAggressive}
}, false)</pre>
<h2>internal/domain/type_safe_enums.go:690</h2>
<pre>var fileSelectionStrategyTypeHelper = NewEnumHelper(map[FileSelectionStrategyType]string{
	FileSelectionStrategyAll:        "all",
	FileSelectionStrategyUnusedOnly: "unused_only",
	FileSelectionStrategyManual:     "manual",
}, func(fss FileSelectionStrategyType) bool {
	return fss >= FileSelectionStrategyAll && fss <= FileSelectionStrategyManual
}, func() []FileSelectionStrategyType {
	return []FileSelectionStrategyType{FileSelectionStrategyAll, FileSelectionStrategyUnusedOnly, FileSelectionStrategyManual}
}, false)</pre>
<h1>#30 found 2 clones</h1>
<h2>internal/config/config.go:165</h2>
<pre>func createDailyProfile() *domain.Profile {
	return &domain.Profile{
		Name:        "daily",
		Description: "Quick daily cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean old Nix generations",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
			},
			{
				Name:        "temp-files",
				Description: "Clean temporary files",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeTempFiles),
			},
		},
		Status: domain.StatusEnabled,
	}
}</pre>
<h2>internal/config/config.go:190</h2>
<pre>func createAggressiveProfile() *domain.Profile {
	return &domain.Profile{
		Name:        "aggressive",
		Description: "Deep aggressive cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean old Nix generations",
				RiskLevel:   domain.RiskHigh,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
			},
			{
				Name:        "homebrew-cleanup",
				Description: "Clean old Homebrew packages",
				RiskLevel:   domain.RiskMedium,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeHomebrew),
			},
		},
		Status: domain.StatusEnabled,
	}
}</pre>
<h1>#31 found 2 clones</h1>
<h2>internal/config/validation_middleware_analysis.go:55</h2>
<pre>for _, path := range proposed {
	if !currentSet[path] {
		changes = append(changes, ConfigChange{
			Field:     field,
			OldValue:  nil,
			NewValue:  path,
			Operation: OperationAdded,
			Risk:      domain.RiskLow,
		})
	}
}</pre>
<h2>internal/config/validation_middleware_analysis.go:68</h2>
<pre>for _, path := range current {
	if !proposedSet[path] {
		changes = append(changes, ConfigChange{
			Field:     field,
			OldValue:  path,
			NewValue:  nil,
			Operation: OperationRemoved,
			Risk:      domain.RiskHigh, // Removing protected paths is risky
		})
	}
}</pre>
<h1>#32 found 2 clones</h1>
<h2>internal/config/safe_test.go:203</h2>
<pre>{
	name: "build valid profile",
	builderFunc: func() *SafeProfileBuilder {
		return NewSafeConfigBuilder().
			AddProfile("test", "test profile").
			AddOperation(CleanTypeNixStore, domain.RiskLow)
	},
	expectError: false,
}</pre>
<h2>internal/config/safe_test.go:221</h2>
<pre>{
	name: "build profile with high risk (valid)",
	builderFunc: func() *SafeProfileBuilder {
		return NewSafeConfigBuilder().
			AddProfile("test", "test profile").
			AddOperation(CleanTypeNixStore, domain.RiskHigh)
	},
	expectError: false,
}</pre>
<h1>#33 found 2 clones</h1>
<h2>internal/domain/types.go:46</h2>
<pre>func NewGenerationCount(count uint) (GenerationCount, error) {
	if count > 100 { // TODO: Make this configurable
		return 0, fmt.Errorf("generation count %d exceeds maximum allowed (100)", count)
	}
	return GenerationCount(count), nil
}</pre>
<h2>internal/domain/types.go:91</h2>
<pre>func NewMaxDiskUsage(percentage uint8) (MaxDiskUsage, error) {
	if percentage > 100 {
		return 0, fmt.Errorf("max disk usage percentage %d exceeds 100", percentage)
	}
	return MaxDiskUsage(percentage), nil
}</pre>
<h1>#34 found 3 clones</h1>
<h2>internal/config/safe_test.go:37</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := tt.level.String()
		if result != tt.expected {
			t.Errorf("String() = %v, want %v", result, tt.expected)
		}
	})
}</pre>
<h2>internal/config/safe_test.go:87</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := tt.level.IsValid()
		if result != tt.expected {
			t.Errorf("IsValid() = %v, want %v", result, tt.expected)
		}
	})
}</pre>
<h2>internal/config/safe_test.go:111</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := tt.cleanType.IsValid()
		if result != tt.expected {
			t.Errorf("IsValid() = %v, want %v", result, tt.expected)
		}
	})
}</pre>
<h1>#35 found 2 clones</h1>
<h2>internal/config/safety_level_test.go:118</h2>
<pre>{
	name: "legacy safe_mode true",
	setup: func(v *viper.Viper) {
		v.Set("safe_mode", true)
	},
	expected:         domain.SafetyLevelEnabled,
	expectedExplicit: true,
}</pre>
<h2>internal/config/safety_level_test.go:126</h2>
<pre>{
	name: "legacy safe_mode false",
	setup: func(v *viper.Viper) {
		v.Set("safe_mode", false)
	},
	expected:         domain.SafetyLevelDisabled,
	expectedExplicit: true,
}</pre>
<h1>#36 found 2 clones</h1>
<h2>internal/config/config_fixer.go:34</h2>
<pre>if err := cf.v.UnmarshalKey(fmt.Sprintf("profiles.%s.enabled", name), &profileEnabled); err != nil {
	slog.Warn("Failed to unmarshal profile enabled flag", "err", err, "profile", name)
}</pre>
<h2>internal/config/config_fixer.go:45</h2>
<pre>if err := cf.v.UnmarshalKey(fmt.Sprintf("profiles.%s.status", name), &profileStatusStr); err != nil {
	slog.Warn("Failed to unmarshal profile status", "err", err, "profile", name)
}</pre>
<h1>#37 found 5 clones</h1>
<h2>internal/config/semver_validation_test.go:34</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := isValidSemver(tt.version)
		if result != tt.expected {
			t.Errorf("isValidSemver(%q) = %v, want %v", tt.version, result, tt.expected)
		}
	})
}</pre>
<h2>internal/format/format_test.go:25</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := Size(tt.bytes)
		if result != tt.expected {
			t.Errorf("Size(%d) = %v, want %v", tt.bytes, result, tt.expected)
		}
	})
}</pre>
<h2>internal/format/format_test.go:50</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := Duration(tt.duration)
		if result != tt.expected {
			t.Errorf("Duration(%v) = %v, want %v", tt.duration, result, tt.expected)
		}
	})
}</pre>
<h2>internal/format/format_test.go:71</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := Date(tt.t)
		if result != tt.expected {
			t.Errorf("Date(%v) = %v, want %v", tt.t, result, tt.expected)
		}
	})
}</pre>
<h2>internal/format/format_test.go:128</h2>
<pre>for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		result := Number(tt.n)
		if result != tt.expected {
			t.Errorf("Number(%d) = %v, want %v", tt.n, result, tt.expected)
		}
	})
}</pre>
<h1>#38 found 2 clones</h1>
<h2>internal/adapters/http_client.go:97</h2>
<pre>func (hc *HTTPClient) Get(ctx context.Context, url string) (*HTTPResponse, error) {
	return hc.doRequest(ctx, "GET", url, nil)
}</pre>
<h2>internal/adapters/http_client.go:112</h2>
<pre>func (hc *HTTPClient) Delete(ctx context.Context, url string) (*HTTPResponse, error) {
	return hc.doRequest(ctx, "DELETE", url, nil)
}</pre>
<h1>#39 found 2 clones</h1>
<h2>internal/middleware/validation.go:34</h2>
<pre>func (vm *ValidationMiddleware) ValidateScanRequest(ctx context.Context, req domain.ScanRequest) result.Result[domain.ScanRequest] {
	return validateRequest(req, "scan")
}</pre>
<h2>internal/middleware/validation.go:39</h2>
<pre>func (vm *ValidationMiddleware) ValidateCleanRequest(ctx context.Context, req domain.CleanRequest) result.Result[domain.CleanRequest] {
	return validateRequest(req, "clean")
}</pre>
<h1>#40 found 2 clones</h1>
<h2>internal/adapters/nix.go:130</h2>
<pre>cleanResult := domain.CleanResult{
	FreedBytes:   uint64(bytesFreed),
	ItemsRemoved: 1,
	ItemsFailed:  0,
	CleanTime:    time.Since(startTime),
	CleanedAt:    time.Now(),
	Strategy:     domain.StrategyAggressive,
}</pre>
<h2>internal/adapters/nix.go:186</h2>
<pre>cleanResult := domain.CleanResult{
	FreedBytes:   uint64(bytesFreed),
	ItemsRemoved: 1,
	ItemsFailed:  0,
	CleanTime:    time.Since(startTime),
	CleanedAt:    time.Now(),
	Strategy:     domain.StrategyConservative,
}</pre>
<h1>#41 found 2 clones</h1>
<h2>internal/adapters/environment.go:123</h2>
<pre>func GetEnvBool(key string, defaultValue bool) bool {
	if value, exists := os.LookupEnv(key); exists {
		if parsed, err := strconv.ParseBool(value); err == nil {
			return parsed
		}
	}
	return defaultValue
}</pre>
<h2>internal/adapters/environment.go:133</h2>
<pre>func GetEnvInt(key string, defaultValue int) int {
	if value, exists := os.LookupEnv(key); exists {
		if parsed, err := strconv.Atoi(value); err == nil {
			return parsed
		}
	}
	return defaultValue
}</pre>
<h1>#42 found 3 clones</h1>
<h2>internal/config/type_safe_validation_rules_test.go:127</h2>
<pre>if original.MaxDiskUsage != nil && copied.MaxDiskUsage != nil {
	if original.MaxDiskUsage.Required == copied.MaxDiskUsage.Required {
		t.Error("FAILED: modified copied.MaxDiskUsage.Required affected original")
	}
	if *original.MaxDiskUsage.Min == *copied.MaxDiskUsage.Min {
		t.Error("FAILED: modified copied.MaxDiskUsage.Min affected original")
	}
	if *original.MaxDiskUsage.Max == *copied.MaxDiskUsage.Max {
		t.Error("FAILED: modified copied.MaxDiskUsage.Max affected original")
	}
	if original.MaxDiskUsage.Message == copied.MaxDiskUsage.Message {
		t.Error("FAILED: modified copied.MaxDiskUsage.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:142</h2>
<pre>if original.MinProtectedPaths != nil && copied.MinProtectedPaths != nil {
	if original.MinProtectedPaths.Required == copied.MinProtectedPaths.Required {
		t.Error("FAILED: modified copied.MinProtectedPaths.Required affected original")
	}
	if *original.MinProtectedPaths.Min == *copied.MinProtectedPaths.Min {
		t.Error("FAILED: modified copied.MinProtectedPaths.Min affected original")
	}
	if *original.MinProtectedPaths.Max == *copied.MinProtectedPaths.Max {
		t.Error("FAILED: modified copied.MinProtectedPaths.Max affected original")
	}
	if original.MinProtectedPaths.Message == copied.MinProtectedPaths.Message {
		t.Error("FAILED: modified copied.MinProtectedPaths.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:157</h2>
<pre>if original.MaxProfiles != nil && copied.MaxProfiles != nil {
	if original.MaxProfiles.Required == copied.MaxProfiles.Required {
		t.Error("FAILED: modified copied.MaxProfiles.Required affected original")
	}
	if *original.MaxProfiles.Min == *copied.MaxProfiles.Min {
		t.Error("FAILED: modified copied.MaxProfiles.Min affected original")
	}
	if *original.MaxProfiles.Max == *copied.MaxProfiles.Max {
		t.Error("FAILED: modified copied.MaxProfiles.Max affected original")
	}
	if original.MaxProfiles.Message == copied.MaxProfiles.Message {
		t.Error("FAILED: modified copied.MaxProfiles.Message affected original")
	}
}</pre>
<h1>#43 found 2 clones</h1>
<h2>internal/config/type_safe_validation_rules_test.go:173</h2>
<pre>if copied.ProfileNamePattern != nil {
	copied.ProfileNamePattern.Required = !original.ProfileNamePattern.Required
	copied.ProfileNamePattern.Pattern = "MODIFIED_PATTERN"
	copied.ProfileNamePattern.Message = "MODIFIED STRING MESSAGE"
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:178</h2>
<pre>if copied.PathPattern != nil {
	copied.PathPattern.Required = !original.PathPattern.Required
	copied.PathPattern.Pattern = "ANOTHER_MODIFIED_PATTERN"
	copied.PathPattern.Message = "ANOTHER MESSAGE MODIFIED"
}</pre>
<h1>#44 found 2 clones</h1>
<h2>internal/config/safe_test.go:128</h2>
<pre>{
	name: "build valid config",
	builderFunc: func() *SafeConfigBuilder {
		return NewSafeConfigBuilder().
			AddProfile("test", "test profile").
			AddOperation(CleanTypeNixStore, domain.RiskLow).
			Done()
	},
	expectError: false,
}</pre>
<h2>internal/config/safe_test.go:146</h2>
<pre>{
	name: "build config with valid risk level only",
	builderFunc: func() *SafeConfigBuilder {
		return NewSafeConfigBuilder().
			AddProfile("test", "test profile").
			AddOperation(CleanTypeNixStore, domain.RiskLow).
			Done()
	},
	expectError: false,
}</pre>
<h1>#45 found 2 clones</h1>
<h2>internal/config/enhanced_loader_types.go:23</h2>
<pre>func (vl ValidationLevel) String() string {
	switch vl {
	case ValidationLevelNone:
		return "NONE"
	case ValidationLevelBasic:
		return "BASIC"
	case ValidationLevelComprehensive:
		return "COMPREHENSIVE"
	case ValidationLevelStrict:
		return "STRICT"
	default:
		return "UNKNOWN"
	}
}</pre>
<h2>internal/pkg/errors/errors.go:89</h2>
<pre>func (e ErrorLevel) String() string {
	switch e {
	case LevelInfo:
		return "INFO"
	case LevelWarn:
		return "WARN"
	case LevelError:
		return "ERROR"
	case LevelFatal:
		return "FATAL"
	default:
		return "UNDEFINED"
	}
}</pre>
<h1>#46 found 2 clones</h1>
<h2>internal/api/mapper_test.go:119</h2>
<pre>if operation.Settings.NixGenerations.Generations != defaultSettings.NixGenerations.Generations {
	t.Errorf("Expected generations %d, got %d", defaultSettings.NixGenerations.Generations, operation.Settings.NixGenerations.Generations)
}</pre>
<h2>internal/api/mapper_test.go:122</h2>
<pre>if operation.Settings.NixGenerations.Optimization != defaultSettings.NixGenerations.Optimization {
	t.Errorf("Expected optimization %v, got %v", defaultSettings.NixGenerations.Optimization, operation.Settings.NixGenerations.Optimization)
}</pre>
<h1>#47 found 2 clones</h1>
<h2>internal/config/validator_business.go:13</h2>
<pre>        ValidationError{
	Field:      fmt.Sprintf("profiles.%s.operations.%s.risk_level", profileName, op.Name),
	Rule:       "security",
	Value:      op.RiskLevel,
	Message:    fmt.Sprintf("Critical risk operation '%s' requires safety level enabled", op.Name),
	Severity:   SeverityError,
	Suggestion: "Enable safety level or remove critical risk operations",
}</pre>
<h2>internal/config/validator_business.go:58</h2>
<pre>                                      ValidationError{
	Field:      fmt.Sprintf("profiles.%s.operations.%s.risk_level", name, op.Name),
	Rule:       "business_logic",
	Value:      op.RiskLevel,
	Message:    fmt.Sprintf("Critical risk operation '%s' not allowed in unsafe mode", op.Name),
	Severity:   SeverityError,
	Suggestion: "Enable safe mode or remove critical risk operation",
}</pre>
<h1>#48 found 2 clones</h1>
<h2>internal/errors/errors_test.go:40</h2>
<pre>func TestCleanWizardError_IsType(t *testing.T) {
	err := NewError(ErrCodeInvalidGeneration, "Invalid generation")

	assert.True(t, err.IsType(ErrorTypeDomain))
	assert.False(t, err.IsType(ErrorTypeConfig))
}</pre>
<h2>internal/errors/errors_test.go:47</h2>
<pre>func TestCleanWizardError_IsCode(t *testing.T) {
	err := NewError(ErrCodeInvalidGeneration, "Invalid generation")

	assert.True(t, err.IsCode(ErrCodeInvalidGeneration))
	assert.False(t, err.IsCode(ErrCodeInvalidSettings))
}</pre>
<h1>#49 found 4 clones</h1>
<h2>internal/adapters/ui_adapter.go:35</h2>
<pre>func (ui *UIAdapter) CleanStrategyIcon(strategy domain.CleanStrategyType) string {
	switch strategy {
	case domain.StrategyAggressiveType:
		return "üî•"
	case domain.StrategyConservativeType:
		return "üõ°Ô∏è"
	case domain.StrategyDryRunType:
		return "üîç"
	default:
		return "‚ùì"
	}
}

// RiskLevelColor returns CSS color for risk level
func (ui *UIAdapter) RiskLevelColor(risk domain.RiskLevelType) string {
	switch risk {
	case domain.RiskLevelLowType:
		return "#22c55e" // green
	case domain.RiskLevelMediumType:
		return "#eab308" // yellow
	case domain.RiskLevelHighType:
		return "#f97316" // orange
	case domain.RiskLevelCriticalType:
		return "#ef4444" // red
	default:
		return "#6b7280" // gray
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:113</h2>
<pre>func (ui *UIAdapter) StatusIcon(status domain.StatusType) string {
	switch status {
	case domain.StatusDisabled:
		return "üî¥"
	case domain.StatusEnabled:
		return "üü¢"
	case domain.StatusInherited:
		return "üîµ"
	default:
		return "‚ö™"
	}
}

// EnforcementLevelIcon returns appropriate emoji icon for enforcement level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) EnforcementLevelIcon(level domain.EnforcementLevelType) string {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:145</h2>
<pre>func (ui *UIAdapter) SelectedStatusIcon(status domain.SelectedStatusType) string {
	switch status {
	case domain.SelectedStatusNotSelected:
		return "‚≠ï"
	case domain.SelectedStatusSelected:
		return "‚úÖ"
	case domain.SelectedStatusDefault:
		return "üåü"
	default:
		return "‚ùì"
	}
}

// RecursionLevelIcon returns appropriate emoji icon for recursion level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) RecursionLevelIcon(level domain.RecursionLevelType) string {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:192</h2>
<pre>func (ui *UIAdapter) FileSelectionStrategyIcon(strategy domain.FileSelectionStrategyType) string {
	switch strategy {
	case domain.FileSelectionStrategyAll:
		return "üìÅ"
	case domain.FileSelectionStrategyUnusedOnly:
		return "üóëÔ∏è"
	case domain.FileSelectionStrategyManual:
		return "‚úèÔ∏è"
	default:
		return "‚ùì"
	}
}

// SafetyLevelIcon returns appropriate emoji icon for safety level
// UI CONCERN: Properly separated from domain layer
func (ui *UIAdapter) SafetyLevelIcon(level domain.SafetyLevelType) string {
	switch level {
	case domain.SafetyLevelDisabled:
		return "üî¥"
	case domain.SafetyLevelEnabled:
		return "üü¢"
	case domain.SafetyLevelStrict:
		return "üü°"
	case domain.SafetyLevelParanoid:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#50 found 2 clones</h1>
<h2>internal/api/mapper_test.go:324</h2>
<pre>for _, tc := range testCases {
	t.Run(string(tc.public), func(t *testing.T) {
		// Test public to domain
		domainStrategy, err := MapStrategyToDomain(tc.public)
		if err != nil {
			t.Errorf("Expected successful mapping, got error: %v", err)
		}

		if domainStrategy != tc.domain {
			t.Errorf("Expected domain strategy %v, got %v", tc.domain, domainStrategy)
		}

		// Test domain to public
		publicStrategy := MapStrategyToPublic(tc.domain)
		if publicStrategy != tc.public {
			t.Errorf("Expected public strategy %s, got %s", tc.public, publicStrategy)
		}
	})
}</pre>
<h2>internal/api/mapper_test.go:357</h2>
<pre>for _, tc := range testCases {
	t.Run(string(tc.public), func(t *testing.T) {
		// Test public to domain
		domainLevel, err := MapRiskLevelToDomain(tc.public)
		if err != nil {
			t.Errorf("Expected successful mapping, got error: %v", err)
		}

		if domainLevel != tc.domain {
			t.Errorf("Expected domain level %v, got %v", tc.domain, domainLevel)
		}

		// Test domain to public
		publicLevel := MapRiskLevelToPublic(tc.domain)
		if publicLevel != tc.public {
			t.Errorf("Expected public level %s, got %s", tc.public, publicLevel)
		}
	})
}</pre>
<h1>#51 found 2 clones</h1>
<h2>internal/config/sanitizer_profile_main.go:54</h2>
<pre>if cs.rules.TrimWhitespace {
	original := op.Name
	op.Name = strings.TrimSpace(op.Name)
	if original != op.Name {
		result.addChange(fieldPrefix+".name", original, op.Name, "trimmed whitespace")
	}
}</pre>
<h2>internal/config/sanitizer_profile_main.go:63</h2>
<pre>if cs.rules.TrimWhitespace {
	original := op.Description
	op.Description = strings.TrimSpace(op.Description)
	if original != op.Description {
		result.addChange(fieldPrefix+".description", original, op.Description, "trimmed whitespace")
	}
}</pre>
<h1>#52 found 5 clones</h1>
<h2>internal/config/validator_field.go:13</h2>
<pre>                                                  {
	result.Errors = append(result.Errors, ValidationError{
		Field:      "max_disk_usage",
		Rule:       "range",
		Value:      cfg.MaxDiskUsage,
		Message:    "Max disk usage must be between 0 and 100 percent",
		Severity:   SeverityError,
		Suggestion: "Set a reasonable disk usage percentage (e.g., 80)",
	})
}</pre>
<h2>internal/config/validator_structure.go:27</h2>
<pre>                     {
	result.Errors = append(result.Errors, ValidationError{
		Field:      "version",
		Rule:       "required",
		Value:      cfg.Version,
		Message:    "Configuration version is required",
		Severity:   SeverityError,
		Suggestion: "Add version field with semantic version (e.g., '1.0.0')",
	})
}</pre>
<h2>internal/config/validator_structure.go:36</h2>
<pre>                                      {
	result.Errors = append(result.Errors, ValidationError{
		Field:      "version",
		Rule:       "semver_format",
		Value:      cfg.Version,
		Message:    "Version must follow semantic version format (MAJOR.MINOR.PATCH)",
		Severity:   SeverityError,
		Suggestion: "Change version to valid semantic version (e.g., '1.0.0', '2.1.3', '1.0.0-alpha')",
	})
}</pre>
<h2>internal/config/validator_structure.go:48</h2>
<pre>                          {
	result.Errors = append(result.Errors, ValidationError{
		Field:      "profiles",
		Rule:       "required",
		Value:      cfg.Profiles,
		Message:    "At least one profile is required",
		Severity:   SeverityError,
		Suggestion: "Add a profile with at least one operation",
	})
}</pre>
<h2>internal/config/validator_structure.go:60</h2>
<pre>                           {
	result.Errors = append(result.Errors, ValidationError{
		Field:      "protected",
		Rule:       "required",
		Value:      cfg.Protected,
		Message:    "Protected paths cannot be empty",
		Severity:   SeverityError,
		Suggestion: "Add system paths like /System, /Applications, /Library",
	})
}</pre>
<h1>#53 found 2 clones</h1>
<h2>internal/errors/adapters.go:28</h2>
<pre>func isConfigurationError(err error) bool {
	configIndicators := []string{
		"config", "configuration", "yaml", "json", "toml",
		"parse", "invalid", "missing", "required",
	}
	return isErrorType(err, configIndicators)
}</pre>
<h2>internal/errors/adapters.go:118</h2>
<pre>func isValidationError(err error) bool {
	validationIndicators := []string{
		"validation failed", "validation error", "invalid format",
		"invalid range", "required field", "constraint violation",
		"unacceptable value", "validation rule", "invalid value",
	}
	return isErrorType(err, validationIndicators)
}</pre>
<h1>#54 found 2 clones</h1>
<h2>internal/config/sanitizer_profile_main.go:25</h2>
<pre>if cs.rules.TrimWhitespace {
	original := profile.Name
	profile.Name = strings.TrimSpace(profile.Name)
	if original != profile.Name {
		result.addChange(fmt.Sprintf("profiles.%s.name", name), original, profile.Name, "trimmed whitespace")
	}
}</pre>
<h2>internal/config/sanitizer_profile_main.go:34</h2>
<pre>if cs.rules.TrimWhitespace {
	original := profile.Description
	profile.Description = strings.TrimSpace(profile.Description)
	if original != profile.Description {
		result.addChange(fmt.Sprintf("profiles.%s.description", name), original, profile.Description, "trimmed whitespace")
	}
}</pre>
<h1>#55 found 2 clones</h1>
<h2>cmd/clean-wizard/commands/profile.go:43</h2>
<pre>func NewProfileSelectCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "select [profile-name]",
		Short: "Select a profile as the default",
		Long:  `Select a profile as the default for future clean and scan operations.`,
		Args:  cobra.ExactArgs(1),
		RunE:  runProfileSelect,
	}
}</pre>
<h2>cmd/clean-wizard/commands/profile.go:54</h2>
<pre>func NewProfileInfoCommand() *cobra.Command {
	return &cobra.Command{
		Use:   "info [profile-name]",
		Short: "Show detailed information about a profile",
		Long:  `Show detailed information about a specific profile including all operations and their settings.`,
		Args:  cobra.MaximumNArgs(1),
		RunE:  runProfileInfo,
	}
}</pre>
<h1>#56 found 2 clones</h1>
<h2>internal/errors/errors_test.go:167</h2>
<pre>func TestConfigErrorAdapter(t *testing.T) {
	adapter := &ConfigErrorAdapter{}
	originalErr := errors.New("invalid config")

	cwErr := adapter.Adapt(originalErr, "main configuration")

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeInvalidConfig, cwErr.Code)
	assert.Equal(t, ErrorTypeConfig, cwErr.Type)
	assert.Equal(t, SeverityInfo, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "main configuration")
	assert.Equal(t, originalErr, cwErr.Cause)
}</pre>
<h2>internal/errors/errors_test.go:181</h2>
<pre>func TestValidationErrorAdapter(t *testing.T) {
	adapter := &ValidationErrorAdapter{}
	originalErr := errors.New("invalid value")

	cwErr := adapter.Adapt(originalErr, "email field")

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeValidationFailed, cwErr.Code)
	assert.Equal(t, ErrorTypeValidation, cwErr.Type)
	assert.Equal(t, SeverityError, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "email field")
	assert.Equal(t, originalErr, cwErr.Cause)
}</pre>
<h1>#57 found 2 clones</h1>
<h2>tests/bdd/nix_operations_test.go:198</h2>
<pre>func (ctx *NixOperationsContext) ThenPreventOperation() error {
	require.Error(ctx.t, ctx.error, "Should have an error for high-risk operation")
	assert.Contains(ctx.t, ctx.error.Error(), "operation delete-system-files prevented",
		"Error should mention operation prevention")
	return nil
}

func (ctx *NixOperationsContext) AndShowRiskWarning() error {
	expectedWarning := "Prevented high-risk operation: delete-system-files"
	found := slices.Contains(ctx.logMessages, expectedWarning)
	assert.True(ctx.t, found, "Should log risk warning: %s", expectedWarning)
	return nil
}</pre>
<h2>tests/bdd/nix_operations_test.go:354</h2>
<pre>func (ctx *NixOperationsContext) ThenPreventConcurrentExecution() error {
	require.Error(ctx.t, ctx.error, "Should prevent concurrent execution")
	assert.Contains(ctx.t, ctx.error.Error(), "already in progress",
		"Error should mention concurrent operation")
	return nil
}

func (ctx *NixOperationsContext) AndShowAppropriateError() error {
	expectedLog := "Concurrent cleanup attempt prevented"
	found := slices.Contains(ctx.logMessages, expectedLog)
	assert.True(ctx.t, found, "Should log concurrent prevention: %s", expectedLog)
	return nil
}</pre>
<h1>#58 found 2 clones</h1>
<h2>internal/config/bdd_nix_validation_test.go:213</h2>
<pre>When: []BDDWhen{
	{
		Description: "the configuration is validated",
		Action: func(cfg *domain.Config) (*ValidationResult, error) {
			validator := NewConfigValidator()
			return validator.ValidateConfig(cfg), nil
		},
	},
}</pre>
<h2>internal/config/bdd_nix_validation_test.go:292</h2>
<pre>When: []BDDWhen{
	{
		Description: "the configuration is validated",
		Action: func(cfg *domain.Config) (*ValidationResult, error) {
			validator := NewConfigValidator()
			return validator.ValidateConfig(cfg), nil
		},
	},
}</pre>
<h1>#59 found 2 clones</h1>
<h2>internal/config/sanitizer_homebrew.go:36</h2>
<pre>                                                   {
	original := settings.Prune
	settings.Prune = strings.TrimSpace(settings.Prune)
	if original != settings.Prune {
		result.addChange(fieldPrefix+".prune", original, settings.Prune, "trimmed whitespace")
	}
}</pre>
<h2>internal/config/sanitizer_profile_main.go:63</h2>
<pre>                           {
	original := op.Description
	op.Description = strings.TrimSpace(op.Description)
	if original != op.Description {
		result.addChange(fieldPrefix+".description", original, op.Description, "trimmed whitespace")
	}
}</pre>
<h1>#60 found 2 clones</h1>
<h2>internal/config/test_data.go:113</h2>
<pre>func GetSanitizationTestCasesCompat() []SanitizationTestCase {
	standardCases := GetStandardTestCases()
	result := make([]SanitizationTestCase, len(standardCases))
	for i, tc := range standardCases {
		result[i] = SanitizationTestCase(tc)
	}
	return result
}</pre>
<h2>internal/config/validation_types_test.go:30</h2>
<pre>func GetStandardTestCasesCompatWrapper() []SanitizationTestCase {
	standardCases := GetStandardTestCases()
	result := make([]SanitizationTestCase, len(standardCases))
	for i, tc := range standardCases {
		result[i] = SanitizationTestCase(tc)
	}
	return result
}</pre>
<h1>#61 found 3 clones</h1>
<h2>internal/config/type_safe_validation_rules_test.go:107</h2>
<pre>if copied.MaxDiskUsage != nil {
	copied.MaxDiskUsage.Required = !original.MaxDiskUsage.Required
	copied.MaxDiskUsage.Min = intPtr(999)
	copied.MaxDiskUsage.Max = intPtr(888)
	copied.MaxDiskUsage.Message = "MODIFIED MESSAGE"
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:113</h2>
<pre>if copied.MinProtectedPaths != nil {
	copied.MinProtectedPaths.Required = !original.MinProtectedPaths.Required
	copied.MinProtectedPaths.Min = intPtr(777)
	copied.MinProtectedPaths.Max = intPtr(666)
	copied.MinProtectedPaths.Message = "MODIFIED MESSAGE TOO"
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:119</h2>
<pre>if copied.MaxProfiles != nil {
	copied.MaxProfiles.Required = !original.MaxProfiles.Required
	copied.MaxProfiles.Min = intPtr(555)
	copied.MaxProfiles.Max = intPtr(444)
	copied.MaxProfiles.Message = "MODIFIED MAX PROFILES MESSAGE"
}</pre>
<h1>#62 found 2 clones</h1>
<h2>cmd/clean-wizard/commands/clean.go:59</h2>
<pre>       {
	// Load default configuration to get profile information
	var err error
	loadedCfg, err = config.LoadWithContext(ctx)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Could not load default configuration: %v\n", err)
		// Continue without profile support
	} else {
		fmt.Printf("üìã Using configuration from ~/.clean-wizard.yaml\n")
	}
}</pre>
<h2>cmd/clean-wizard/commands/scan.go:51</h2>
<pre>       {
	// Load default configuration to get profile information
	var err error
	loadedCfg, err = config.LoadWithContext(ctx)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Could not load default configuration: %v\n", err)
		// Continue without profile support
	} else {
		fmt.Printf("üìã Using configuration from ~/.clean-wizard.yaml\n")
	}
}</pre>
<h1>#63 found 2 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:179</h2>
<pre>func (c *ConfigurationWorkflowContext) haveUnsafeConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: false
max_disk_usage: 50
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "unsafe-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveBasicConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true`

	configPath := filepath.Join(c.tempDir, "basic-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveIncompleteConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected: []`

	configPath := filepath.Join(c.tempDir, "incomplete-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h2>tests/bdd/configuration_workflow_bdd_test.go:198</h2>
<pre>func (c *ConfigurationWorkflowContext) haveBasicConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
profiles:
  daily:
    name: "daily"
    enabled: true`

	configPath := filepath.Join(c.tempDir, "basic-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveIncompleteConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected: []`

	configPath := filepath.Join(c.tempDir, "incomplete-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}

func (c *ConfigurationWorkflowContext) haveMultiProfileConfigFile() error {
	configContent := `version: "1.0.0"
safe_mode: true
protected:
  - "/System"
  - "/Library"
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup"
    enabled: true
    operations:
      - name: "nix-generations"
        risk_level: "LOW"
        enabled: true
  weekly:
    name: "weekly"
    description: "Weekly cleanup"
    enabled: true
    operations:
      - name: "package-caches"
        risk_level: "MEDIUM"
        enabled: true`

	configPath := filepath.Join(c.tempDir, "multi-profile-config.yaml")
	return ioutil.WriteFile(configPath, []byte(configContent), 0o644)
}</pre>
<h1>#64 found 2 clones</h1>
<h2>tests/bdd/nix_operations_test.go:373</h2>
<pre>t.Run("Happy Path Nix Cleanup", func(t *testing.T) {
	err := ctx.GivenValidNixInstallation()
	require.NoError(t, err)

	err = ctx.WhenRunningNixGenerationsCleanup()
	require.NoError(t, err)

	err = ctx.ThenRemoveOldGenerationsAndKeepCurrent()
	require.NoError(t, err)

	err = ctx.AndLogOperationsPerformed()
	require.NoError(t, err)
})</pre>
<h2>tests/bdd/nix_operations_test.go:418</h2>
<pre>t.Run("Error Recovery", func(t *testing.T) {
	err := ctx.GivenCleanupOperationFailsMidway()
	require.NoError(t, err)

	err = ctx.WhenRunningCleanup()
	require.NoError(t, err)

	err = ctx.ThenRollbackChanges()
	require.NoError(t, err)

	err = ctx.AndReportErrorDetails()
	require.NoError(t, err)
})</pre>
<h1>#65 found 2 clones</h1>
<h2>tests/bdd/configuration_workflow_bdd_test.go:27</h2>
<pre>         godog.TestSuite{
	Name: "Configuration Workflow",
	TestSuiteInitializer: func(ctx *godog.TestSuiteContext) {
		InitializeConfigurationWorkflowContext(ctx.ScenarioContext())
	},
	Options: &godog.Options{
		Format: "cucumber",
		Paths:  []string{"configuration_workflow.feature"},
		Strict: true,
	},
}</pre>
<h2>tests/bdd/nix_management_bdd_test.go:12</h2>
<pre>          godog.TestSuite{
	Name: "Nix Management",
	TestSuiteInitializer: func(ctx *godog.TestSuiteContext) {
		InitializeScenario(ctx.ScenarioContext())
	},
	Options: &godog.Options{
		Format: "cucumber",
		Paths:  []string{"nix_management.feature"},
		Strict: true, // Enable strict mode for better error reporting
	},
}</pre>
<h1>#66 found 3 clones</h1>
<h2>internal/domain/enum_helper_test.go:161</h2>
<pre>case CleanStrategyType:
	var cs CleanStrategyType
	if err := json.Unmarshal([]byte(tt.data), &cs); err != nil {
		t.Fatalf("Unmarshal error: %v", err)
	}
	result = cs</pre>
<h2>internal/domain/enum_helper_test.go:167</h2>
<pre>case ScanTypeType:
	var st ScanTypeType
	if err := json.Unmarshal([]byte(tt.data), &st); err != nil {
		t.Fatalf("Unmarshal error: %v", err)
	}
	result = st</pre>
<h2>internal/domain/enum_helper_test.go:173</h2>
<pre>case RiskLevelType:
	var rl RiskLevelType
	if err := json.Unmarshal([]byte(tt.data), &rl); err != nil {
		t.Fatalf("Unmarshal error: %v", err)
	}
	result = rl</pre>
<h1>#67 found 2 clones</h1>
<h2>internal/config/sanitizer.go:144</h2>
<pre>if cs.rules.TrimWhitespace {
	original := cfg.Version
	cfg.Version = strings.TrimSpace(cfg.Version)
	if original != cfg.Version {
		result.addChange("version", original, cfg.Version, "trimmed whitespace")
	}
}</pre>
<h2>internal/config/sanitizer.go:152</h2>
<pre>if cs.rules.NormalizeCase {
	original := cfg.Version
	cfg.Version = strings.ToLower(cfg.Version)
	if original != cfg.Version {
		result.addChange("version", original, cfg.Version, "normalized to lowercase")
	}
}</pre>
<h1>#68 found 13 clones</h1>
<h2>internal/domain/type_safe_enums.go:147</h2>
<pre>func (rl *RiskLevelType) UnmarshalJSON(data []byte) error {
	val, err := riskLevelHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*rl = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:196</h2>
<pre>func (on *OperationNameType) UnmarshalJSON(data []byte) error {
	val, err := operationNameHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*on = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:265</h2>
<pre>func (vl *ValidationLevelType) UnmarshalJSON(data []byte) error {
	val, err := validationLevelHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*vl = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:321</h2>
<pre>func (co *ChangeOperationType) UnmarshalJSON(data []byte) error {
	val, err := changeOperationHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*co = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:375</h2>
<pre>func (cs *CleanStrategyType) UnmarshalJSON(data []byte) error {
	val, err := cleanStrategyHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*cs = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:453</h2>
<pre>func (s *StatusType) UnmarshalJSON(data []byte) error {
	val, err := statusTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*s = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:506</h2>
<pre>func (el *EnforcementLevelType) UnmarshalJSON(data []byte) error {
	val, err := enforcementLevelTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*el = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:566</h2>
<pre>func (ss *SelectedStatusType) UnmarshalJSON(data []byte) error {
	val, err := selectedStatusTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*ss = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:619</h2>
<pre>func (rl *RecursionLevelType) UnmarshalJSON(data []byte) error {
	val, err := recursionLevelTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*rl = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:670</h2>
<pre>func (ol *OptimizationLevelType) UnmarshalJSON(data []byte) error {
	val, err := optimizationLevelTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*ol = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:721</h2>
<pre>func (fss *FileSelectionStrategyType) UnmarshalJSON(data []byte) error {
	val, err := fileSelectionStrategyTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*fss = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:751</h2>
<pre>func (st *ScanTypeType) UnmarshalJSON(data []byte) error {
	val, err := scanTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*st = val
	return nil
}</pre>
<h2>internal/domain/type_safe_enums.go:804</h2>
<pre>func (sl *SafetyLevelType) UnmarshalJSON(data []byte) error {
	val, err := safetyLevelTypeHelper.UnmarshalJSONImpl(data)
	if err != nil {
		return err
	}
	*sl = val
	return nil
}</pre>
<h1>#69 found 2 clones</h1>
<h2>internal/errors/errors_test.go:301</h2>
<pre>t.Run("PermissionError", func(t *testing.T) {
	err := PermissionError("/tmp/file")

	require.NotNil(t, err)
	assert.Equal(t, ErrCodePermissionDenied, err.Code)
	assert.Contains(t, err.Message, "/tmp/file")
})</pre>
<h2>internal/errors/errors_test.go:309</h2>
<pre>t.Run("FileNotFoundError", func(t *testing.T) {
	err := FileNotFoundError("/tmp/missing")

	require.NotNil(t, err)
	assert.Equal(t, ErrCodeFileNotFound, err.Code)
	assert.Contains(t, err.Message, "/tmp/missing")
})</pre>
<h1>#70 found 2 clones</h1>
<h2>tests/bdd/nix_operations_test.go:158</h2>
<pre>ctx.profile = &domain.Profile{
	Name:        "dangerous-cleanup",
	Description: "High risk cleanup operation",
	Operations: []domain.CleanupOperation{
		{
			Name:        "delete-system-files",
			Description: "Delete system files (DANGEROUS)",
			RiskLevel:   ctx.riskLevel,
			Status:      domain.StatusEnabled,
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h2>tests/bdd/nix_operations_test.go:278</h2>
<pre>ctx.profile = &domain.Profile{
	Name:        "failing-cleanup",
	Description: "Profile that will fail",
	Operations: []domain.CleanupOperation{
		{
			Name:        "simulate-failure",
			Description: "Operation that fails",
			RiskLevel:   domain.RiskLow,
			Status:      domain.StatusEnabled,
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h1>#71 found 2 clones</h1>
<h2>internal/config/safe_test.go:25</h2>
<pre>tests := []struct {
	name     string
	level    domain.RiskLevel
	expected string
}{
	{"low risk", domain.RiskLow, "LOW"},
	{"medium risk", domain.RiskMedium, "MEDIUM"},
	{"high risk", domain.RiskHigh, "HIGH"},
	{"critical risk", domain.RiskCritical, "CRITICAL"},
	{"unknown risk", testInvalidRiskUnknown, "UNKNOWN"},
}</pre>
<h2>internal/config/safe_test.go:50</h2>
<pre>tests := []struct {
	name     string
	level    domain.RiskLevel
	expected string
}{
	{"low risk", domain.RiskLow, "üü¢"},
	{"medium risk", domain.RiskMedium, "üü°"},
	{"high risk", domain.RiskHigh, "üü†"},
	{"critical risk", domain.RiskCritical, "üî¥"},
	{"unknown risk", testInvalidRiskUnknown, "‚ö™"},
}</pre>
<h1>#72 found 2 clones</h1>
<h2>internal/config/validator.go:158</h2>
<pre>if minRules != nil && minRules.Min != nil && len(sliceVal) < *minRules.Min {
	return fmt.Errorf("protected paths must have at least %d items, got %d", *minRules.Min, len(sliceVal))
}</pre>
<h2>internal/config/validator.go:162</h2>
<pre>if maxRules != nil && maxRules.Max != nil && len(sliceVal) > *maxRules.Max {
	return fmt.Errorf("protected paths must have at most %d items, got %d", *maxRules.Max, len(sliceVal))
}</pre>
<h1>#73 found 2 clones</h1>
<h2>internal/config/validator_field.go:26</h2>
<pre>              {
	result.Errors = append(result.Errors, ValidationError{
		Field:      fmt.Sprintf("protected[%d]", i),
		Rule:       "required",
		Value:      path,
		Message:    "Protected path cannot be empty",
		Severity:   SeverityError,
		Suggestion: "Provide a valid absolute path",
	})
}</pre>
<h2>internal/config/validator_field.go:35</h2>
<pre>                                {
	result.Errors = append(result.Errors, ValidationError{
		Field:      fmt.Sprintf("protected[%d]", i),
		Rule:       "format",
		Value:      path,
		Message:    "Protected path must be absolute",
		Severity:   SeverityError,
		Suggestion: "Use absolute path (e.g., /System, /Applications)",
	})
}</pre>
<h1>#74 found 2 clones</h1>
<h2>internal/config/semver_validation_test.go:80</h2>
<pre>t.Run("Invalid semver version", func(t *testing.T) {
	cfg := factories.CreateSemverTestConfig("invalid.version.format")
	result := cv.ValidateConfig(cfg)
	assertValidationErrorForField(t, result, "version", "semver_format")
})</pre>
<h2>internal/config/semver_validation_test.go:86</h2>
<pre>t.Run("Missing version", func(t *testing.T) {
	cfg := factories.CreateSemverTestConfig("")
	result := cv.ValidateConfig(cfg)
	assertValidationErrorForField(t, result, "version", "required")
})</pre>
<h1>#75 found 2 clones</h1>
<h2>internal/domain/duration_parser.go:22</h2>
<pre>                 {
	// Only format as "Xm" if exact multiple of minutes
	if d%time.Minute == 0 {
		minutes := int(d.Minutes())
		return fmt.Sprintf("%dm", minutes)
	}
	return d.String()
}</pre>
<h2>internal/domain/duration_parser.go:31</h2>
<pre>                    {
	// Only format as "Xh" if exact multiple of hours
	if d%time.Hour == 0 {
		hours := int(d.Hours())
		return fmt.Sprintf("%dh", hours)
	}
	return d.String()
}</pre>
<h1>#76 found 2 clones</h1>
<h2>internal/config/factories/profile_factory.go:88</h2>
<pre>       &domain.Profile{
	Name:        "Weekly Cleanup",
	Description: "Weekly deep cleanup",
	Operations: []domain.CleanupOperation{
		{
			Name:        "nix-generations",
			Description: "Deep Nix cleanup",
			RiskLevel:   domain.RiskMedium,
			Status:      domain.StatusEnabled,
			Settings: &domain.OperationSettings{
				NixGenerations: &domain.NixGenerationsSettings{
					Generations:  5,
					Optimization: domain.OptimizationLevelConservative,
				},
			},
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h2>tests/bdd/nix_operations_test.go:85</h2>
<pre>              &domain.Profile{
	Name:        "nix-cleanup",
	Description: "Nix generations cleanup profile",
	Operations: []domain.CleanupOperation{
		{
			Name:        "nix-generations",
			Description: "Clean old Nix generations",
			RiskLevel:   domain.RiskLow,
			Status:      domain.StatusEnabled,
			Settings: &domain.OperationSettings{
				NixGenerations: &domain.NixGenerationsSettings{
					Generations:  3,
					Optimization: domain.OptimizationLevelConservative,
				},
			},
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h1>#77 found 2 clones</h1>
<h2>internal/format/format_test.go:61</h2>
<pre>tests := []struct {
	name     string
	t        time.Time
	expected string
}{
	{"valid date", time.Date(2023, 12, 25, 10, 30, 45, 0, time.UTC), "2023-12-25"},
	{"zero time", time.Time{}, "never"},
	{"unix epoch", time.Unix(0, 0), "1970-01-01"},
}</pre>
<h2>internal/format/format_test.go:82</h2>
<pre>tests := []struct {
	name     string
	t        time.Time
	expected string
}{
	{
		"valid datetime",
		time.Date(2023, 12, 25, 10, 30, 45, 0, time.UTC),
		"2023-12-25 15:30:45", // Note: depends on local timezone
	},
	{"zero time", time.Time{}, "never"},
	{"unix epoch", time.Unix(0, 0), "1970-01-01 00:00:00"},
}</pre>
<h1>#78 found 4 clones</h1>
<h2>internal/domain/enum_helper_test.go:47</h2>
<pre>func TestValidationLevelType_Helper(t *testing.T) {
	// Test String()
	if ValidationLevelStrictType.String() != "STRICT" {
		t.Errorf("ValidationLevelStrictType.String() = %q, want %q", ValidationLevelStrictType.String(), "STRICT")
	}

	// Test IsValid()
	if !ValidationLevelNoneType.IsValid() {
		t.Error("ValidationLevelNoneType.IsValid() = false, want true")
	}

	level := ValidationLevelType(999)
	if level.IsValid() {
		t.Error("Invalid ValidationLevelType.IsValid() = true, want false")
	}

	// Test Values()
	values := ValidationLevelNoneType.Values()
	if len(values) != 4 {
		t.Errorf("ValidationLevelType.Values() = %d, want 4", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:70</h2>
<pre>func TestChangeOperationType_Helper(t *testing.T) {
	// Test String()
	if ChangeOperationAddedType.String() != "ADDED" {
		t.Errorf("ChangeOperationAddedType.String() = %q, want %q", ChangeOperationAddedType.String(), "ADDED")
	}

	// Test IsValid()
	if !ChangeOperationRemovedType.IsValid() {
		t.Error("ChangeOperationRemovedType.IsValid() = false, want true")
	}

	op := ChangeOperationType(999)
	if op.IsValid() {
		t.Error("Invalid ChangeOperationType.IsValid() = true, want false")
	}

	// Test Values()
	values := ChangeOperationAddedType.Values()
	if len(values) != 3 {
		t.Errorf("ChangeOperationType.Values() = %d, want 3", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:93</h2>
<pre>func TestCleanStrategyType_Helper(t *testing.T) {
	// Test String()
	if StrategyAggressiveType.String() != "aggressive" {
		t.Errorf("StrategyAggressiveType.String() = %q, want %q", StrategyAggressiveType.String(), "aggressive")
	}

	// Test IsValid()
	if !StrategyDryRunType.IsValid() {
		t.Error("StrategyDryRunType.IsValid() = false, want true")
	}

	strategy := CleanStrategyType(999)
	if strategy.IsValid() {
		t.Error("Invalid CleanStrategyType.IsValid() = true, want false")
	}

	// Test Values()
	values := StrategyConservativeType.Values()
	if len(values) != 3 {
		t.Errorf("CleanStrategyType.Values() = %d, want 3", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:116</h2>
<pre>func TestScanTypeType_Helper(t *testing.T) {
	// Test String()
	if ScanTypeNixStoreType.String() != "nix_store" {
		t.Errorf("ScanTypeNixStoreType.String() = %q, want %q", ScanTypeNixStoreType.String(), "nix_store")
	}

	// Test IsValid()
	if !ScanTypeHomebrewType.IsValid() {
		t.Error("ScanTypeHomebrewType.IsValid() = false, want true")
	}

	scan := ScanTypeType(999)
	if scan.IsValid() {
		t.Error("Invalid ScanTypeType.IsValid() = true, want false")
	}

	// Test Values()
	values := ScanTypeSystemType.Values()
	if len(values) != 4 {
		t.Errorf("ScanTypeType.Values() = %d, want 4", len(values))
	}
}</pre>
<h1>#79 found 2 clones</h1>
<h2>internal/errors/errors_test.go:292</h2>
<pre>t.Run("ValidationError", func(t *testing.T) {
	err := ValidationError("email", "invalid format")

	require.NotNil(t, err)
	assert.Equal(t, ErrCodeValidationFailed, err.Code)
	assert.Contains(t, err.Message, "email")
	assert.Contains(t, err.Message, "invalid format")
})</pre>
<h2>internal/errors/errors_test.go:327</h2>
<pre>t.Run("SystemError", func(t *testing.T) {
	err := SystemError("memory", "out of memory")

	require.NotNil(t, err)
	assert.Equal(t, ErrCodeProcessFailed, err.Code)
	assert.Contains(t, err.Message, "memory")
	assert.Contains(t, err.Message, "out of memory")
})</pre>
<h1>#80 found 2 clones</h1>
<h2>cmd/clean-wizard/commands/profile.go:241</h2>
<pre>if op.Settings.NixGenerations != nil {
	fmt.Printf("       ‚Ä¢ generations: %d\n", op.Settings.NixGenerations.Generations)
	fmt.Printf("       ‚Ä¢ optimization: %s\n", op.Settings.NixGenerations.Optimization)
}</pre>
<h2>cmd/clean-wizard/commands/profile.go:254</h2>
<pre>if op.Settings.SystemTemp != nil {
	fmt.Printf("       ‚Ä¢ paths: %v\n", op.Settings.SystemTemp.Paths)
	fmt.Printf("       ‚Ä¢ older_than: %s\n", op.Settings.SystemTemp.OlderThan)
}</pre>
<h1>#81 found 3 clones</h1>
<h2>internal/domain/benchmarks_test.go:11</h2>
<pre>b.Run("RiskLevel", func(b *testing.B) {
	levels := []RiskLevelType{RiskLow, RiskMedium, RiskHigh, RiskCritical}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = levels[i%len(levels)].String()
	}
})</pre>
<h2>internal/domain/benchmarks_test.go:27</h2>
<pre>b.Run("ScanType", func(b *testing.B) {
	types := []ScanTypeType{ScanTypeNixStoreType, ScanTypeHomebrewType, ScanTypeSystemType, ScanTypeTempType}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = types[i%len(types)].String()
	}
})</pre>
<h2>internal/domain/benchmarks_test.go:38</h2>
<pre>b.Run("RiskLevel", func(b *testing.B) {
	levels := []RiskLevelType{RiskLow, RiskMedium, RiskHigh, RiskCritical}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = levels[i%len(levels)].IsValid()
	}
})</pre>
<h1>#82 found 3 clones</h1>
<h2>internal/config/test_data.go:56</h2>
<pre>                      map[string]*domain.Profile{
	"daily": {
		Name:        "  daily  ",
		Description: "Daily cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean Nix generations",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
			},
		},
		Status: domain.StatusEnabled,
	},
}</pre>
<h2>internal/config/test_data.go:74</h2>
<pre>                      map[string]*domain.Profile{
	"daily": { // Normal key - sanitizer should clean up name field inside
		Name:        " daily cleanup ", // Extra spaces
		Description: " Daily cleanup ",
		Operations: []domain.CleanupOperation{
			{
				Name:        " nix-generations ",
				Description: " Clean Nix generations ",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
			},
		},
		Status: domain.StatusEnabled,
	},
}</pre>
<h2>internal/config/validation_sanitizer_test.go:49</h2>
<pre>          map[string]*domain.Profile{
	"daily": {
		Name:        "daily",
		Description: "Daily cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean Nix generations",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
			},
		},
		Status: domain.StatusEnabled,
	},
}</pre>
<h1>#83 found 8 clones</h1>
<h2>cmd/clean-wizard/commands/profile.go:279</h2>
<pre>                                                 {
	switch level {
	case domain.RiskLow:
		return "üü¢ " // Green
	case domain.RiskMedium:
		return "üü° " // Yellow
	case domain.RiskHigh:
		return "üü† " // Orange
	case domain.RiskCritical:
		return "üî¥ " // Red
	default:
		return "‚ö™ " // White
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:18</h2>
<pre>                                                                     {
	switch risk {
	case domain.RiskLevelLowType:
		return "üü¢"
	case domain.RiskLevelMediumType:
		return "üü°"
	case domain.RiskLevelHighType:
		return "üü†"
	case domain.RiskLevelCriticalType:
		return "üî¥"
	default:
		return "‚ö™"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:49</h2>
<pre>                                                                      {
	switch risk {
	case domain.RiskLevelLowType:
		return "#22c55e" // green
	case domain.RiskLevelMediumType:
		return "#eab308" // yellow
	case domain.RiskLevelHighType:
		return "#f97316" // orange
	case domain.RiskLevelCriticalType:
		return "#ef4444" // red
	default:
		return "#6b7280" // gray
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:66</h2>
<pre>                                                                       {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "üì¶"
	case domain.ScanTypeHomebrewType:
		return "üç∫"
	case domain.ScanTypeSystemType:
		return "üíª"
	case domain.ScanTypeTempType:
		return "üóëÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:82</h2>
<pre>                                                                              {
	switch scanType {
	case domain.ScanTypeNixStoreType:
		return "Nix store garbage collection and cleanup"
	case domain.ScanTypeHomebrewType:
		return "Homebrew package cleanup and maintenance"
	case domain.ScanTypeSystemType:
		return "System-level temporary files cleanup"
	case domain.ScanTypeTempType:
		return "Temporary files and cache cleanup"
	default:
		return "Unknown scan type"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:128</h2>
<pre>                                                                                    {
	switch level {
	case domain.EnforcementLevelNone:
		return "‚ö™"
	case domain.EnforcementLevelWarning:
		return "üü°"
	case domain.EnforcementLevelError:
		return "üî¥"
	case domain.EnforcementLevelStrict:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:160</h2>
<pre>                                                                                {
	switch level {
	case domain.RecursionLevelNone:
		return "‚û°Ô∏è"
	case domain.RecursionLevelDirect:
		return "‚¨áÔ∏è"
	case domain.RecursionLevelFull:
		return "üîÑ"
	case domain.RecursionLevelInfinite:
		return "‚ôæÔ∏è"
	default:
		return "‚ùì"
	}
}</pre>
<h2>internal/adapters/ui_adapter.go:207</h2>
<pre>                                                                          {
	switch level {
	case domain.SafetyLevelDisabled:
		return "üî¥"
	case domain.SafetyLevelEnabled:
		return "üü¢"
	case domain.SafetyLevelStrict:
		return "üü°"
	case domain.SafetyLevelParanoid:
		return "üö´"
	default:
		return "‚ùì"
	}
}</pre>
<h1>#84 found 2 clones</h1>
<h2>internal/domain/cleanresult_test.go:57</h2>
<pre>{
	name: "Invalid CleanResult - zero freed bytes with items removed",
	result: CleanResult{
		FreedBytes:   0,
		ItemsRemoved: 1,
		ItemsFailed:  0,
		CleanTime:    time.Second,
		CleanedAt:    time.Now(),
		Strategy:     StrategyAggressive,
	},
	shouldValid: false,
	shouldError: true,
	errorMsg:    "cannot have zero FreedBytes when ItemsRemoved is > 0",
}</pre>
<h2>internal/domain/cleanresult_test.go:71</h2>
<pre>{
	name: "Invalid CleanResult - failed items with no freed bytes",
	result: CleanResult{
		FreedBytes:   0,
		ItemsRemoved: 0,
		ItemsFailed:  5,
		CleanTime:    time.Second,
		CleanedAt:    time.Now(),
		Strategy:     StrategyConservative,
	},
	shouldValid: false,
	shouldError: true,
	errorMsg:    "cannot have failed items when no items were processed",
}</pre>
<h1>#85 found 2 clones</h1>
<h2>cmd/clean-wizard/commands/profile.go:138</h2>
<pre>if !exists {
	// Show available profiles
	var names []string
	for name := range cfg.Profiles {
		names = append(names, name)
	}
	sort.Strings(names)
	return fmt.Errorf("profile '%s' not found. Available profiles: %s",
		profileName, strings.Join(names, ", "))
}</pre>
<h2>cmd/clean-wizard/commands/profile.go:187</h2>
<pre>if !exists {
	var names []string
	for name := range cfg.Profiles {
		names = append(names, name)
	}
	sort.Strings(names)
	return fmt.Errorf("profile '%s' not found. Available profiles: %s",
		profileName, strings.Join(names, ", "))
}</pre>
<h1>#86 found 2 clones</h1>
<h2>internal/config/sanitizer_nix.go:26</h2>
<pre>                                            {
	settings.Generations = MinNixGenerations
	result.Warnings = append(result.Warnings, SanitizationWarning{
		Field:     fieldName,
		Original:  original,
		Sanitized: settings.Generations,
		Reason:    fmt.Sprintf("Nix generations clamped to minimum %d", MinNixGenerations),
	})
	result.addChange(fieldName, original, settings.Generations, "clamped to minimum")
	changed = true
}</pre>
<h2>internal/config/sanitizer_nix.go:36</h2>
<pre>                                                   {
	settings.Generations = MaxNixGenerations
	result.Warnings = append(result.Warnings, SanitizationWarning{
		Field:     fieldName,
		Original:  original,
		Sanitized: settings.Generations,
		Reason:    fmt.Sprintf("Nix generations clamped to maximum %d", MaxNixGenerations),
	})
	result.addChange(fieldName, original, settings.Generations, "clamped to maximum")
	changed = true
}</pre>
<h1>#87 found 2 clones</h1>
<h2>internal/domain/benchmarks_test.go:11</h2>
<pre>b.Run("RiskLevel", func(b *testing.B) {
	levels := []RiskLevelType{RiskLow, RiskMedium, RiskHigh, RiskCritical}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = levels[i%len(levels)].String()
	}
})

b.Run("CleanStrategy", func(b *testing.B) {
	strategies := []CleanStrategyType{StrategyAggressive, StrategyConservative, StrategyDryRun}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = strategies[i%len(strategies)].String()
	}
})</pre>
<h2>internal/domain/benchmarks_test.go:38</h2>
<pre>b.Run("RiskLevel", func(b *testing.B) {
	levels := []RiskLevelType{RiskLow, RiskMedium, RiskHigh, RiskCritical}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = levels[i%len(levels)].IsValid()
	}
})

b.Run("CleanStrategy", func(b *testing.B) {
	strategies := []CleanStrategyType{StrategyAggressive, StrategyConservative, StrategyDryRun}
	b.ResetTimer()
	for i := 0; b.Loop(); i++ {
		_ = strategies[i%len(strategies)].IsValid()
	}
})</pre>
