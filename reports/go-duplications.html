<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 2 clones</h1>
<h2>internal/config/bdd_nix_validation_test.go:228</h2>
<pre>{
	Name:        "Invalid Nix generations below minimum",
	Description: "Should reject Nix generations below minimum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations below minimum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 0), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action: func(cfg *domain.Config) (*ValidationResult, error) {
				validator := NewConfigValidator()
				return validator.ValidateConfig(cfg), nil
			},
		},
	},
	Then: []BDDThen{
		{
			Description: "validation should fail",
			Validate: func(result *ValidationResult) error {
				if result.IsValid {
					return fmt.Errorf("expected invalid configuration")
				}
				return nil
			},
		},
		{
			Description: "validation errors should be present",
			Validate: func(result *ValidationResult) error {
				if len(result.Errors) == 0 {
					return fmt.Errorf("expected validation errors")
				}
				return nil
			},
		},
		{
			Description: "error should mention generations constraint",
			Validate: func(result *ValidationResult) error {
				found := false
				for _, err := range result.Errors {
					if strings.Contains(err.Message, "generations") {
						found = true
						break
					}
				}
				if !found {
					return fmt.Errorf("expected error mentioning generations constraint")
				}
				return nil
			},
		},
	},
}</pre>
<h2>internal/config/bdd_nix_validation_test.go:285</h2>
<pre>{
	Name:        "Invalid Nix generations above maximum",
	Description: "Should reject Nix generations above maximum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations above maximum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 15), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action: func(cfg *domain.Config) (*ValidationResult, error) {
				validator := NewConfigValidator()
				return validator.ValidateConfig(cfg), nil
			},
		},
	},
	Then: []BDDThen{
		{
			Description: "validation should fail",
			Validate: func(result *ValidationResult) error {
				if result.IsValid {
					return fmt.Errorf("expected invalid configuration")
				}
				return nil
			},
		},
		{
			Description: "validation errors should be present",
			Validate: func(result *ValidationResult) error {
				if len(result.Errors) == 0 {
					return fmt.Errorf("expected validation errors")
				}
				return nil
			},
		},
		{
			Description: "error should mention generations constraint",
			Validate: func(result *ValidationResult) error {
				found := false
				for _, err := range result.Errors {
					if strings.Contains(err.Message, "generations") {
						found = true
						break
					}
				}
				if !found {
					return fmt.Errorf("expected error mentioning generations constraint")
				}
				return nil
			},
		},
	},
}</pre>
<h1>#2 found 2 clones</h1>
<h2>internal/config/semver_validation_test.go:72</h2>
<pre>t.Run("Invalid semver version", func(t *testing.T) {
	cfg := &domain.Config{
		Version: "invalid.version.format",
		Profiles: map[string]*domain.Profile{
			"test": {
				Name:        "test",
				Description: "Test profile",
				Operations: []domain.CleanupOperation{{
					Name:        "test-op",
					Description: "Test operation",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
					Settings:    &domain.OperationSettings{NixGenerations: &domain.NixGenerationsSettings{Generations: 5}},
				}},
				Status: domain.StatusEnabled,
			},
		},
		Protected: []string{"/System"},
	}

	result := cv.ValidateConfig(cfg)
	if len(result.Errors) == 0 {
		t.Error("Expected validation errors for invalid semver version")
	}

	// Check if error is related to version format
	foundVersionError := false
	for _, err := range result.Errors {
		if err.Field == "version" && err.Rule == "semver_format" {
			foundVersionError = true
			break
		}
	}
	if !foundVersionError {
		t.Errorf("Expected semver_format error for version field, got errors: %v", result.Errors)
	}
})</pre>
<h2>internal/config/semver_validation_test.go:110</h2>
<pre>t.Run("Missing version", func(t *testing.T) {
	cfg := &domain.Config{
		Version: "",
		Profiles: map[string]*domain.Profile{
			"test": {
				Name:        "test",
				Description: "Test profile",
				Operations: []domain.CleanupOperation{{
					Name:        "test-op",
					Description: "Test operation",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
					Settings:    &domain.OperationSettings{NixGenerations: &domain.NixGenerationsSettings{Generations: 5}},
				}},
				Status: domain.StatusEnabled,
			},
		},
		Protected: []string{"/System"},
	}

	result := cv.ValidateConfig(cfg)
	if len(result.Errors) == 0 {
		t.Error("Expected validation errors for missing version")
	}

	// Check if error is related to missing version
	foundMissingError := false
	for _, err := range result.Errors {
		if err.Field == "version" && err.Rule == "required" {
			foundMissingError = true
			break
		}
	}
	if !foundMissingError {
		t.Errorf("Expected required error for version field, got errors: %v", result.Errors)
	}
})</pre>
<h1>#3 found 2 clones</h1>
<h2>internal/config/config.go:71</h2>
<pre>for name, profile := range config.Profiles {
	// Convert boolean enabled to StatusType enum for profiles
	var profileEnabled bool
	if v.IsSet(fmt.Sprintf("profiles.%s.enabled", name)) {
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.enabled", name), &profileEnabled); err != nil {
			log.Warn().Err(err).Str("profile", name).Msg("Failed to unmarshal profile enabled flag")
		}
		if profileEnabled {
			profile.Status = domain.StatusEnabled
		} else {
			profile.Status = domain.StatusDisabled
		}
	} else {
		// Fallback to string status parsing for backward compatibility
		var profileStatusStr string
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.status", name), &profileStatusStr); err != nil {
			log.Warn().Err(err).Str("profile", name).Msg("Failed to unmarshal profile status")
		}
		switch strings.ToUpper(strings.TrimSpace(profileStatusStr)) {
		case "DISABLED":
			profile.Status = domain.StatusDisabled
		case "ENABLED":
			profile.Status = domain.StatusEnabled
		case "INHERITED":
			profile.Status = domain.StatusInherited
		default:
			if profileStatusStr != "" {
				log.Warn().Str("profile", name).Str("status", profileStatusStr).Msg("Invalid profile status, defaulting to ENABLED")
			}
			profile.Status = domain.StatusEnabled
		}
	}

	for i, op := range profile.Operations {
		// Convert string risk level to RiskLevel enum
		var riskLevelStr string
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.risk_level", name, i), &riskLevelStr); err != nil {
			log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal risk level")
		}

		switch strings.ToUpper(riskLevelStr) {
		case "LOW":
			op.RiskLevel = domain.RiskLow
		case "MEDIUM":
			op.RiskLevel = domain.RiskMedium
		case "HIGH":
			op.RiskLevel = domain.RiskHigh
		case "CRITICAL":
			op.RiskLevel = domain.RiskCritical
		default:
			log.Warn().Str("risk_level", riskLevelStr).Msg("Invalid risk level, defaulting to LOW")
			op.RiskLevel = domain.RiskLow
		}

		// Convert boolean enabled to StatusType enum for operations
		operationEnabledKey := fmt.Sprintf("profiles.%s.operations.%d.enabled", name, i)
		if v.IsSet(operationEnabledKey) {
			var operationEnabled bool
			if err := v.UnmarshalKey(operationEnabledKey, &operationEnabled); err != nil {
				log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal operation enabled flag")
			}
			if operationEnabled {
				op.Status = domain.StatusEnabled
			} else {
				op.Status = domain.StatusDisabled
			}
		} else {
			// Fallback to string status parsing for backward compatibility
			var opStatusStr string
			if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.status", name, i), &opStatusStr); err != nil {
				log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal operation status")
			}
			switch strings.ToUpper(strings.TrimSpace(opStatusStr)) {
			case "DISABLED":
				op.Status = domain.StatusDisabled
			case "ENABLED":
				op.Status = domain.StatusEnabled
			case "INHERITED":
				op.Status = domain.StatusInherited
			default:
				if opStatusStr != "" {
					log.Warn().Str("profile", name).Int("operation", i).Str("status", opStatusStr).Msg("Invalid operation status, defaulting to ENABLED")
				}
				op.Status = domain.StatusEnabled
			}
		}
	}
}</pre>
<h2>internal/config/config.go:243</h2>
<pre>for name, profile := range config.Profiles {
	// Convert boolean enabled to StatusType enum for profiles
	var profileEnabled bool
	if v.IsSet(fmt.Sprintf("profiles.%s.enabled", name)) {
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.enabled", name), &profileEnabled); err != nil {
			log.Warn().Err(err).Str("profile", name).Msg("Failed to unmarshal profile enabled flag")
		}
		if profileEnabled {
			profile.Status = domain.StatusEnabled
		} else {
			profile.Status = domain.StatusDisabled
		}
	} else {
		// Fallback to string status parsing for backward compatibility
		var profileStatusStr string
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.status", name), &profileStatusStr); err != nil {
			log.Warn().Err(err).Str("profile", name).Msg("Failed to unmarshal profile status")
		}
		switch strings.ToUpper(strings.TrimSpace(profileStatusStr)) {
		case "DISABLED":
			profile.Status = domain.StatusDisabled
		case "ENABLED":
			profile.Status = domain.StatusEnabled
		case "INHERITED":
			profile.Status = domain.StatusInherited
		default:
			if profileStatusStr != "" {
				log.Warn().Str("profile", name).Str("status", profileStatusStr).Msg("Invalid profile status, defaulting to ENABLED")
			}
			profile.Status = domain.StatusEnabled
		}
	}

	for i, op := range profile.Operations {
		// Convert string risk level to RiskLevel enum
		var riskLevelStr string
		if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.risk_level", name, i), &riskLevelStr); err != nil {
			log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal risk level")
		}

		switch strings.ToUpper(riskLevelStr) {
		case "LOW":
			op.RiskLevel = domain.RiskLow
		case "MEDIUM":
			op.RiskLevel = domain.RiskMedium
		case "HIGH":
			op.RiskLevel = domain.RiskHigh
		case "CRITICAL":
			op.RiskLevel = domain.RiskCritical
		default:
			log.Warn().Str("risk_level", riskLevelStr).Msg("Invalid risk level, defaulting to LOW")
			op.RiskLevel = domain.RiskLow
		}

		// Convert boolean enabled to StatusType enum for operations
		operationEnabledKey := fmt.Sprintf("profiles.%s.operations.%d.enabled", name, i)
		if v.IsSet(operationEnabledKey) {
			var operationEnabled bool
			if err := v.UnmarshalKey(operationEnabledKey, &operationEnabled); err != nil {
				log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal operation enabled flag")
			}
			if operationEnabled {
				op.Status = domain.StatusEnabled
			} else {
				op.Status = domain.StatusDisabled
			}
		} else {
			// Fallback to string status parsing for backward compatibility
			var opStatusStr string
			if err := v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.status", name, i), &opStatusStr); err != nil {
				log.Warn().Err(err).Str("profile", name).Int("operation", i).Msg("Failed to unmarshal operation status")
			}
			switch strings.ToUpper(strings.TrimSpace(opStatusStr)) {
			case "DISABLED":
				op.Status = domain.StatusDisabled
			case "ENABLED":
				op.Status = domain.StatusEnabled
			case "INHERITED":
				op.Status = domain.StatusInherited
			default:
				if opStatusStr != "" {
					log.Warn().Str("profile", name).Int("operation", i).Str("status", opStatusStr).Msg("Invalid operation status, defaulting to ENABLED")
				}
				op.Status = domain.StatusEnabled
			}
		}
	}
}</pre>
<h1>#4 found 2 clones</h1>
<h2>internal/result/type_test.go:9</h2>
<pre>func TestResult_Ok(t *testing.T) {
	tests := []struct {
		name     string
		result   Result[int]
		expected bool
	}{
		{
			name:     "ok result",
			result:   Ok(42),
			expected: true,
		},
		{
			name:     "error result",
			result:   Err[int](errors.New("test error")),
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.result.IsOk() != tt.expected {
				t.Errorf("IsOk() = %v, want %v", tt.result.IsOk(), tt.expected)
			}
		})
	}
}</pre>
<h2>internal/result/type_test.go:36</h2>
<pre>func TestResult_IsErr(t *testing.T) {
	tests := []struct {
		name     string
		result   Result[int]
		expected bool
	}{
		{
			name:     "ok result",
			result:   Ok(42),
			expected: false,
		},
		{
			name:     "error result",
			result:   Err[int](errors.New("test error")),
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.result.IsErr() != tt.expected {
				t.Errorf("IsErr() = %v, want %v", tt.result.IsErr(), tt.expected)
			}
		})
	}
}</pre>
