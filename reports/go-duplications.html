<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 2 clones</h1>
<h2>internal/config/bdd_nix_validation_test.go:242</h2>
<pre>{
	Name:        "Invalid Nix generations below minimum",
	Description: "Should reject Nix generations below minimum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations below minimum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 0), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action:      whenConfigValidated,
		},
	},
	Then: thenValidationFailsWithError("generations constraint"),
}</pre>
<h2>internal/config/bdd_nix_validation_test.go:261</h2>
<pre>{
	Name:        "Invalid Nix generations above maximum",
	Description: "Should reject Nix generations above maximum threshold",
	Given: []BDDGiven{
		{
			Description: "a configuration with Nix generations above maximum",
			Setup: func(t *testing.T) (*domain.Config, error) {
				return withGenerations(t, newBaseNixConfig(t, true), 15), nil
			},
		},
	},
	When: []BDDWhen{
		{
			Description: "the configuration is validated",
			Action:      whenConfigValidated,
		},
	},
	Then: thenValidationFailsWithError("generations constraint"),
}</pre>
<h1>#2 found 2 clones</h1>
<h2>internal/config/test_data.go:38</h2>
<pre>           {
	baseConfig.Version = "  1.0.0  "
	baseConfig.Protected = []string{"/System", "/Library"}
	baseConfig.Profiles = map[string]*domain.Profile{
		"daily": {
			Name:        "  daily  ",
			Description: "Daily cleanup",
			Operations: []domain.CleanupOperation{
				{
					Name:        "nix-generations",
					Description: "Clean Nix generations",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
				},
			},
			Status: domain.StatusEnabled,
		},
	}
}</pre>
<h2>internal/config/test_data.go:56</h2>
<pre>       {
	baseConfig.Version = " 1.0.0 " // Extra spaces
	baseConfig.Protected = []string{"/System ", " /Library"} // Trailing/leading spaces
	baseConfig.Profiles = map[string]*domain.Profile{
		"daily": { // Normal key - the sanitizer should clean up the name field inside
			Name:        " daily cleanup ", // Extra spaces
			Description: " Daily cleanup ",
			Operations: []domain.CleanupOperation{
				{
					Name:        " nix-generations ",
					Description: " Clean Nix generations ",
					RiskLevel:   domain.RiskLow,
					Status:      domain.StatusEnabled,
				},
			},
			Status: domain.StatusEnabled,
		},
	}
}</pre>
<h1>#3 found 2 clones</h1>
<h2>internal/errors/errors_test.go:119</h2>
<pre>t.Run("File not found", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrNotExist, Path: "/tmp/missing"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeFileNotFound, cwErr.Code)
	assert.Equal(t, ErrorTypeFileSystem, cwErr.Type)
	assert.Equal(t, SeverityWarning, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/missing")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h2>internal/errors/errors_test.go:131</h2>
<pre>t.Run("Permission denied", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrPermission, Path: "/tmp/protected"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodePermissionError, cwErr.Code)
	assert.Equal(t, ErrorTypePermission, cwErr.Type)
	assert.Equal(t, SeverityError, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/protected")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h1>#4 found 2 clones</h1>
<h2>internal/config/config.go:165</h2>
<pre>func createDailyProfile() *domain.Profile {
	return &domain.Profile{
		Name:        "daily",
		Description: "Quick daily cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean old Nix generations",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
			},
			{
				Name:        "temp-files",
				Description: "Clean temporary files",
				RiskLevel:   domain.RiskLow,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeTempFiles),
			},
		},
		Status: domain.StatusEnabled,
	}
}</pre>
<h2>internal/config/config.go:190</h2>
<pre>func createAggressiveProfile() *domain.Profile {
	return &domain.Profile{
		Name:        "aggressive",
		Description: "Deep aggressive cleanup",
		Operations: []domain.CleanupOperation{
			{
				Name:        "nix-generations",
				Description: "Clean old Nix generations",
				RiskLevel:   domain.RiskHigh,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
			},
			{
				Name:        "homebrew-cleanup",
				Description: "Clean old Homebrew packages",
				RiskLevel:   domain.RiskMedium,
				Status:      domain.StatusEnabled,
				Settings:    domain.DefaultSettings(domain.OperationTypeHomebrew),
			},
		},
		Status: domain.StatusEnabled,
	}
}</pre>
<h1>#5 found 3 clones</h1>
<h2>internal/config/type_safe_validation_rules_test.go:127</h2>
<pre>if original.MaxDiskUsage != nil && copied.MaxDiskUsage != nil {
	if original.MaxDiskUsage.Required == copied.MaxDiskUsage.Required {
		t.Error("FAILED: modified copied.MaxDiskUsage.Required affected original")
	}
	if *original.MaxDiskUsage.Min == *copied.MaxDiskUsage.Min {
		t.Error("FAILED: modified copied.MaxDiskUsage.Min affected original")
	}
	if *original.MaxDiskUsage.Max == *copied.MaxDiskUsage.Max {
		t.Error("FAILED: modified copied.MaxDiskUsage.Max affected original")
	}
	if original.MaxDiskUsage.Message == copied.MaxDiskUsage.Message {
		t.Error("FAILED: modified copied.MaxDiskUsage.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:142</h2>
<pre>if original.MinProtectedPaths != nil && copied.MinProtectedPaths != nil {
	if original.MinProtectedPaths.Required == copied.MinProtectedPaths.Required {
		t.Error("FAILED: modified copied.MinProtectedPaths.Required affected original")
	}
	if *original.MinProtectedPaths.Min == *copied.MinProtectedPaths.Min {
		t.Error("FAILED: modified copied.MinProtectedPaths.Min affected original")
	}
	if *original.MinProtectedPaths.Max == *copied.MinProtectedPaths.Max {
		t.Error("FAILED: modified copied.MinProtectedPaths.Max affected original")
	}
	if original.MinProtectedPaths.Message == copied.MinProtectedPaths.Message {
		t.Error("FAILED: modified copied.MinProtectedPaths.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:157</h2>
<pre>if original.MaxProfiles != nil && copied.MaxProfiles != nil {
	if original.MaxProfiles.Required == copied.MaxProfiles.Required {
		t.Error("FAILED: modified copied.MaxProfiles.Required affected original")
	}
	if *original.MaxProfiles.Min == *copied.MaxProfiles.Min {
		t.Error("FAILED: modified copied.MaxProfiles.Min affected original")
	}
	if *original.MaxProfiles.Max == *copied.MaxProfiles.Max {
		t.Error("FAILED: modified copied.MaxProfiles.Max affected original")
	}
	if original.MaxProfiles.Message == copied.MaxProfiles.Message {
		t.Error("FAILED: modified copied.MaxProfiles.Message affected original")
	}
}</pre>
<h1>#6 found 2 clones</h1>
<h2>internal/api/mapper_test.go:324</h2>
<pre>for _, tc := range testCases {
	t.Run(string(tc.public), func(t *testing.T) {
		// Test public to domain
		domainStrategy, err := MapStrategyToDomain(tc.public)
		if err != nil {
			t.Errorf("Expected successful mapping, got error: %v", err)
		}

		if domainStrategy != tc.domain {
			t.Errorf("Expected domain strategy %v, got %v", tc.domain, domainStrategy)
		}

		// Test domain to public
		publicStrategy := MapStrategyToPublic(tc.domain)
		if publicStrategy != tc.public {
			t.Errorf("Expected public strategy %s, got %s", tc.public, publicStrategy)
		}
	})
}</pre>
<h2>internal/api/mapper_test.go:357</h2>
<pre>for _, tc := range testCases {
	t.Run(string(tc.public), func(t *testing.T) {
		// Test public to domain
		domainLevel, err := MapRiskLevelToDomain(tc.public)
		if err != nil {
			t.Errorf("Expected successful mapping, got error: %v", err)
		}

		if domainLevel != tc.domain {
			t.Errorf("Expected domain level %v, got %v", tc.domain, domainLevel)
		}

		// Test domain to public
		publicLevel := MapRiskLevelToPublic(tc.domain)
		if publicLevel != tc.public {
			t.Errorf("Expected public level %s, got %s", tc.public, publicLevel)
		}
	})
}</pre>
<h1>#7 found 2 clones</h1>
<h2>internal/errors/errors_test.go:167</h2>
<pre>func TestConfigErrorAdapter(t *testing.T) {
	adapter := &ConfigErrorAdapter{}
	originalErr := errors.New("invalid config")

	cwErr := adapter.Adapt(originalErr, "main configuration")

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeInvalidConfig, cwErr.Code)
	assert.Equal(t, ErrorTypeConfig, cwErr.Type)
	assert.Equal(t, SeverityInfo, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "main configuration")
	assert.Equal(t, originalErr, cwErr.Cause)
}</pre>
<h2>internal/errors/errors_test.go:181</h2>
<pre>func TestValidationErrorAdapter(t *testing.T) {
	adapter := &ValidationErrorAdapter{}
	originalErr := errors.New("invalid value")

	cwErr := adapter.Adapt(originalErr, "email field")

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeValidationFailed, cwErr.Code)
	assert.Equal(t, ErrorTypeValidation, cwErr.Type)
	assert.Equal(t, SeverityError, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "email field")
	assert.Equal(t, originalErr, cwErr.Cause)
}</pre>
<h1>#8 found 2 clones</h1>
<h2>tests/bdd/nix_operations_test.go:373</h2>
<pre>t.Run("Happy Path Nix Cleanup", func(t *testing.T) {
	err := ctx.GivenValidNixInstallation()
	require.NoError(t, err)

	err = ctx.WhenRunningNixGenerationsCleanup()
	require.NoError(t, err)

	err = ctx.ThenRemoveOldGenerationsAndKeepCurrent()
	require.NoError(t, err)

	err = ctx.AndLogOperationsPerformed()
	require.NoError(t, err)
})</pre>
<h2>tests/bdd/nix_operations_test.go:418</h2>
<pre>t.Run("Error Recovery", func(t *testing.T) {
	err := ctx.GivenCleanupOperationFailsMidway()
	require.NoError(t, err)

	err = ctx.WhenRunningCleanup()
	require.NoError(t, err)

	err = ctx.ThenRollbackChanges()
	require.NoError(t, err)

	err = ctx.AndReportErrorDetails()
	require.NoError(t, err)
})</pre>
<h1>#9 found 2 clones</h1>
<h2>internal/config/test_data.go:313</h2>
<pre>       &domain.Profile{
	Name:        "Weekly Cleanup",
	Description: "Weekly deep cleanup",
	Operations: []domain.CleanupOperation{
		{
			Name:        "nix-generations",
			Description: "Deep Nix cleanup",
			RiskLevel:   domain.RiskMedium,
			Status:      domain.StatusEnabled,
			Settings: &domain.OperationSettings{
				NixGenerations: &domain.NixGenerationsSettings{
					Generations:  5,
					Optimization: domain.OptimizationLevelConservative,
				},
			},
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h2>tests/bdd/nix_operations_test.go:85</h2>
<pre>              &domain.Profile{
	Name:        "nix-cleanup",
	Description: "Nix generations cleanup profile",
	Operations: []domain.CleanupOperation{
		{
			Name:        "nix-generations",
			Description: "Clean old Nix generations",
			RiskLevel:   domain.RiskLow,
			Status:      domain.StatusEnabled,
			Settings: &domain.OperationSettings{
				NixGenerations: &domain.NixGenerationsSettings{
					Generations:  3,
					Optimization: domain.OptimizationLevelConservative,
				},
			},
		},
	},
	Status: domain.StatusEnabled,
}</pre>
<h1>#10 found 4 clones</h1>
<h2>internal/domain/enum_helper_test.go:47</h2>
<pre>func TestValidationLevelType_Helper(t *testing.T) {
	// Test String()
	if ValidationLevelStrictType.String() != "STRICT" {
		t.Errorf("ValidationLevelStrictType.String() = %q, want %q", ValidationLevelStrictType.String(), "STRICT")
	}

	// Test IsValid()
	if !ValidationLevelNoneType.IsValid() {
		t.Error("ValidationLevelNoneType.IsValid() = false, want true")
	}

	level := ValidationLevelType(999)
	if level.IsValid() {
		t.Error("Invalid ValidationLevelType.IsValid() = true, want false")
	}

	// Test Values()
	values := ValidationLevelNoneType.Values()
	if len(values) != 4 {
		t.Errorf("ValidationLevelType.Values() = %d, want 4", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:70</h2>
<pre>func TestChangeOperationType_Helper(t *testing.T) {
	// Test String()
	if ChangeOperationAddedType.String() != "ADDED" {
		t.Errorf("ChangeOperationAddedType.String() = %q, want %q", ChangeOperationAddedType.String(), "ADDED")
	}

	// Test IsValid()
	if !ChangeOperationRemovedType.IsValid() {
		t.Error("ChangeOperationRemovedType.IsValid() = false, want true")
	}

	op := ChangeOperationType(999)
	if op.IsValid() {
		t.Error("Invalid ChangeOperationType.IsValid() = true, want false")
	}

	// Test Values()
	values := ChangeOperationAddedType.Values()
	if len(values) != 3 {
		t.Errorf("ChangeOperationType.Values() = %d, want 3", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:93</h2>
<pre>func TestCleanStrategyType_Helper(t *testing.T) {
	// Test String()
	if StrategyAggressiveType.String() != "aggressive" {
		t.Errorf("StrategyAggressiveType.String() = %q, want %q", StrategyAggressiveType.String(), "aggressive")
	}

	// Test IsValid()
	if !StrategyDryRunType.IsValid() {
		t.Error("StrategyDryRunType.IsValid() = false, want true")
	}

	strategy := CleanStrategyType(999)
	if strategy.IsValid() {
		t.Error("Invalid CleanStrategyType.IsValid() = true, want false")
	}

	// Test Values()
	values := StrategyConservativeType.Values()
	if len(values) != 3 {
		t.Errorf("CleanStrategyType.Values() = %d, want 3", len(values))
	}
}</pre>
<h2>internal/domain/enum_helper_test.go:116</h2>
<pre>func TestScanTypeType_Helper(t *testing.T) {
	// Test String()
	if ScanTypeNixStoreType.String() != "nix_store" {
		t.Errorf("ScanTypeNixStoreType.String() = %q, want %q", ScanTypeNixStoreType.String(), "nix_store")
	}

	// Test IsValid()
	if !ScanTypeHomebrewType.IsValid() {
		t.Error("ScanTypeHomebrewType.IsValid() = false, want true")
	}

	scan := ScanTypeType(999)
	if scan.IsValid() {
		t.Error("Invalid ScanTypeType.IsValid() = true, want false")
	}

	// Test Values()
	values := ScanTypeSystemType.Values()
	if len(values) != 4 {
		t.Errorf("ScanTypeType.Values() = %d, want 4", len(values))
	}
}</pre>
<h1>#11 found 2 clones</h1>
<h2>internal/errors/adapters.go:10</h2>
<pre>func isConfigurationError(err error) bool {
	if err == nil {
		return false
	}

	errStr := err.Error()
	// Common indicators of configuration errors
	configIndicators := []string{
		"config", "configuration", "yaml", "json", "toml",
		"parse", "invalid", "missing", "required",
	}

	lowerErrStr := strings.ToLower(errStr)
	for _, indicator := range configIndicators {
		if strings.Contains(lowerErrStr, indicator) {
			return true
		}
	}

	return false
}</pre>
<h2>internal/errors/adapters.go:114</h2>
<pre>func isValidationError(err error) bool {
	if err == nil {
		return false
	}

	errStr := err.Error()
	// Strong indicators of validation errors
	validationIndicators := []string{
		"validation failed", "validation error", "invalid format",
		"invalid range", "required field", "constraint violation",
		"unacceptable value", "validation rule", "invalid value",
	}

	lowerErrStr := strings.ToLower(errStr)
	for _, indicator := range validationIndicators {
		if strings.Contains(lowerErrStr, indicator) {
			return true
		}
	}

	return false
}</pre>
