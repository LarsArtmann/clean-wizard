<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 2 clones</h1>
<h2>internal/errors/errors_test.go:119</h2>
<pre>t.Run("File not found", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrNotExist, Path: "/tmp/missing"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodeFileNotFound, cwErr.Code)
	assert.Equal(t, ErrorTypeFileSystem, cwErr.Type)
	assert.Equal(t, SeverityWarning, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/missing")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h2>internal/errors/errors_test.go:131</h2>
<pre>t.Run("Permission denied", func(t *testing.T) {
	err := &os.PathError{Err: os.ErrPermission, Path: "/tmp/protected"}
	cwErr := adapter.Adapt(err)

	require.NotNil(t, cwErr)
	assert.Equal(t, ErrCodePermissionError, cwErr.Code)
	assert.Equal(t, ErrorTypePermission, cwErr.Type)
	assert.Equal(t, SeverityError, cwErr.Severity)
	assert.Contains(t, cwErr.Message, "/tmp/protected")
	assert.Equal(t, err, cwErr.Cause)
})</pre>
<h1>#2 found 3 clones</h1>
<h2>internal/config/type_safe_validation_rules_test.go:127</h2>
<pre>if original.MaxDiskUsage != nil && copied.MaxDiskUsage != nil {
	if original.MaxDiskUsage.Required == copied.MaxDiskUsage.Required {
		t.Error("FAILED: modified copied.MaxDiskUsage.Required affected original")
	}
	if *original.MaxDiskUsage.Min == *copied.MaxDiskUsage.Min {
		t.Error("FAILED: modified copied.MaxDiskUsage.Min affected original")
	}
	if *original.MaxDiskUsage.Max == *copied.MaxDiskUsage.Max {
		t.Error("FAILED: modified copied.MaxDiskUsage.Max affected original")
	}
	if original.MaxDiskUsage.Message == copied.MaxDiskUsage.Message {
		t.Error("FAILED: modified copied.MaxDiskUsage.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:142</h2>
<pre>if original.MinProtectedPaths != nil && copied.MinProtectedPaths != nil {
	if original.MinProtectedPaths.Required == copied.MinProtectedPaths.Required {
		t.Error("FAILED: modified copied.MinProtectedPaths.Required affected original")
	}
	if *original.MinProtectedPaths.Min == *copied.MinProtectedPaths.Min {
		t.Error("FAILED: modified copied.MinProtectedPaths.Min affected original")
	}
	if *original.MinProtectedPaths.Max == *copied.MinProtectedPaths.Max {
		t.Error("FAILED: modified copied.MinProtectedPaths.Max affected original")
	}
	if original.MinProtectedPaths.Message == copied.MinProtectedPaths.Message {
		t.Error("FAILED: modified copied.MinProtectedPaths.Message affected original")
	}
}</pre>
<h2>internal/config/type_safe_validation_rules_test.go:157</h2>
<pre>if original.MaxProfiles != nil && copied.MaxProfiles != nil {
	if original.MaxProfiles.Required == copied.MaxProfiles.Required {
		t.Error("FAILED: modified copied.MaxProfiles.Required affected original")
	}
	if *original.MaxProfiles.Min == *copied.MaxProfiles.Min {
		t.Error("FAILED: modified copied.MaxProfiles.Min affected original")
	}
	if *original.MaxProfiles.Max == *copied.MaxProfiles.Max {
		t.Error("FAILED: modified copied.MaxProfiles.Max affected original")
	}
	if original.MaxProfiles.Message == copied.MaxProfiles.Message {
		t.Error("FAILED: modified copied.MaxProfiles.Message affected original")
	}
}</pre>
<h1>#3 found 2 clones</h1>
<h2>internal/adapters/http_client.go:91</h2>
<pre>func (hc *HTTPClient) Post(ctx context.Context, url string, body any) (*HTTPResponse, error) {
	resp, err := hc.client.R().SetBody(body).SetContext(ctx).Post(url)
	if err != nil {
		return nil, err
	}
	bodyBytes := resp.Body()
	return &HTTPResponse{
		StatusCode: resp.StatusCode(),
		RawBody:    bodyBytes,
		Body:       string(bodyBytes), // Keep for convenience
		Headers:    resp.Header(),
		Request:    resp.Request,
	}, nil
}</pre>
<h2>internal/adapters/http_client.go:107</h2>
<pre>func (hc *HTTPClient) Put(ctx context.Context, url string, body any) (*HTTPResponse, error) {
	resp, err := hc.client.R().SetBody(body).SetContext(ctx).Put(url)
	if err != nil {
		return nil, err
	}
	bodyBytes := resp.Body()
	return &HTTPResponse{
		StatusCode: resp.StatusCode(),
		RawBody:    bodyBytes,
		Body:       string(bodyBytes), // Keep for convenience
		Headers:    resp.Header(),
		Request:    resp.Request,
	}, nil
}</pre>
