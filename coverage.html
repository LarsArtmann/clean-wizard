<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>commands: Go Coverage Report</title>
    <style>
      			body {
      				background: black;
      				color: rgb(80, 80, 80);
      			}
      			body, pre, #legend span {
      				font-family: Menlo, monospace;
      				font-weight: bold;
      			}
      			#topbar {
      				background: black;
      				position: fixed;
      				top: 0; left: 0; right: 0;
      				height: 42px;
      				border-bottom: 1px solid rgb(80, 80, 80);
      			}
      			#content {
      				margin-top: 50px;
      			}
      			#nav, #legend {
      				float: left;
      				margin-left: 10px;
      			}
      			#legend {
      				margin-top: 12px;
      			}
      			#nav {
      				margin-top: 10px;
      			}
      			#legend span {
      				margin: 0 5px;
      			}
      			.cov0 { color: rgb(192, 0, 0) }
      .cov1 { color: rgb(128, 128, 128) }
      .cov2 { color: rgb(116, 140, 131) }
      .cov3 { color: rgb(104, 152, 134) }
      .cov4 { color: rgb(92, 164, 137) }
      .cov5 { color: rgb(80, 176, 140) }
      .cov6 { color: rgb(68, 188, 143) }
      .cov7 { color: rgb(56, 200, 146) }
      .cov8 { color: rgb(44, 212, 149) }
      .cov9 { color: rgb(32, 224, 152) }
      .cov10 { color: rgb(20, 236, 155) }
    </style>
  </head>
  <body>
    <div id="topbar">
      <div id="nav">
        <select id="files">
          <option value="file0">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/clean.go (0.0%)
          </option>

          <option value="file1">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/config.go (0.0%)
          </option>

          <option value="file2">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/generate.go (0.0%)
          </option>

          <option value="file3">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/init.go (0.0%)
          </option>

          <option value="file4">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/profile.go (0.0%)
          </option>

          <option value="file5">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/root.go (0.0%)
          </option>

          <option value="file6">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/scan.go (0.0%)
          </option>

          <option value="file7">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands/util.go (0.0%)
          </option>

          <option value="file8">
            github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/main.go (0.0%)
          </option>

          <option value="file9">
            github.com/LarsArtmann/clean-wizard/internal/adapters/cache_manager.go (37.5%)
          </option>

          <option value="file10">
            github.com/LarsArtmann/clean-wizard/internal/adapters/environment.go (45.9%)
          </option>

          <option value="file11">
            github.com/LarsArtmann/clean-wizard/internal/adapters/errors.go (90.9%)
          </option>

          <option value="file12">
            github.com/LarsArtmann/clean-wizard/internal/adapters/http_client.go (39.4%)
          </option>

          <option value="file13">
            github.com/LarsArtmann/clean-wizard/internal/adapters/nix.go (0.0%)
          </option>

          <option value="file14">
            github.com/LarsArtmann/clean-wizard/internal/adapters/rate_limiter.go (80.0%)
          </option>

          <option value="file15">
            github.com/LarsArtmann/clean-wizard/internal/api/mapper.go (75.7%)
          </option>

          <option value="file16">
            github.com/LarsArtmann/clean-wizard/internal/cleaner/nix.go (32.1%)
          </option>

          <option value="file17">
            github.com/LarsArtmann/clean-wizard/internal/config/bdd_framework.go (61.5%)
          </option>

          <option value="file18">
            github.com/LarsArtmann/clean-wizard/internal/config/config.go (0.0%)
          </option>

          <option value="file19">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader.go (0.0%)
          </option>

          <option value="file20">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader_api.go (0.0%)
          </option>

          <option value="file21">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader_cache.go (0.0%)
          </option>

          <option value="file22">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader_defaults.go (0.0%)
          </option>

          <option value="file23">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader_private.go (0.0%)
          </option>

          <option value="file24">
            github.com/LarsArtmann/clean-wizard/internal/config/enhanced_loader_types.go (10.5%)
          </option>

          <option value="file25">
            github.com/LarsArtmann/clean-wizard/internal/config/safe.go (70.0%)
          </option>

          <option value="file26">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer.go (78.7%)
          </option>

          <option value="file27">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_homebrew.go (87.5%)
          </option>

          <option value="file28">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_nix.go (50.0%)
          </option>

          <option value="file29">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_operation_settings.go
            (58.3%)
          </option>

          <option value="file30">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_paths.go (76.5%)
          </option>

          <option value="file31">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_profile_main.go (76.0%)
          </option>

          <option value="file32">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_systemtemp.go (82.8%)
          </option>

          <option value="file33">
            github.com/LarsArtmann/clean-wizard/internal/config/sanitizer_tempfiles.go (88.5%)
          </option>

          <option value="file34">
            github.com/LarsArtmann/clean-wizard/internal/config/type_safe_validation_rules.go (0.0%)
          </option>

          <option value="file35">
            github.com/LarsArtmann/clean-wizard/internal/config/validation_middleware.go (0.0%)
          </option>

          <option value="file36">
            github.com/LarsArtmann/clean-wizard/internal/config/validation_middleware_analysis.go
            (0.0%)
          </option>

          <option value="file37">
            github.com/LarsArtmann/clean-wizard/internal/config/validation_middleware_rules.go
            (0.0%)
          </option>

          <option value="file38">
            github.com/LarsArtmann/clean-wizard/internal/config/validator.go (78.9%)
          </option>

          <option value="file39">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_business.go (71.2%)
          </option>

          <option value="file40">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_crossfield.go (86.4%)
          </option>

          <option value="file41">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_field.go (94.1%)
          </option>

          <option value="file42">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_profile.go (0.0%)
          </option>

          <option value="file43">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_rules.go (54.5%)
          </option>

          <option value="file44">
            github.com/LarsArtmann/clean-wizard/internal/config/validator_structure.go (100.0%)
          </option>

          <option value="file45">
            github.com/LarsArtmann/clean-wizard/internal/conversions/conversions.go (88.7%)
          </option>

          <option value="file46">
            github.com/LarsArtmann/clean-wizard/internal/domain/config.go (0.0%)
          </option>

          <option value="file47">
            github.com/LarsArtmann/clean-wizard/internal/domain/duration_parser.go (95.7%)
          </option>

          <option value="file48">
            github.com/LarsArtmann/clean-wizard/internal/domain/operation_settings.go (0.0%)
          </option>

          <option value="file49">
            github.com/LarsArtmann/clean-wizard/internal/domain/type_safe_enums.go (12.9%)
          </option>

          <option value="file50">
            github.com/LarsArtmann/clean-wizard/internal/domain/types.go (30.6%)
          </option>

          <option value="file51">
            github.com/LarsArtmann/clean-wizard/internal/errors/errors.go (0.0%)
          </option>

          <option value="file52">
            github.com/LarsArtmann/clean-wizard/internal/format/bytes_function.go (0.0%)
          </option>

          <option value="file53">
            github.com/LarsArtmann/clean-wizard/internal/format/format.go (100.0%)
          </option>

          <option value="file54">
            github.com/LarsArtmann/clean-wizard/internal/middleware/validation.go (100.0%)
          </option>

          <option value="file55">
            github.com/LarsArtmann/clean-wizard/internal/pkg/errors/errors.go (0.0%)
          </option>

          <option value="file56">
            github.com/LarsArtmann/clean-wizard/internal/pkg/errors/handlers.go (0.0%)
          </option>

          <option value="file57">
            github.com/LarsArtmann/clean-wizard/internal/result/type.go (70.8%)
          </option>
        </select>
      </div>
      <div id="legend">
        <span>not tracked</span>

        <span class="cov0">no coverage</span>
        <span class="cov1">low coverage</span>
        <span class="cov2">*</span>
        <span class="cov3">*</span>
        <span class="cov4">*</span>
        <span class="cov5">*</span>
        <span class="cov6">*</span>
        <span class="cov7">*</span>
        <span class="cov8">*</span>
        <span class="cov9">*</span>
        <span class="cov10">high coverage</span>
      </div>
    </div>
    <div id="content">
      <pre class="file" id="file0" style="display: none">package commands

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/cleaner"
        "github.com/LarsArtmann/clean-wizard/internal/config"
        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/format"
        "github.com/LarsArtmann/clean-wizard/internal/middleware"
        "github.com/spf13/cobra"
)

var (
        cleanDryRun  bool
        cleanVerbose bool
)

// NewCleanCommand creates clean command with proper domain types
func NewCleanCommand(validationLevel config.ValidationLevel) *cobra.Command <span class="cov0" title="0">{
        var configFile string
        var profileName string

        cleanCmd := &amp;cobra.Command{
                Use:   "clean",
                Short: "Perform system cleanup",
                Long:  `Safely clean old files, package caches, and temporary data from your system.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        fmt.Println("üßπ Starting system cleanup...")
                        ctx := context.Background()

                        // Parse validation level from flag
                        validationLevelStr, _ := cmd.Flags().GetString("validation-level")
                        validationLevel := ParseValidationLevel(validationLevelStr)

                        // Parse profile name from flag
                        profileName, _ = cmd.Flags().GetString("profile")

                        // Load and validate configuration if provided
                        var loadedCfg *domain.Config
                        if configFile != "" </span><span class="cov0" title="0">{
                                fmt.Printf("üìÑ Loading configuration from %s...\n", configFile)

                                // Set config file path using environment variable
                                os.Setenv("CONFIG_PATH", configFile)

                                var err error
                                loadedCfg, err = config.LoadWithContext(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load configuration: %w", err)
                                }</span>

                                // Apply validation based on level
                                <span class="cov0" title="0">if validationLevel &gt; config.ValidationLevelNone </span><span class="cov0" title="0">{
                                        fmt.Printf("üîç Applying validation level: %s\n", validationLevel.String())

                                        if validationLevel &gt;= config.ValidationLevelBasic </span><span class="cov0" title="0">{
                                                // Basic validation
                                                if len(loadedCfg.Protected) == 0 </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("basic validation failed: protected paths cannot be empty")
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if validationLevel &gt;= config.ValidationLevelComprehensive </span><span class="cov0" title="0">{
                                                // Comprehensive validation
                                                if err := loadedCfg.Validate(); err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("comprehensive validation failed: %w", err)
                                                }</span>
                                        }

                                        <span class="cov0" title="0">if validationLevel &gt;= config.ValidationLevelStrict </span><span class="cov0" title="0">{
                                                // Strict validation
                                                if !loadedCfg.SafeMode </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("strict validation failed: safe_mode must be enabled")
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration applied: safe_mode=%v, profiles=%d\n",
                                        loadedCfg.SafeMode, len(loadedCfg.Profiles))</span>
                        } else<span class="cov0" title="0"> {
                                // Load default configuration to get profile information
                                var err error
                                loadedCfg, err = config.LoadWithContext(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("‚ö†Ô∏è  Could not load default configuration: %v\n", err)
                                        // Continue without profile support
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("üìã Using configuration from ~/.clean-wizard.yaml\n")
                                }</span>
                        }

                        // Apply profile if specified
                        <span class="cov0" title="0">var usedProfile *domain.Profile
                        if loadedCfg != nil &amp;&amp; profileName != "" </span><span class="cov0" title="0">{
                                profile, exists := loadedCfg.Profiles[profileName]
                                if !exists </span><span class="cov0" title="0">{
                                        return fmt.Errorf("profile '%s' not found in configuration", profileName)
                                }</span>

                                <span class="cov0" title="0">if !profile.Enabled </span><span class="cov0" title="0">{
                                        return fmt.Errorf("profile '%s' is disabled", profileName)
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("üè∑Ô∏è  Using profile: %s (%s)\n", profileName, profile.Description)
                                usedProfile = profile</span>
                        } else<span class="cov0" title="0"> if loadedCfg != nil &amp;&amp; loadedCfg.CurrentProfile != "" </span><span class="cov0" title="0">{
                                // Use current profile from config
                                profile := loadedCfg.Profiles[loadedCfg.CurrentProfile]
                                if profile != nil &amp;&amp; profile.Enabled </span><span class="cov0" title="0">{
                                        fmt.Printf("üè∑Ô∏è  Using current profile: %s (%s)\n", loadedCfg.CurrentProfile, profile.Description)
                                        usedProfile = profile
                                }</span>
                        } else<span class="cov0" title="0"> if loadedCfg != nil </span><span class="cov0" title="0">{
                                // Default to daily profile if available
                                if dailyProfile, exists := loadedCfg.Profiles["daily"]; exists &amp;&amp; dailyProfile.Enabled </span><span class="cov0" title="0">{
                                        fmt.Printf("üìã Using daily profile configuration\n")
                                        usedProfile = dailyProfile
                                }</span>
                        }

                        // Extract settings from profile if available
                        <span class="cov0" title="0">var settings *domain.OperationSettings
                        if usedProfile != nil </span><span class="cov0" title="0">{
                                for _, op := range usedProfile.Operations </span><span class="cov0" title="0">{
                                        if op.Name == "nix-generations" &amp;&amp; op.Enabled </span><span class="cov0" title="0">{
                                                fmt.Printf("üîß Configuring Nix generations cleanup\n")
                                                fmt.Printf("üîç Operation Settings: %+v\n", op.Settings)
                                                if op.Settings != nil </span><span class="cov0" title="0">{
                                                        settings = op.Settings
                                                        fmt.Printf("‚úÖ Using operation settings: %+v\n", settings)
                                                }</span> else<span class="cov0" title="0"> {
                                                        settings = domain.DefaultSettings(domain.OperationTypeNixGenerations)
                                                        fmt.Printf("‚ùå Using default settings: %+v\n", settings)
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                        }

                        // Extract dry-run from settings if configured in Nix generations
                        <span class="cov0" title="0">actualDryRun := cleanDryRun
                        fmt.Printf("üîç Debug: settings = %+v\n", settings)
                        
                        if settings != nil </span><span class="cov0" title="0">{
                                fmt.Printf("üîç Debug: settings.NixGenerations = %+v\n", settings.NixGenerations)
                                if settings.NixGenerations != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("üîç Debug: NixGenerations.Optimize = %v\n", settings.NixGenerations.Optimize)
                                        fmt.Printf("üîç Debug: NixGenerations.DryRun = %v\n", settings.NixGenerations.DryRun)
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if settings != nil &amp;&amp; settings.NixGenerations != nil &amp;&amp; settings.NixGenerations.Optimize </span><span class="cov0" title="0">{
                                // Using Optimize field as dry-run indicator for now
                                actualDryRun = true
                                fmt.Println("üîç Running in DRY-RUN mode (from config) - no files will be deleted")
                        }</span> else<span class="cov0" title="0"> if cleanDryRun </span><span class="cov0" title="0">{
                                fmt.Println("üîç Running in DRY-RUN mode (from flag) - no files will be deleted")
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("‚öôÔ∏è  Settings loaded: %+v\n", settings)
                        if settings != nil </span><span class="cov0" title="0">{
                                if settings.NixGenerations != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("üéõÔ∏è  Nix Generations Settings: %+v\n", settings.NixGenerations)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("‚ùå Nix Generations Settings: nil\n")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("‚ùå Settings: nil\n")
                        }</span>

                        <span class="cov0" title="0">nixCleaner := cleaner.NewNixCleaner(cleanVerbose, actualDryRun)

                        validator := middleware.NewValidationMiddleware()
                        validatedSettings := validator.ValidateCleanerSettings(ctx, nixCleaner, settings)
                        if validatedSettings.IsErr() </span><span class="cov0" title="0">{
                                return fmt.Errorf("cleaner validation failed: %w", validatedSettings.Error())
                        }</span>

                        <span class="cov0" title="0">startTime := time.Now()

                        // Clean old generations (keep last 3)
                        result := nixCleaner.CleanOldGenerations(ctx, 3)

                        if result.IsErr() </span><span class="cov0" title="0">{
                                _, err := result.Unwrap()
                                return handleCleanError(err, actualDryRun)
                        }</span>

                        <span class="cov0" title="0">duration := time.Since(startTime)
                        displayCleanResults(result.Value(), cleanVerbose, duration, actualDryRun)
                        return nil</span>
                },
        }

        // Clean command flags
        <span class="cov0" title="0">cleanCmd.Flags().BoolVar(&amp;cleanDryRun, "dry-run", false, "Show what would be cleaned without doing it")
        cleanCmd.Flags().BoolVar(&amp;cleanVerbose, "verbose", false, "Show detailed output")
        cleanCmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Configuration file path")

        return cleanCmd</span>
}

// handleCleanError provides user-friendly error messages
func handleCleanError(err error, isDryRun bool) error <span class="cov0" title="0">{
        if isDryRun </span><span class="cov0" title="0">{
                fmt.Printf("üîç Dry run encountered issues: %s\n", err)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("cleanup failed: %w", err)</span>
}

// displayCleanResults shows cleanup results to user
func displayCleanResults(result domain.CleanResult, verbose bool, duration time.Duration, isDryRun bool) <span class="cov0" title="0">{
        status := "SUCCESS"
        if !result.IsValid() </span><span class="cov0" title="0">{
                status = "FAILED"
        }</span>

        <span class="cov0" title="0">action := "cleaned"
        if isDryRun </span><span class="cov0" title="0">{
                action = "would be cleaned"
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüéØ Cleanup Results (%s):\n", status)
        fmt.Printf("   ‚Ä¢ Duration: %s\n", duration.String())

        if result.IsValid() </span><span class="cov0" title="0">{
                fmt.Printf("   ‚Ä¢ Status: %d items %s\n", result.ItemsRemoved, action)
                if result.FreedBytes &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   ‚Ä¢ Space freed: %s\n", format.Bytes(int64(result.FreedBytes)))
                }</span>

                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("\nüìã Details:\n")
                        fmt.Printf("   - Strategy: %s\n", result.Strategy)
                        fmt.Printf("   - Items failed: %d\n", result.ItemsFailed)
                }</span>
        }

        <span class="cov0" title="0">if isDryRun </span><span class="cov0" title="0">{
                fmt.Printf("\nüí° This was a dry run - no files were actually deleted\n")
                fmt.Printf("   üèÉ Run 'clean-wizard clean' without --dry-run to perform cleanup\n")
        }</span>

        <span class="cov0" title="0">if result.IsValid() </span><span class="cov0" title="0">{
                fmt.Printf("\n‚úÖ Cleanup completed successfully\n")
        }</span>
}
</pre>

      <pre class="file" id="file1" style="display: none">package commands

import (
        "fmt"

        "github.com/spf13/cobra"
)

// NewConfigCommand creates config command
func NewConfigCommand() *cobra.Command <span class="cov0" title="0">{
        configCmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Manage configuration",
        }

        configCmd.AddCommand(&amp;cobra.Command{
                Use:   "show",
                Short: "Show current configuration",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Println("Configuration file: ~/.clean-wizard.yaml")
                        fmt.Println("Version: dev")
                        fmt.Println("Safe mode: true")
                        fmt.Println("Dry run: true")
                }</span>,
        })

        <span class="cov0" title="0">return configCmd</span>
}
</pre>

      <pre class="file" id="file2" style="display: none">package commands

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

// NewGenerateCommand creates configuration generation command
func NewGenerateCommand() *cobra.Command <span class="cov0" title="0">{
        var outputFile string
        var template string

        generateCmd := &amp;cobra.Command{
                Use:   "generate",
                Short: "Generate configuration templates",
                Long: `Create configuration file templates for different use cases.

Available templates:
- simple    : Basic configuration for everyday use
- working    : Complete configuration with all features
- minimal    : Bare minimum configuration for testing
- advanced   : Production-ready configuration with all options`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                template = args[0]
                        }</span>

                        <span class="cov0" title="0">return generateConfigTemplate(template, outputFile)</span>
                },
        }

        // Command flags
        <span class="cov0" title="0">generateCmd.Flags().StringVarP(&amp;outputFile, "output", "o", "clean-wizard.yaml", "Output configuration file")
        generateCmd.Flags().StringVarP(&amp;template, "template", "t", "working", "Configuration template (simple, working, minimal, advanced)")

        return generateCmd</span>
}

// generateConfigTemplate generates the specified configuration template
func generateConfigTemplate(template, outputFile string) error <span class="cov0" title="0">{
        var content string

        switch template </span>{
        case "simple":<span class="cov0" title="0">
                content = getSimpleTemplate()</span>
        case "working":<span class="cov0" title="0">
                content = getWorkingTemplate()</span>
        case "minimal":<span class="cov0" title="0">
                content = getMinimalTemplate()</span>
        case "advanced":<span class="cov0" title="0">
                content = getAdvancedTemplate()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown template: %s. Available: simple, working, minimal, advanced", template)</span>
        }

        // Write to file
        <span class="cov0" title="0">err := os.WriteFile(outputFile, []byte(content), 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration template '%s' generated: %s\n", template, outputFile)
        fmt.Printf("üí° Edit the file to customize your cleanup strategy\n")
        fmt.Printf("üèÉ Run 'clean-wizard scan --config %s' to test configuration\n", outputFile)

        return nil</span>
}

// getSimpleTemplate returns basic configuration template
func getSimpleTemplate() string <span class="cov0" title="0">{
        return `# Clean-wizard basic configuration
# Generated with: clean-wizard generate simple

version: "1.0.0"
safe_mode: true
max_disk_usage: 50

# Protected system paths (never cleaned)
protected:
  - "/System"
  - "/Library"
  - "/Applications"
  - "/usr"
  - "/etc"
  - "/var"
  - "/bin"
  - "/sbin"

# Cleanup profiles
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup for routine maintenance"
    enabled: true
    operations:
      - name: "nix-generations"
        description: "Clean old Nix generations"
        risk_level: "LOW"
        enabled: true
        settings:
          keep_count: 3
`
}</span>

// getWorkingTemplate returns complete configuration template
func getWorkingTemplate() string <span class="cov0" title="0">{
        return `# Clean-wizard working configuration
# Generated with: clean-wizard generate working

version: "1.0.0"
safe_mode: true
max_disk_usage: 50

# Protected system paths (never cleaned)
protected:
  - "/"
  - "/System"
  - "/Library"
  - "/Applications"
  - "/usr"
  - "/etc"
  - "/var"
  - "/bin"
  - "/sbin"

# Cleanup profiles
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup for routine maintenance"
    enabled: true
    operations:
      - name: "nix-generations"
        description: "Clean old Nix generations"
        risk_level: "LOW"
        enabled: true
        settings:
          keep_count: 3
  
  weekly:
    name: "weekly"
    description: "Weekly cleanup for deeper maintenance"
    enabled: false
    operations:
      - name: "package-caches"
        description: "Clean package manager caches"
        risk_level: "MEDIUM"
        enabled: true
        settings:
          keep_recent: true
`
}</span>

// getMinimalTemplate returns bare minimum configuration
func getMinimalTemplate() string <span class="cov0" title="0">{
        return `# Clean-wizard minimal configuration
# Generated with: clean-wizard generate minimal

version: "1.0.0"
safe_mode: true
max_disk_usage: 50

protected: []

profiles:
  basic:
    name: "basic"
    description: "Basic cleanup"
    enabled: true
    operations:
      - name: "nix-generations"
        description: "Clean Nix generations"
        risk_level: "LOW"
        enabled: true
`
}</span>

// getAdvancedTemplate returns production-ready configuration
func getAdvancedTemplate() string <span class="cov0" title="0">{
        return `# Clean-wizard advanced production configuration
# Generated with: clean-wizard generate advanced

version: "1.0.0"
safe_mode: true
max_disk_usage: 70

# Protected system paths (never cleaned)
protected:
  - "/"
  - "/System"
  - "/Library"
  - "/Applications"
  - "/usr"
  - "/usr/local"
  - "/etc"
  - "/var"
  - "/bin"
  - "/sbin"
  - "/opt"

# User-defined protected paths
user_protected:
  - "/Users/Documents"
  - "/Users/Downloads/Important"
  - "/home/user/projects"

# Cleanup profiles
profiles:
  daily:
    name: "daily"
    description: "Daily cleanup for routine maintenance"
    enabled: true
    operations:
      - name: "nix-generations"
        description: "Clean old Nix generations"
        risk_level: "LOW"
        enabled: true
        settings:
          keep_count: 3
          keep_current: true
  
  weekly:
    name: "weekly"
    description: "Weekly cleanup for deeper maintenance"
    enabled: true
    operations:
      - name: "package-caches"
        description: "Clean package manager caches"
        risk_level: "MEDIUM"
        enabled: true
        settings:
          keep_recent: true
          max_age_days: 30
  
  monthly:
    name: "monthly"
    description: "Monthly cleanup for deep maintenance"
    enabled: false
    operations:
      - name: "temp-files"
        description: "Clean temporary files"
        risk_level: "MEDIUM"
        enabled: true
        settings:
          max_age_days: 7
          exclude_patterns: ["*.log", "*.tmp"]
      
      - name: "logs"
        description: "Clean old log files"
        risk_level: "MEDIUM"
        enabled: true
        settings:
          max_age_days: 14
          keep_critical: true

# Configuration settings
settings:
  dry_run_default: true
  confirm_before_delete: true
  backup_important_files: true
  log_cleanup_operations: true
  max_cleanup_time_minutes: 60
`
}</span>
</pre>

      <pre class="file" id="file3" style="display: none">package commands

import (
        "fmt"

        "github.com/spf13/cobra"
)

// NewInitCommand creates init command
func NewInitCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "init",
                Short: "Interactive setup wizard",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        fmt.Println("üßπ Clean Wizard Setup")
                        fmt.Println("======================")
                        fmt.Println("Configuration created successfully!")
                }</span>,
        }
}
</pre>

      <pre class="file" id="file4" style="display: none">package commands

import (
        "fmt"
        "sort"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/config"
        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/spf13/cobra"
)

// NewProfileCommand creates the profile command
func NewProfileCommand() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "profile",
                Short: "Manage configuration profiles",
                Long:  `Manage and view cleanup configuration profiles for different cleaning strategies.`,
        }

        // Add subcommands
        cmd.AddCommand(
                NewProfileListCommand(),
                NewProfileSelectCommand(),
                NewProfileInfoCommand(),
        )

        return cmd
}</span>

// NewProfileListCommand creates the profile list command
func NewProfileListCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "list",
                Short: "List all available profiles",
                Long:  `List all available configuration profiles with their descriptions and status.`,
                Args:  cobra.NoArgs,
                RunE:  runProfileList,
        }
}</span>

// NewProfileSelectCommand creates the profile select command
func NewProfileSelectCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "select [profile-name]",
                Short: "Select a profile as the default",
                Long:  `Select a profile as the default for future clean and scan operations.`,
                Args:  cobra.ExactArgs(1),
                RunE:  runProfileSelect,
        }
}</span>

// NewProfileInfoCommand creates the profile info command
func NewProfileInfoCommand() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "info [profile-name]",
                Short: "Show detailed information about a profile",
                Long:  `Show detailed information about a specific profile including all operations and their settings.`,
                Args:  cobra.MaximumNArgs(1),
                RunE:  runProfileInfo,
        }
}</span>

// runProfileList lists all available profiles
func runProfileList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">if len(cfg.Profiles) == 0 </span><span class="cov0" title="0">{
                fmt.Println("‚ùå No profiles found in configuration")
                return nil
        }</span>

        // Sort profile names for consistent display
        <span class="cov0" title="0">var profileNames []string
        for name := range cfg.Profiles </span><span class="cov0" title="0">{
                profileNames = append(profileNames, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(profileNames)

        fmt.Printf("üìã Available Profiles:\n\n")

        for _, name := range profileNames </span><span class="cov0" title="0">{
                profile := cfg.Profiles[name]
                status := "‚úÖ Enabled"
                if !profile.Enabled </span><span class="cov0" title="0">{
                        status = "‚ùå Disabled"
                }</span>

                <span class="cov0" title="0">fmt.Printf("üè∑Ô∏è  %s\n", name)
                fmt.Printf("   Description: %s\n", profile.Description)
                fmt.Printf("   Status: %s\n", status)
                fmt.Printf("   Operations: %d\n", len(profile.Operations))

                // Show risk level summary
                riskLevels := make(map[domain.RiskLevel]int)
                for _, op := range profile.Operations </span><span class="cov0" title="0">{
                        riskLevels[op.RiskLevel]++
                }</span>

                <span class="cov0" title="0">var riskSummary []string
                if riskLevels[domain.RiskLow] &gt; 0 </span><span class="cov0" title="0">{
                        riskSummary = append(riskSummary, fmt.Sprintf("%d low", riskLevels[domain.RiskLow]))
                }</span>
                <span class="cov0" title="0">if riskLevels[domain.RiskMedium] &gt; 0 </span><span class="cov0" title="0">{
                        riskSummary = append(riskSummary, fmt.Sprintf("%d medium", riskLevels[domain.RiskMedium]))
                }</span>
                <span class="cov0" title="0">if riskLevels[domain.RiskHigh] &gt; 0 </span><span class="cov0" title="0">{
                        riskSummary = append(riskSummary, fmt.Sprintf("%d high", riskLevels[domain.RiskHigh]))
                }</span>
                <span class="cov0" title="0">if riskLevels[domain.RiskCritical] &gt; 0 </span><span class="cov0" title="0">{
                        riskSummary = append(riskSummary, fmt.Sprintf("%d critical", riskLevels[domain.RiskCritical]))
                }</span>

                <span class="cov0" title="0">if len(riskSummary) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   Risk levels: %s\n", strings.Join(riskSummary, ", "))
                }</span>

                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// runProfileSelect selects a profile as default
func runProfileSelect(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        profileName := args[0]

        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Check if profile exists
        <span class="cov0" title="0">profile, exists := cfg.Profiles[profileName]
        if !exists </span><span class="cov0" title="0">{
                // Show available profiles
                var names []string
                for name := range cfg.Profiles </span><span class="cov0" title="0">{
                        names = append(names, name)
                }</span>
                <span class="cov0" title="0">sort.Strings(names)
                return fmt.Errorf("profile '%s' not found. Available profiles: %s",
                        profileName, strings.Join(names, ", "))</span>
        }

        // Check if profile is enabled
        <span class="cov0" title="0">if !profile.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("profile '%s' is disabled. Enable it first before selecting.", profileName)
        }</span>

        // Update current profile in config
        <span class="cov0" title="0">cfg.CurrentProfile = profileName
        cfg.Updated = config.GetCurrentTime()

        // Save configuration
        if err := config.Save(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úÖ Profile '%s' selected as default\n", profileName)
        fmt.Printf("üìù Configuration updated in ~/.clean-wizard.yaml\n")

        return nil</span>
}

// runProfileInfo shows detailed information about a profile
func runProfileInfo(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">var profileName string
        if len(args) == 1 </span><span class="cov0" title="0">{
                profileName = args[0]
        }</span> else<span class="cov0" title="0"> {
                profileName = cfg.CurrentProfile
                if profileName == "" </span><span class="cov0" title="0">{
                        profileName = "daily" // Default fallback
                }</span>
        }

        <span class="cov0" title="0">profile, exists := cfg.Profiles[profileName]
        if !exists </span><span class="cov0" title="0">{
                var names []string
                for name := range cfg.Profiles </span><span class="cov0" title="0">{
                        names = append(names, name)
                }</span>
                <span class="cov0" title="0">sort.Strings(names)
                return fmt.Errorf("profile '%s' not found. Available profiles: %s",
                        profileName, strings.Join(names, ", "))</span>
        }

        <span class="cov0" title="0">fmt.Printf("üìã Profile Details: %s\n", profile.Name)
        fmt.Printf("%s\n", strings.Repeat("=", len(profile.Name)+20))

        // Basic info
        status := "‚úÖ Enabled"
        if !profile.Enabled </span><span class="cov0" title="0">{
                status = "‚ùå Disabled"
        }</span>

        <span class="cov0" title="0">fmt.Printf("Description: %s\n", profile.Description)
        fmt.Printf("Status: %s\n", status)

        // Check if this is the current profile
        isCurrent := (cfg.CurrentProfile == profileName)
        if isCurrent </span><span class="cov0" title="0">{
                fmt.Printf("Current: ‚úÖ Yes (default profile)\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Current: ‚ùå No (current: %s)\n", cfg.CurrentProfile)
        }</span>

        <span class="cov0" title="0">fmt.Println()

        // Operations
        if len(profile.Operations) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("Operations: None configured\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Operations (%d total):\n", len(profile.Operations))
                fmt.Println()

                for i, op := range profile.Operations </span><span class="cov0" title="0">{
                        status := "‚úÖ Enabled"
                        if !op.Enabled </span><span class="cov0" title="0">{
                                status = "‚ùå Disabled"
                        }</span>

                        <span class="cov0" title="0">riskColor := getRiskColor(op.RiskLevel)
                        fmt.Printf("  %d. %s\n", i+1, op.Name)
                        fmt.Printf("     Description: %s\n", op.Description)
                        fmt.Printf("     Status: %s\n", status)
                        fmt.Printf("     Risk Level: %s%s\n", riskColor, op.RiskLevel.String())

                        // Show settings if any
                        if op.Settings != nil </span><span class="cov0" title="0">{
                                fmt.Printf("     Settings:\n")
                                if op.Settings.NixGenerations != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("       ‚Ä¢ generations: %d\n", op.Settings.NixGenerations.Generations)
                                        fmt.Printf("       ‚Ä¢ optimize: %t\n", op.Settings.NixGenerations.Optimize)
                                }</span>
                                <span class="cov0" title="0">if op.Settings.TempFiles != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("       ‚Ä¢ older_than: %s\n", op.Settings.TempFiles.OlderThan)
                                        if len(op.Settings.TempFiles.Excludes) &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("       ‚Ä¢ excludes: %v\n", op.Settings.TempFiles.Excludes)
                                        }</span>
                                }
                                <span class="cov0" title="0">if op.Settings.Homebrew != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("       ‚Ä¢ unused_only: %t\n", op.Settings.Homebrew.UnusedOnly)
                                }</span>
                                <span class="cov0" title="0">if op.Settings.SystemTemp != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("       ‚Ä¢ paths: %v\n", op.Settings.SystemTemp.Paths)
                                        fmt.Printf("       ‚Ä¢ older_than: %s\n", op.Settings.SystemTemp.OlderThan)
                                }</span>
                        }

                        <span class="cov0" title="0">if i &lt; len(profile.Operations)-1 </span><span class="cov0" title="0">{
                                fmt.Println()
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println()

        // Usage hint
        if !isCurrent &amp;&amp; profile.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("üí° To use this profile: clean-wizard profile select %s\n", profileName)
        }</span> else<span class="cov0" title="0"> if !profile.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("‚ö†Ô∏è  This profile is disabled. Enable it in the configuration to use it.\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getRiskColor returns color code for risk level
func getRiskColor(level domain.RiskLevel) string <span class="cov0" title="0">{
        switch level </span>{
        case domain.RiskLow:<span class="cov0" title="0">
                return "üü¢ "</span> // Green
        case domain.RiskMedium:<span class="cov0" title="0">
                return "üü° "</span> // Yellow
        case domain.RiskHigh:<span class="cov0" title="0">
                return "üü† "</span> // Orange
        case domain.RiskCritical:<span class="cov0" title="0">
                return "üî¥ "</span> // Red
        default:<span class="cov0" title="0">
                return "‚ö™ "</span> // White
        }
}
</pre>

      <pre class="file" id="file5" style="display: none">package commands

import "github.com/spf13/cobra"

// NewRootCmd creates the root command
func NewRootCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "clean-wizard",
                Short: "Safe system cleanup tool",
                Long:  `A professional system cleanup tool that safely removes old files, package caches, and temporary data.`,
        }
}</span>
</pre>

      <pre class="file" id="file6" style="display: none">package commands

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/cleaner"
        "github.com/LarsArtmann/clean-wizard/internal/config"
        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/format"
        "github.com/LarsArtmann/clean-wizard/internal/middleware"
        "github.com/spf13/cobra"
)

// NewScanCommand creates scan command with proper domain types
func NewScanCommand(verbose bool, validationLevel config.ValidationLevel) *cobra.Command <span class="cov0" title="0">{
        var configFile string
        var profileName string

        cmd := &amp;cobra.Command{
                Use:   "scan",
                Short: "Scan system for cleanable items",
                Long:  `Analyze your system to identify old files, package caches, and temporary data that can be safely cleaned.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        fmt.Println("üîç Analyzing system state...")
                        ctx := context.Background()

                        // Parse validation level from flag
                        validationLevelStr, _ := cmd.Flags().GetString("validation-level")
                        validationLevel = ParseValidationLevel(validationLevelStr)

                        // Parse profile name from flag
                        profileName, _ = cmd.Flags().GetString("profile")

                        // Determine scan parameters from configuration
                        scanType := domain.ScanTypeNixStore
                        recursive := true
                        limit := 100
                        var loadedCfg *domain.Config

                        // Load and validate configuration if provided
                        if configFile != "" </span><span class="cov0" title="0">{
                                fmt.Printf("üìÑ Loading configuration from %s...\n", configFile)

                                // Set config file path using environment variable
                                os.Setenv("CONFIG_PATH", configFile)

                                var err error
                                loadedCfg, err = config.LoadWithContext(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load configuration: %w", err)
                                }</span>

                                // Apply validation based on level
                                <span class="cov0" title="0">if validationLevel &gt; config.ValidationLevelNone </span><span class="cov0" title="0">{
                                        fmt.Printf("üîç Applying validation level: %s\n", validationLevel.String())

                                        if validationLevel &gt;= config.ValidationLevelBasic </span><span class="cov0" title="0">{
                                                // Basic validation
                                                if len(loadedCfg.Protected) == 0 </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("basic validation failed: protected paths cannot be empty")
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // Load default configuration to get profile information
                                var err error
                                loadedCfg, err = config.LoadWithContext(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("‚ö†Ô∏è  Could not load default configuration: %v\n", err)
                                        // Continue without profile support
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("üìã Using configuration from ~/.clean-wizard.yaml\n")
                                }</span>
                        }

                        // Apply validation if we have loaded configuration
                        <span class="cov0" title="0">if loadedCfg != nil &amp;&amp; validationLevel &gt; config.ValidationLevelNone </span><span class="cov0" title="0">{
                                fmt.Printf("üîç Applying validation level: %s\n", validationLevel.String())

                                if validationLevel &gt;= config.ValidationLevelBasic </span><span class="cov0" title="0">{
                                        // Basic validation
                                        if len(loadedCfg.Protected) == 0 </span><span class="cov0" title="0">{
                                                return fmt.Errorf("basic validation failed: protected paths cannot be empty")
                                        }</span>
                                }

                                <span class="cov0" title="0">if validationLevel &gt;= config.ValidationLevelComprehensive </span><span class="cov0" title="0">{
                                        // Comprehensive validation
                                        if err := loadedCfg.Validate(); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("comprehensive validation failed: %w", err)
                                        }</span>
                                }

                                <span class="cov0" title="0">if validationLevel &gt;= config.ValidationLevelStrict </span><span class="cov0" title="0">{
                                        // Strict validation
                                        if !loadedCfg.SafeMode </span><span class="cov0" title="0">{
                                                return fmt.Errorf("strict validation failed: safe_mode must be enabled")
                                        }</span>
                                }

                                <span class="cov0" title="0">fmt.Printf("‚úÖ Configuration applied: safe_mode=%v, profiles=%d\n",
                                        loadedCfg.SafeMode, len(loadedCfg.Profiles))</span>
                        }

                        // Apply profile if specified
                        <span class="cov0" title="0">if loadedCfg != nil &amp;&amp; profileName != "" </span><span class="cov0" title="0">{
                                profile, exists := loadedCfg.Profiles[profileName]
                                if !exists </span><span class="cov0" title="0">{
                                        return fmt.Errorf("profile '%s' not found in configuration", profileName)
                                }</span>

                                <span class="cov0" title="0">if !profile.Enabled </span><span class="cov0" title="0">{
                                        return fmt.Errorf("profile '%s' is disabled", profileName)
                                }</span>

                                <span class="cov0" title="0">fmt.Printf("üè∑Ô∏è  Using profile: %s (%s)\n", profileName, profile.Description)</span>
                        } else<span class="cov0" title="0"> if loadedCfg != nil &amp;&amp; loadedCfg.CurrentProfile != "" </span><span class="cov0" title="0">{
                                // Use current profile from config
                                profile := loadedCfg.Profiles[loadedCfg.CurrentProfile]
                                if profile != nil &amp;&amp; profile.Enabled </span><span class="cov0" title="0">{
                                        fmt.Printf("üè∑Ô∏è  Using current profile: %s (%s)\n", loadedCfg.CurrentProfile, profile.Description)
                                }</span>
                        } else<span class="cov0" title="0"> if loadedCfg != nil </span><span class="cov0" title="0">{
                                // Default to daily profile if available
                                if dailyProfile, exists := loadedCfg.Profiles["daily"]; exists &amp;&amp; dailyProfile.Enabled </span><span class="cov0" title="0">{
                                        fmt.Printf("üìã Using daily profile configuration\n")
                                        // Extract scan parameters from profile
                                        for _, op := range dailyProfile.Operations </span><span class="cov0" title="0">{
                                                if op.Name == "nix-generations" &amp;&amp; op.Enabled </span><span class="cov0" title="0">{
                                                        // Nix generations scanning
                                                        limit = 50 // Default for generations
                                                        break</span>
                                                }
                                        }
                                }
                        }

                        // Create scan request with applied configuration
                        <span class="cov0" title="0">scanReq := domain.ScanRequest{
                                Type:      scanType,
                                Recursive: recursive,
                                Limit:     limit,
                        }

                        // Validate scan request
                        validator := middleware.NewValidationMiddleware()
                        validatedReq := validator.ValidateScanRequest(ctx, scanReq)
                        if validatedReq.IsErr() </span><span class="cov0" title="0">{
                                return fmt.Errorf("scan validation failed: %w", validatedReq.Error())
                        }</span>

                        // Perform scan
                        <span class="cov0" title="0">nixCleaner := cleaner.NewNixCleaner(verbose, false)
                        result := nixCleaner.ListGenerations(ctx)

                        if result.IsErr() </span><span class="cov0" title="0">{
                                return fmt.Errorf("scan failed: %w", result.Error())
                        }</span>

                        // Convert generations to scan result for display
                        <span class="cov0" title="0">generations := result.Value()

                        // Calculate total bytes from generations
                        var totalBytes int64
                        for _, gen := range generations </span><span class="cov0" title="0">{
                                totalBytes += gen.EstimateSize()
                        }</span>

                        <span class="cov0" title="0">scanResult := domain.ScanResult{
                                TotalBytes:   totalBytes,
                                TotalItems:   len(generations),
                                ScannedPaths: []string{"/nix/store"},
                                ScanTime:     time.Duration(100 * time.Millisecond),
                                ScannedAt:    time.Now(),
                        }

                        // Display results
                        displayScanResults(scanResult, generations, verbose)
                        return nil</span>
                },
        }

        // Scan command flags
        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;configFile, "config", "c", "", "Configuration file path")

        return cmd</span>
}

// displayScanResults shows scan results to user
func displayScanResults(result domain.ScanResult, generations []domain.NixGeneration, verbose bool) <span class="cov0" title="0">{
        fmt.Printf("\nüìä Scan Results:\n")
        fmt.Printf("   ‚Ä¢ Total generations: %d\n", result.TotalItems)

        // Count current generations
        currentCount := 0
        for _, gen := range generations </span><span class="cov0" title="0">{
                if gen.Current </span><span class="cov0" title="0">{
                        currentCount++
                }</span>
        }

        // Calculate cleanable generations (non-current ones)
        <span class="cov0" title="0">cleanableCount := len(generations) - currentCount

        fmt.Printf("   ‚Ä¢ Current generation: %d\n", currentCount)
        fmt.Printf("   ‚Ä¢ Cleanable generations: %d\n", cleanableCount)
        fmt.Printf("   ‚Ä¢ Store size: %s\n", format.Bytes(result.TotalBytes))

        if cleanableCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nüí° You can clean up %d old generations to free space\n", cleanableCount)
                fmt.Printf("   üèÉ Run 'clean-wizard clean' to start cleanup\n")
                fmt.Printf("   üîç Try 'clean-wizard clean --dry-run' first to see what would be cleaned\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n‚úÖ System is already clean - no old generations found\n")
        }</span>

        // Add completion message for BDD tests
        <span class="cov0" title="0">fmt.Printf("\n‚úÖ Scan completed!\n")</span>
}
</pre>

      <pre class="file" id="file7" style="display: none">package commands

import (
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/config"
)

// ParseValidationLevel converts string to ValidationLevel
func ParseValidationLevel(level string) config.ValidationLevel <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "none":<span class="cov0" title="0">
                return config.ValidationLevelNone</span>
        case "basic":<span class="cov0" title="0">
                return config.ValidationLevelBasic</span>
        case "comprehensive":<span class="cov0" title="0">
                return config.ValidationLevelComprehensive</span>
        case "strict":<span class="cov0" title="0">
                return config.ValidationLevelStrict</span>
        default:<span class="cov0" title="0">
                return config.ValidationLevelBasic</span> // Safe default
        }
}
</pre>

      <pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "os"
        "strings"

        "github.com/LarsArtmann/clean-wizard/cmd/clean-wizard/commands"
        "github.com/LarsArtmann/clean-wizard/internal/config"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "github.com/sirupsen/logrus"
)

var (
        version         = "dev"
        verbose         bool
        dryRun          bool
        force           bool
        profileName     string
        validationLevel string
)

// colorize adds color to output based on type
func colorize(text, color string) string <span class="cov0" title="0">{
        colors := map[string]string{
                "red":    "\033[31m",
                "green":  "\033[32m",
                "yellow": "\033[33m",
                "blue":   "\033[34m",
                "purple": "\033[35m",
                "cyan":   "\033[36m",
                "reset":  "\033[0m",
        }

        if !strings.Contains(os.Getenv("NO_COLOR"), "1") </span><span class="cov0" title="0">{
                return colors[color] + text + colors["reset"]
        }</span>
        <span class="cov0" title="0">return text</span>
}

// parseValidationLevel converts string to ValidationLevel
func parseValidationLevel(level string) config.ValidationLevel <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "none":<span class="cov0" title="0">
                return config.ValidationLevelNone</span>
        case "basic":<span class="cov0" title="0">
                return config.ValidationLevelBasic</span>
        case "comprehensive":<span class="cov0" title="0">
                return config.ValidationLevelComprehensive</span>
        case "strict":<span class="cov0" title="0">
                return config.ValidationLevelStrict</span>
        default:<span class="cov0" title="0">
                return config.ValidationLevelBasic</span> // Safe default
        }
}

func init() <span class="cov0" title="0">{
        // Configure zerolog with colorful output
        log.Logger = log.Output(
                zerolog.ConsoleWriter{
                        Out:        os.Stderr,
                        NoColor:    false,
                        TimeFormat: "2006-01-02 15:04:05",
                },
        ).With().Timestamp().Caller().Logger()

        // Set global log level based on verbosity
        if verbose </span><span class="cov0" title="0">{
                zerolog.SetGlobalLevel(zerolog.DebugLevel)
        }</span> else<span class="cov0" title="0"> {
                zerolog.SetGlobalLevel(zerolog.InfoLevel)
        }</span>

        // Enable debug logging for configuration loading
        <span class="cov0" title="0">logrus.SetLevel(logrus.DebugLevel)</span>
}

func main() <span class="cov0" title="0">{
        rootCmd := commands.NewRootCmd()

        // Add global flags
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")
        rootCmd.PersistentFlags().BoolVar(&amp;dryRun, "dry-run", false, "Show what would be deleted without actually deleting")
        rootCmd.PersistentFlags().BoolVar(&amp;force, "force", false, "Force cleanup without confirmation")
        rootCmd.PersistentFlags().StringVar(&amp;profileName, "profile", "daily", "Configuration profile to use")
        rootCmd.PersistentFlags().StringVar(&amp;validationLevel, "validation-level", "basic", "Validation level: none, basic, comprehensive, strict")

        // Add subcommands
        rootCmd.AddCommand(
                commands.NewProfileCommand(),
                commands.NewScanCommand(verbose, parseValidationLevel(validationLevel)),
                commands.NewCleanCommand(parseValidationLevel(validationLevel)),
                commands.NewGenerateCommand(),
        )

        // Handle command execution with proper error handling
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // Log fatal errors with context
                if verbose </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg(colorize("Command execution failed", "red"))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(colorize(fmt.Sprintf("‚ùå Error: %s", err), "red"))
                        os.Exit(1)
                }</span>
        }
}
</pre>

      <pre class="file" id="file9" style="display: none">package adapters

import (
        "time"

        "github.com/patrickmn/go-cache"
)

// CacheManager provides in-memory caching functionality
type CacheManager struct {
        cache *cache.Cache
}

// NewCacheManager creates a new cache manager
// defaultExpiration: default TTL for cache entries
// cleanupInterval: interval for cleaning expired entries
func NewCacheManager(defaultExpiration, cleanupInterval time.Duration) *CacheManager <span class="cov7" title="3">{
        return &amp;CacheManager{
                cache: cache.New(defaultExpiration, cleanupInterval),
        }
}</span>

// Set stores a value in cache with expiration
func (cm *CacheManager) Set(key string, value any, expiration time.Duration) <span class="cov10" title="5">{
        cm.cache.Set(key, value, expiration)
}</span>

// Get retrieves a value from cache
func (cm *CacheManager) Get(key string) (any, bool) <span class="cov10" title="5">{
        return cm.cache.Get(key)
}</span>

// GetWithExpiration retrieves a value with its expiration time
func (cm *CacheManager) GetWithExpiration(key string) (any, time.Time, bool) <span class="cov0" title="0">{
        return cm.cache.GetWithExpiration(key)
}</span>

// Delete removes an item from cache
func (cm *CacheManager) Delete(key string) <span class="cov1" title="1">{
        cm.cache.Delete(key)
}</span>

// Clear removes all items from cache
func (cm *CacheManager) Clear() <span class="cov1" title="1">{
        cm.cache.Flush()
}</span>

// ItemCount returns the number of items in cache
func (cm *CacheManager) ItemCount() int <span class="cov8" title="4">{
        return cm.cache.ItemCount()
}</span>

// CacheStats provides cache statistics
type CacheStats struct {
        Items     int     `json:"items"`
        HitCount  uint64  `json:"hit_count"`
        MissCount uint64  `json:"miss_count"`
        HitRate   float64 `json:"hit_rate"`
}

// Stats returns cache performance statistics
func (cm *CacheManager) Stats() CacheStats <span class="cov0" title="0">{
        // Note: go-cache doesn't provide hit/miss counts by default
        // In production, we'd wrap with instrumentation
        return CacheStats{
                Items: cm.cache.ItemCount(),
        }
}</span>

// Keys returns all keys in the cache
func (cm *CacheManager) Keys() []string <span class="cov0" title="0">{
        items := cm.cache.Items()
        keys := make([]string, 0, len(items))
        for k := range items </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// SetDefault sets the default expiration for new items
func (cm *CacheManager) SetDefault(expiration time.Duration) {<span class="cov0" title="0">
        // go-cache doesn't support setting default after creation
        // This is a no-op but maintains interface compatibility
}</span>

// FlushExpired removes all expired items
func (cm *CacheManager) FlushExpired() <span class="cov0" title="0">{
        for key, item := range cm.cache.Items() </span><span class="cov0" title="0">{
                if item.Expired() </span><span class="cov0" title="0">{
                        cm.cache.Delete(key)
                }</span>
        }
}
</pre>

      <pre class="file" id="file10" style="display: none">package adapters

import (
        "os"
        "strconv"
        "time"

        "github.com/caarlos0/env/v6"
)

// EnvironmentConfig holds environment-based configuration
type EnvironmentConfig struct {
        // Application settings
        Debug       bool   `env:"DEBUG" envDefault:"false"`
        Environment string `env:"ENV" envDefault:"development"`
        LogLevel    string `env:"LOG_LEVEL" envDefault:"info"`
        Version     string `env:"VERSION" envDefault:"dev"`

        // Performance settings
        MaxConcurrency int           `env:"MAX_CONCURRENCY" envDefault:"4"`
        Timeout        time.Duration `env:"TIMEOUT" envDefault:"30s"`
        RateLimitRPS   float64       `env:"RATE_LIMIT_RPS" envDefault:"10"`

        // Cache settings
        CacheEnabled         bool          `env:"CACHE_ENABLED" envDefault:"true"`
        CacheTTL             time.Duration `env:"CACHE_TTL" envDefault:"5m"`
        CacheCleanupInterval time.Duration `env:"CACHE_CLEANUP_INTERVAL" envDefault:"10m"`

        // HTTP client settings
        HTTPTimeout       time.Duration `env:"HTTP_TIMEOUT" envDefault:"30s"`
        HTTPRetryCount    int           `env:"HTTP_RETRY_COUNT" envDefault:"3"`
        HTTPRetryWaitTime time.Duration `env:"HTTP_RETRY_WAIT_TIME" envDefault:"1s"`
        HTTPRetryMaxWait  time.Duration `env:"HTTP_RETRY_MAX_WAIT" envDefault:"10s"`

        // Nix settings
        NixPath               string `env:"NIX_PATH" envDefault:"/nix/var/nix"`
        MaxNixGenerations     int    `env:"MAX_NIX_GENERATIONS" envDefault:"10"`
        DefaultNixGenerations int    `env:"DEFAULT_NIX_GENERATIONS" envDefault:"3"`
        NixStoreSizeGB        int    `env:"NIX_STORE_SIZE_GB" envDefault:"300"`

        // Disk settings
        MaxDiskUsagePercent int `env:"MAX_DISK_USAGE_PERCENT" envDefault:"50"`
        MinDiskUsagePercent int `env:"MIN_DISK_USAGE_PERCENT" envDefault:"10"`
        RoundingIncrement   int `env:"ROUNDING_INCREMENT" envDefault:"10"`

        // Security settings
        SafeMode            bool `env:"SAFE_MODE" envDefault:"true"`
        RequireConfirmation bool `env:"REQUIRE_CONFIRMATION" envDefault:"true"`

        // Filesystem settings
        TempDir        string `env:"TEMP_DIR" envDefault:"/tmp"`
        ConfigFile     string `env:"CONFIG_FILE" envDefault:"clean-wizard.yaml"`
        StateDirectory string `env:"STATE_DIRECTORY" envDefault:"~/.clean-wizard"`

        // Monitoring settings
        MetricsEnabled  bool   `env:"METRICS_ENABLED" envDefault:"false"`
        MetricsPort     int    `env:"METRICS_PORT" envDefault:"8080"`
        MetricsPath     string `env:"METRICS_PATH" envDefault:"/metrics"`
        TracingEnabled  bool   `env:"TRACING_ENABLED" envDefault:"false"`
        TracingEndpoint string `env:"TRACING_ENDPOINT" envDefault:""`
}

// LoadEnvironmentConfig loads configuration from environment variables
func LoadEnvironmentConfig() (*EnvironmentConfig, error) <span class="cov10" title="2">{
        cfg := &amp;EnvironmentConfig{}

        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">return cfg, nil</span>
}

// LoadEnvironmentConfigWithPrefix loads configuration with custom prefix
func LoadEnvironmentConfigWithPrefix(prefix string) (*EnvironmentConfig, error) <span class="cov0" title="0">{
        cfg := &amp;EnvironmentConfig{}

        if err := env.Parse(cfg, env.Options{
                Prefix: prefix,
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// GetEnvWithDefault returns environment variable with default value
func GetEnvWithDefault(key, defaultValue string) string <span class="cov1" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov1" title="1">return defaultValue</span>
}

// GetEnvBool returns boolean environment variable with default
func GetEnvBool(key string, defaultValue bool) bool <span class="cov1" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov1" title="1">return defaultValue</span>
}

// GetEnvInt returns integer environment variable with default
func GetEnvInt(key string, defaultValue int) int <span class="cov1" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov1" title="1">return defaultValue</span>
}

// GetEnvDuration returns duration environment variable with default
func GetEnvDuration(key string, defaultValue time.Duration) time.Duration <span class="cov1" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                if parsed, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov1" title="1">return defaultValue</span>
}

// ValidateEnvironmentConfig validates the loaded configuration
func (cfg *EnvironmentConfig) ValidateEnvironmentConfig() error <span class="cov1" title="1">{
        if cfg.MaxConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidConfig("max_concurrency must be positive")
        }</span>

        <span class="cov1" title="1">if cfg.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidConfig("timeout must be positive")
        }</span>

        <span class="cov1" title="1">if cfg.RateLimitRPS &lt;= 0 </span><span class="cov0" title="0">{
                return ErrInvalidConfig("rate_limit_rps must be positive")
        }</span>

        <span class="cov1" title="1">if cfg.MaxNixGenerations &lt;= 0 || cfg.MaxNixGenerations &gt; 1000 </span><span class="cov0" title="0">{
                return ErrInvalidConfig("max_nix_generations must be between 1 and 1000")
        }</span>

        <span class="cov1" title="1">if cfg.MaxDiskUsagePercent &lt; 10 || cfg.MaxDiskUsagePercent &gt; 95 </span><span class="cov0" title="0">{
                return ErrInvalidConfig("max_disk_usage_percent must be between 10 and 95")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// EnvironmentConfigView provides strongly-typed config representation for logging/debugging
type EnvironmentConfigView struct {
        Debug               bool          `json:"debug"`
        Environment         string        `json:"environment"`
        LogLevel            string        `json:"log_level"`
        Version             string        `json:"version"`
        MaxConcurrency      int           `json:"max_concurrency"`
        Timeout             time.Duration `json:"timeout"`
        RateLimitRPS        float64       `json:"rate_limit_rps"`
        CacheEnabled        bool          `json:"cache_enabled"`
        CacheTTL            time.Duration `json:"cache_ttl"`
        HTTPTimeout         time.Duration `json:"http_timeout"`
        NixPath             string        `json:"nix_path"`
        MaxNixGenerations   int           `json:"max_nix_generations"`
        SafeMode            bool          `json:"safe_mode"`
        RequireConfirmation bool          `json:"require_confirmation"`
        TempDir             string        `json:"temp_dir"`
        ConfigFile          string        `json:"config_file"`
        StateDirectory      string        `json:"state_directory"`
}

// ToView converts config to strongly-typed view for logging/debugging
func (cfg *EnvironmentConfig) ToView() EnvironmentConfigView <span class="cov0" title="0">{
        return EnvironmentConfigView{
                Debug:               cfg.Debug,
                Environment:         cfg.Environment,
                LogLevel:            cfg.LogLevel,
                Version:             cfg.Version,
                MaxConcurrency:      cfg.MaxConcurrency,
                Timeout:             cfg.Timeout,
                RateLimitRPS:        cfg.RateLimitRPS,
                CacheEnabled:        cfg.CacheEnabled,
                CacheTTL:            cfg.CacheTTL,
                HTTPTimeout:         cfg.HTTPTimeout,
                NixPath:             cfg.NixPath,
                MaxNixGenerations:   cfg.MaxNixGenerations,
                SafeMode:            cfg.SafeMode,
                RequireConfirmation: cfg.RequireConfirmation,
                TempDir:             cfg.TempDir,
                ConfigFile:          cfg.ConfigFile,
                StateDirectory:      cfg.StateDirectory,
        }
}</span>

// ToMap converts config to map for legacy compatibility (deprecated)
func (cfg *EnvironmentConfig) ToMap() map[string]any <span class="cov0" title="0">{
        view := cfg.ToView()
        return map[string]any{
                "debug":                view.Debug,
                "environment":          view.Environment,
                "log_level":            view.LogLevel,
                "version":              view.Version,
                "max_concurrency":      view.MaxConcurrency,
                "timeout":              view.Timeout.String(),
                "rate_limit_rps":       view.RateLimitRPS,
                "cache_enabled":        view.CacheEnabled,
                "cache_ttl":            view.CacheTTL.String(),
                "http_timeout":         view.HTTPTimeout.String(),
                "nix_path":             view.NixPath,
                "max_nix_generations":  view.MaxNixGenerations,
                "safe_mode":            view.SafeMode,
                "require_confirmation": view.RequireConfirmation,
                "temp_dir":             view.TempDir,
                "config_file":          view.ConfigFile,
                "state_directory":      view.StateDirectory,
        }
}</span>
</pre>

      <pre class="file" id="file11" style="display: none">package adapters

import (
        "fmt"
)

// ErrInvalidConfig creates a configuration validation error
func ErrInvalidConfig(message string) error <span class="cov8" title="1">{
        return fmt.Errorf("configuration error: %s", message)
}</span>

// ErrInvalidArgument creates an argument validation error
func ErrInvalidArgument(arg, message string) error <span class="cov8" title="1">{
        return fmt.Errorf("invalid argument '%s': %s", arg, message)
}</span>

// ErrNotFound creates a not found error
func ErrNotFound(resource string) error <span class="cov8" title="1">{
        return fmt.Errorf("resource not found: %s", resource)
}</span>

// ErrTimeout creates a timeout error
func ErrTimeout(operation string) error <span class="cov8" title="1">{
        return fmt.Errorf("operation timeout: %s", operation)
}</span>

// ErrRateLimit creates a rate limit error
func ErrRateLimit(limit float64) error <span class="cov8" title="1">{
        return fmt.Errorf("rate limit exceeded: %.2f requests/second", limit)
}</span>

// ErrCacheMiss creates a cache miss error
func ErrCacheMiss(key string) error <span class="cov8" title="1">{
        return fmt.Errorf("cache miss: key '%s' not found", key)
}</span>

// ErrHTTPError creates an HTTP error
func ErrHTTPError(statusCode int, message string) error <span class="cov0" title="0">{
        return fmt.Errorf("HTTP error %d: %s", statusCode, message)
}</span>

// ErrNotImplemented creates a not implemented error
func ErrNotImplemented(feature string) error <span class="cov8" title="1">{
        return fmt.Errorf("feature not implemented: %s", feature)
}</span>

// ErrUnauthorized creates an unauthorized error
func ErrUnauthorized(operation string) error <span class="cov8" title="1">{
        return fmt.Errorf("unauthorized: %s", operation)
}</span>

// ErrForbidden creates a forbidden error
func ErrForbidden(operation string) error <span class="cov8" title="1">{
        return fmt.Errorf("forbidden: %s", operation)
}</span>

// ErrServiceUnavailable creates a service unavailable error
func ErrServiceUnavailable(service string) error <span class="cov8" title="1">{
        return fmt.Errorf("service unavailable: %s", service)
}</span>
</pre>

      <pre class="file" id="file12" style="display: none">package adapters

import (
        "context"
        "time"

        "github.com/go-resty/resty/v2"
)

// HTTPClient provides a modern HTTP client with built-in features
type HTTPClient struct {
        client *resty.Client
}

// NewHTTPClient creates a new HTTP client with sensible defaults
func NewHTTPClient() *HTTPClient <span class="cov8" title="1">{
        client := resty.New()

        // Set sensible defaults
        client.
                SetTimeout(30*time.Second).
                SetRetryCount(3).
                SetRetryWaitTime(1*time.Second).
                SetRetryMaxWaitTime(10*time.Second).
                SetHeader("User-Agent", "clean-wizard/1.0.0")

        return &amp;HTTPClient{
                client: client,
        }
}</span>

// WithTimeout sets the request timeout
func (hc *HTTPClient) WithTimeout(timeout time.Duration) *HTTPClient <span class="cov8" title="1">{
        hc.client.SetTimeout(timeout)
        return hc
}</span>

// WithRetry configures retry behavior
func (hc *HTTPClient) WithRetry(count int, waitTime, maxWaitTime time.Duration) *HTTPClient <span class="cov8" title="1">{
        hc.client.SetRetryCount(count).
                SetRetryWaitTime(waitTime).
                SetRetryMaxWaitTime(maxWaitTime)
        return hc
}</span>

// WithAuth sets authentication header
func (hc *HTTPClient) WithAuth(authType, token string) *HTTPClient <span class="cov8" title="1">{
        hc.client.SetAuthToken(token)
        if authType == "Bearer" </span><span class="cov8" title="1">{
                hc.client.SetAuthToken("Bearer " + token)
        }</span>
        <span class="cov8" title="1">return hc</span>
}

// WithHeader adds a default header
func (hc *HTTPClient) WithHeader(key, value string) *HTTPClient <span class="cov8" title="1">{
        hc.client.SetHeader(key, value)
        return hc
}</span>

// Get performs HTTP GET request
func (hc *HTTPClient) Get(ctx context.Context, url string) (*HTTPResponse, error) <span class="cov0" title="0">{
        resp, err := hc.client.R().SetContext(ctx).Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;HTTPResponse{
                StatusCode: resp.StatusCode(),
                Body:       string(resp.Body()),
                Headers:    resp.Header(),
                Request:    resp.Request,
        }, nil</span>
}

// Post performs HTTP POST request
func (hc *HTTPClient) Post(ctx context.Context, url string, body any) (*HTTPResponse, error) <span class="cov0" title="0">{
        resp, err := hc.client.R().SetBody(body).SetContext(ctx).Post(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;HTTPResponse{
                StatusCode: resp.StatusCode(),
                Body:       string(resp.Body()),
                Headers:    resp.Header(),
                Request:    resp.Request,
        }, nil</span>
}

// Put performs HTTP PUT request
func (hc *HTTPClient) Put(ctx context.Context, url string, body any) (*HTTPResponse, error) <span class="cov0" title="0">{
        resp, err := hc.client.R().SetBody(body).SetContext(ctx).Put(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;HTTPResponse{
                StatusCode: resp.StatusCode(),
                Body:       string(resp.Body()),
                Headers:    resp.Header(),
                Request:    resp.Request,
        }, nil</span>
}

// Delete performs HTTP DELETE request
func (hc *HTTPClient) Delete(ctx context.Context, url string) (*HTTPResponse, error) <span class="cov0" title="0">{
        resp, err := hc.client.R().SetContext(ctx).Delete(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;HTTPResponse{
                StatusCode: resp.StatusCode(),
                Body:       string(resp.Body()),
                Headers:    resp.Header(),
                Request:    resp.Request,
        }, nil</span>
}

// HTTPResponse wraps resty response
type HTTPResponse struct {
        StatusCode int                 `json:"status_code"`
        Body       string              `json:"body"`
        Headers    map[string][]string `json:"headers"`
        Request    *resty.Request      `json:"request"`
}

// IsSuccess returns true if status code indicates success (2xx)
func (hr *HTTPResponse) IsSuccess() bool <span class="cov0" title="0">{
        return hr.StatusCode &gt;= 200 &amp;&amp; hr.StatusCode &lt; 300
}</span>

// IsError returns true if status code indicates error (4xx, 5xx)
func (hr *HTTPResponse) IsError() bool <span class="cov0" title="0">{
        return hr.StatusCode &gt;= 400
}</span>

// IsClientError returns true if status code indicates client error (4xx)
func (hr *HTTPResponse) IsClientError() bool <span class="cov0" title="0">{
        return hr.StatusCode &gt;= 400 &amp;&amp; hr.StatusCode &lt; 500
}</span>

// IsServerError returns true if status code indicates server error (5xx)
func (hr *HTTPResponse) IsServerError() bool <span class="cov0" title="0">{
        return hr.StatusCode &gt;= 500
}</span>
</pre>

      <pre class="file" id="file13" style="display: none">package adapters

import (
        "context"
        "fmt"
        "os/exec"
        "strconv"
        "strings"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/conversions"
        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/result"
)

// NixAdapter wraps Nix package manager operations
type NixAdapter struct {
        timeout time.Duration
        retries int
        dryRun  bool
}

// NewNixAdapter creates Nix adapter with configuration
func NewNixAdapter(timeout time.Duration, retries int) *NixAdapter <span class="cov0" title="0">{
        return &amp;NixAdapter{
                timeout: timeout,
                retries: retries,
        }
}</span>

// SetDryRun configures dry-run mode for the adapter
func (n *NixAdapter) SetDryRun(dryRun bool) <span class="cov0" title="0">{
        n.dryRun = dryRun
}</span>

// ListGenerations lists Nix generations with dry-run isolation
func (n *NixAdapter) ListGenerations(ctx context.Context) result.Result[[]domain.NixGeneration] <span class="cov0" title="0">{
        if !n.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return result.Err[[]domain.NixGeneration](fmt.Errorf("nix not available"))
        }</span>

        // If dry-run, return mock data without system calls
        <span class="cov0" title="0">if n.dryRun </span><span class="cov0" title="0">{
                return result.Ok([]domain.NixGeneration{
                        {ID: 300, Path: "/nix/var/nix/profiles/default-300-link", Date: time.Now().Add(-24 * time.Hour), Current: true},
                        {ID: 299, Path: "/nix/var/nix/profiles/default-299-link", Date: time.Now().Add(-48 * time.Hour), Current: false},
                        {ID: 298, Path: "/nix/var/nix/profiles/default-298-link", Date: time.Now().Add(-72 * time.Hour), Current: false},
                        {ID: 297, Path: "/nix/var/nix/profiles/default-297-link", Date: time.Now().Add(-96 * time.Hour), Current: false},
                        {ID: 296, Path: "/nix/var/nix/profiles/default-296-link", Date: time.Now().Add(-120 * time.Hour), Current: false},
                })
        }</span>

        // Real system call for production mode
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "nix-env", "--list-generations", "--profile", "/nix/var/nix/profiles/default")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return result.Err[[]domain.NixGeneration](fmt.Errorf("failed to list generations: %w", err))
        }</span>

        <span class="cov0" title="0">var generations []domain.NixGeneration
        lines := strings.SplitSeq(string(output), "\n")

        for line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gen, err := n.ParseGeneration(line)
                if err != nil </span><span class="cov0" title="0">{
                        return result.Err[[]domain.NixGeneration](fmt.Errorf("failed to parse generation: %w", err))
                }</span>

                <span class="cov0" title="0">generations = append(generations, gen)</span>
        }

        <span class="cov0" title="0">return result.Ok(generations)</span>
}

// GetStoreSize returns Nix store size with dry-run isolation
func (n *NixAdapter) GetStoreSize(ctx context.Context) result.Result[int64] <span class="cov0" title="0">{
        // If dry-run, return estimated size without system calls
        if n.dryRun </span><span class="cov0" title="0">{
                return result.Ok(int64(50 * 1024 * 1024 * 1024)) // 50GB estimate
        }</span>

        // Real system call for production mode
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "du", "-sb", "/nix/store")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return result.Err[int64](fmt.Errorf("failed to get store size: %w", err))
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(string(output))
        if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                return result.Err[int64](fmt.Errorf("invalid du output: %s", string(output)))
        }</span>

        <span class="cov0" title="0">size, err := strconv.ParseInt(fields[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return result.Err[int64](fmt.Errorf("failed to parse size: %w", err))
        }</span>

        <span class="cov0" title="0">return result.Ok(size)</span>
}

// CollectGarbage removes old Nix generations using centralized conversion
func (n *NixAdapter) CollectGarbage(ctx context.Context) result.Result[domain.CleanResult] <span class="cov0" title="0">{
        // Get store size before garbage collection
        beforeSize, err := n.getActualStoreSize(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to get pre-gc store size: %w", err))
        }</span>

        // Run actual nix-collect-garbage command
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "nix-collect-garbage", "-d")
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to collect garbage: %w", err))
        }</span>

        // Get store size after garbage collection
        <span class="cov0" title="0">afterSize, err := n.getActualStoreSize(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to get post-gc store size: %w", err))
        }</span>

        <span class="cov0" title="0">bytesFreed := max(beforeSize-afterSize,
                // Shouldn't happen but guard against it
                0)

        // Use centralized conversion with proper timing
        cleanResult := conversions.NewCleanResultWithTiming(domain.StrategyAggressive, 1, bytesFreed, time.Since(time.Now()))
        return result.Ok(cleanResult)</span>
}

// getActualStoreSize helper function to get real store size
func (n *NixAdapter) getActualStoreSize(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "du", "-sb", "/nix/store")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">fields := strings.Fields(string(output))
        if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid du output: %s", string(output))
        }</span>

        <span class="cov0" title="0">return strconv.ParseInt(fields[0], 10, 64)</span>
}

// RemoveGeneration removes specific Nix generation using centralized conversion
func (n *NixAdapter) RemoveGeneration(ctx context.Context, genID int) result.Result[domain.CleanResult] <span class="cov0" title="0">{
        // Get store size before removal
        beforeSize, err := n.getActualStoreSize(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to get pre-remove store size: %w", err))
        }</span>

        // Remove the specific generation
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "nix-env", "--delete-generations", fmt.Sprintf("%d", genID))
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to remove generation %d: %w", genID, err))
        }</span>

        // Get store size after removal
        <span class="cov0" title="0">afterSize, err := n.getActualStoreSize(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(fmt.Errorf("failed to get post-remove store size: %w", err))
        }</span>

        <span class="cov0" title="0">bytesFreed := max(beforeSize-afterSize,
                // Guard against negative values
                0)

        // Use centralized conversion with proper timing
        cleanResult := conversions.NewCleanResultWithTiming(domain.StrategyConservative, 1, bytesFreed, time.Since(time.Now()))
        return result.Ok(cleanResult)</span>
}

// ParseGeneration parses generation line from nix-env output
func (n *NixAdapter) ParseGeneration(line string) (domain.NixGeneration, error) <span class="cov0" title="0">{
        fields := strings.Fields(line)
        if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                return domain.NixGeneration{}, fmt.Errorf("invalid generation line: %s", line)
        }</span>

        <span class="cov0" title="0">pathParts := strings.Split(fields[0], "-")
        if len(pathParts) &lt; 2 </span><span class="cov0" title="0">{
                return domain.NixGeneration{}, fmt.Errorf("invalid generation path: %s", fields[0])
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(pathParts[len(pathParts)-1])
        if err != nil </span><span class="cov0" title="0">{
                return domain.NixGeneration{}, fmt.Errorf("invalid generation ID: %s", pathParts[len(pathParts)-1])
        }</span>

        // Simple date parsing
        <span class="cov0" title="0">date := time.Now()
        if len(fields) &gt; 1 &amp;&amp; strings.Contains(fields[1], "-") </span><span class="cov0" title="0">{
                parts := strings.Split(fields[1], "-")
                if len(parts) == 3 </span><span class="cov0" title="0">{
                        if parsed, err := time.Parse("2006-01-02", strings.Join(parts, "-")); err == nil </span><span class="cov0" title="0">{
                                date = parsed
                        }</span>
                }
        }

        <span class="cov0" title="0">return domain.NixGeneration{
                ID:      id,
                Path:    fields[0],
                Date:    date,
                Current: strings.Contains(line, "current"),
        }, nil</span>
}

// IsAvailable checks if Nix is available and accessible
func (n *NixAdapter) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        // First check if nix command exists
        versionCmd := exec.CommandContext(ctx, "nix", "--version")
        if err := versionCmd.Run(); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Then check if we can access profiles (the actual operation we need)
        <span class="cov0" title="0">listCmd := exec.CommandContext(ctx, "nix-env", "--list-generations", "--profile", "/nix/var/nix/profiles/default")
        err := listCmd.Run()
        return err == nil</span>
}
</pre>

      <pre class="file" id="file14" style="display: none">package adapters

import (
        "context"

        "golang.org/x/time/rate"
)

// RateLimiter provides rate limiting functionality for cleaning operations
type RateLimiter struct {
        limiter *rate.Limiter
}

// NewRateLimiter creates a new rate limiter
// rps: requests per second limit
// burst: maximum burst size
func NewRateLimiter(rps float64, burst int) *RateLimiter <span class="cov10" title="3">{
        return &amp;RateLimiter{
                limiter: rate.NewLimiter(rate.Limit(rps), burst),
        }
}</span>

// Wait blocks until the operation is allowed or context is cancelled
func (rl *RateLimiter) Wait(ctx context.Context) error <span class="cov1" title="1">{
        return rl.limiter.Wait(ctx)
}</span>

// Allow returns true if the operation is allowed immediately
func (rl *RateLimiter) Allow() bool <span class="cov6" title="2">{
        return rl.limiter.Allow()
}</span>

// Reservation returns a reservation for a future operation
func (rl *RateLimiter) Reservation() *rate.Reservation <span class="cov0" title="0">{
        return rl.limiter.Reserve()
}</span>

// RateLimitStats provides rate limiting statistics
type RateLimitStats struct {
        Limit  rate.Limit `json:"limit"`
        Burst  int        `json:"burst"`
        Tokens float64    `json:"tokens"`
}

// Stats returns current rate limiter statistics
func (rl *RateLimiter) Stats() RateLimitStats <span class="cov1" title="1">{
        return RateLimitStats{
                Limit:  rl.limiter.Limit(),
                Burst:  rl.limiter.Burst(),
                Tokens: rl.limiter.Tokens(),
        }
}</span>
</pre>

      <pre class="file" id="file15" style="display: none">package api

import (
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/result"
)

// === MAPPING LAYER: API ‚Üî DOMAIN TYPES ===
// Converts between public API types and internal domain models

// MapConfigToDomain converts public API config to internal domain model
func MapConfigToDomain(publicConfig *PublicConfig) result.Result[*domain.Config] <span class="cov1" title="1">{
        if publicConfig == nil </span><span class="cov0" title="0">{
                return result.Err[*domain.Config](fmt.Errorf("public config cannot be nil"))
        }</span>

        // Map profiles
        <span class="cov1" title="1">profiles := make(map[string]*domain.Profile, len(publicConfig.Profiles))
        for name, publicProfile := range publicConfig.Profiles </span><span class="cov1" title="1">{
                domainProfile, err := MapProfileToDomain(publicProfile)
                if err != nil </span><span class="cov0" title="0">{
                        return result.Err[*domain.Config](fmt.Errorf("failed to map profile %s: %w", name, err))
                }</span>
                <span class="cov1" title="1">profiles[name] = domainProfile</span>
        }

        // Create domain config
        <span class="cov1" title="1">config := &amp;domain.Config{
                Version:      publicConfig.Version,
                SafeMode:     publicConfig.SafeMode,
                MaxDiskUsage: int(publicConfig.MaxDiskUsage),
                Protected:    publicConfig.ProtectedPaths,
                Profiles:     profiles,
        }

        // Validate domain config
        if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return result.Err[*domain.Config](fmt.Errorf("domain config validation failed: %w", err))
        }</span>

        <span class="cov1" title="1">return result.Ok(config)</span>
}

// MapConfigToPublic converts internal domain config to public API type
func MapConfigToPublic(domainConfig *domain.Config) result.Result[*PublicConfig] <span class="cov1" title="1">{
        if domainConfig == nil </span><span class="cov0" title="0">{
                return result.Err[*PublicConfig](fmt.Errorf("domain config cannot be nil"))
        }</span>

        // Map profiles
        <span class="cov1" title="1">publicProfiles := make(map[string]*PublicProfile, len(domainConfig.Profiles))
        for name, domainProfile := range domainConfig.Profiles </span><span class="cov1" title="1">{
                publicProfile := MapProfileToPublic(domainProfile)
                publicProfiles[name] = publicProfile
        }</span>

        <span class="cov1" title="1">publicConfig := &amp;PublicConfig{
                Version:        domainConfig.Version,
                SafeMode:       domainConfig.SafeMode,
                MaxDiskUsage:   int32(domainConfig.MaxDiskUsage),
                ProtectedPaths: domainConfig.Protected,
                Profiles:       publicProfiles,
        }

        return result.Ok(publicConfig)</span>
}

// MapProfileToDomain converts public API profile to domain model
func MapProfileToDomain(publicProfile *PublicProfile) (*domain.Profile, error) <span class="cov1" title="1">{
        if publicProfile == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public profile cannot be nil")
        }</span>

        // Map operations
        <span class="cov1" title="1">operations := make([]domain.CleanupOperation, len(publicProfile.Operations))
        for i, publicOp := range publicProfile.Operations </span><span class="cov1" title="1">{
                domainOp, err := MapOperationToDomain(&amp;publicOp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to map operation %d: %w", i, err)
                }</span>
                <span class="cov1" title="1">operations[i] = *domainOp</span>
        }

        <span class="cov1" title="1">return &amp;domain.Profile{
                Name:        publicProfile.Name,
                Description: publicProfile.Description,
                Enabled:     publicProfile.Enabled,
                Operations:  operations,
        }, nil</span>
}

// MapProfileToPublic converts domain profile to public API type
func MapProfileToPublic(domainProfile *domain.Profile) *PublicProfile <span class="cov1" title="1">{
        if domainProfile == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Map operations
        <span class="cov1" title="1">publicOperations := make([]PublicOperation, len(domainProfile.Operations))
        for i, domainOp := range domainProfile.Operations </span><span class="cov1" title="1">{
                publicOperations[i] = *MapOperationToPublic(&amp;domainOp)
        }</span>

        <span class="cov1" title="1">return &amp;PublicProfile{
                Name:        domainProfile.Name,
                Description: domainProfile.Description,
                Enabled:     domainProfile.Enabled,
                Operations:  publicOperations,
        }</span>
}

// MapOperationToDomain converts public API operation to domain model
func MapOperationToDomain(publicOperation *PublicOperation) (*domain.CleanupOperation, error) <span class="cov1" title="1">{
        if publicOperation == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("public operation cannot be nil")
        }</span>

        // Map risk level
        <span class="cov1" title="1">riskLevel, err := MapRiskLevelToDomain(publicOperation.RiskLevel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid risk level: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;domain.CleanupOperation{
                Name:        publicOperation.Name,
                Description: publicOperation.Description,
                RiskLevel:   riskLevel,
                Enabled:     publicOperation.Enabled,
                Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations), // Simplified for PoC
        }, nil</span>
}

// MapOperationToPublic converts domain operation to public API type
func MapOperationToPublic(domainOperation *domain.CleanupOperation) *PublicOperation <span class="cov1" title="1">{
        if domainOperation == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Map complex operation settings to simplified public API settings
        <span class="cov1" title="1">publicSettings := MapOperationSettingsToPublic(domainOperation.Settings)

        return &amp;PublicOperation{
                Name:        domainOperation.Name,
                Description: domainOperation.Description,
                RiskLevel:   MapRiskLevelToPublic(domainOperation.RiskLevel),
                Enabled:     domainOperation.Enabled,
                Settings:    publicSettings,
        }</span>
}

// MapOperationSettingsToPublic converts complex domain settings to simplified public API settings
func MapOperationSettingsToPublic(settings *domain.OperationSettings) OperationSettings <span class="cov1" title="1">{
        // Default values for simplified public API
        publicSettings := OperationSettings{
                DryRun:              true, // Safe default
                Verbose:             false,
                TimeoutSeconds:      300, // 5 minutes
                ConfirmBeforeDelete: false,
        }

        // Extract relevant values from domain-specific settings
        if settings.NixGenerations != nil </span><span class="cov1" title="1">{
                publicSettings.DryRun = false // Nix operations default to false
                if settings.NixGenerations.Optimize </span><span class="cov0" title="0">{
                        publicSettings.Verbose = true
                }</span>
        }

        <span class="cov1" title="1">return publicSettings</span>
}

// MapRiskLevelToDomain converts public risk level string to domain enum
func MapRiskLevelToDomain(publicRisk PublicRiskLevel) (domain.RiskLevelType, error) <span class="cov10" title="5">{
        switch publicRisk </span>{
        case PublicRiskLow:<span class="cov4" title="2">
                return domain.RiskLow, nil</span>
        case PublicRiskMedium:<span class="cov1" title="1">
                return domain.RiskMedium, nil</span>
        case PublicRiskHigh:<span class="cov1" title="1">
                return domain.RiskHigh, nil</span>
        case PublicRiskCritical:<span class="cov1" title="1">
                return domain.RiskCritical, nil</span>
        default:<span class="cov0" title="0">
                return domain.RiskLow, fmt.Errorf("unknown risk level: %s", publicRisk)</span>
        }
}

// MapRiskLevelToPublic converts domain risk level enum to public string
func MapRiskLevelToPublic(domainRisk domain.RiskLevelType) PublicRiskLevel <span class="cov10" title="5">{
        switch domainRisk </span>{
        case domain.RiskLow:<span class="cov1" title="1">
                return PublicRiskLow</span>
        case domain.RiskMedium:<span class="cov4" title="2">
                return PublicRiskMedium</span>
        case domain.RiskHigh:<span class="cov1" title="1">
                return PublicRiskHigh</span>
        case domain.RiskCritical:<span class="cov1" title="1">
                return PublicRiskCritical</span>
        default:<span class="cov0" title="0">
                return PublicRiskLow</span> // Default fallback
        }
}

// MapCleanResultToPublic converts domain clean result to public API type
func MapCleanResultToPublic(domainResult domain.CleanResult) result.Result[*PublicCleanResult] <span class="cov1" title="1">{
        // Map strategy
        strategy := MapStrategyToPublic(domainResult.Strategy)

        publicResult := &amp;PublicCleanResult{
                Success:      domainResult.IsValid(),
                FreedBytes:   domainResult.FreedBytes,
                ItemsRemoved: uint32(domainResult.ItemsRemoved),
                ItemsFailed:  uint32(domainResult.ItemsFailed),
                CleanTime:    domainResult.CleanTime.String(),
                CleanedAt:    domainResult.CleanedAt.Format(time.RFC3339),
                Strategy:     strategy,
        }

        // Add validation errors if any
        if err := domainResult.Validate(); err != nil </span><span class="cov0" title="0">{
                publicResult.Errors = []string{err.Error()}
                publicResult.Success = false
        }</span>

        <span class="cov1" title="1">return result.Ok(publicResult)</span>
}

// MapStrategyToPublic converts domain strategy enum to public string
func MapStrategyToPublic(domainStrategy domain.CleanStrategyType) PublicStrategy <span class="cov1" title="1">{
        switch domainStrategy </span>{
        case domain.StrategyAggressive:<span class="cov1" title="1">
                return PublicStrategyAggressive</span>
        case domain.StrategyConservative:<span class="cov0" title="0">
                return PublicStrategyConservative</span>
        case domain.StrategyDryRun:<span class="cov0" title="0">
                return PublicStrategyDryRun</span>
        default:<span class="cov0" title="0">
                return PublicStrategyDryRun</span> // Safe default
        }
}
</pre>

      <pre class="file" id="file16" style="display: none">package cleaner

import (
        "context"
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/adapters"
        "github.com/LarsArtmann/clean-wizard/internal/conversions"
        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/result"
)

// NixCleaner handles Nix package manager cleanup with proper type safety
type NixCleaner struct {
        adapter *adapters.NixAdapter
        verbose bool
        dryRun  bool
}

// NewNixCleaner creates Nix cleaner with proper configuration
func NewNixCleaner(verbose, dryRun bool) *NixCleaner <span class="cov10" title="4">{
        nc := &amp;NixCleaner{
                adapter: adapters.NewNixAdapter(0, 0),
                verbose: verbose,
                dryRun:  dryRun,
        }
        nc.adapter.SetDryRun(dryRun) // Pass dry-run to adapter
        return nc
}</span>

// IsAvailable checks if Nix cleaner is available
func (nc *NixCleaner) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        return nc.adapter.IsAvailable(ctx)
}</span>

// GetStoreSize gets Nix store size with type safety
func (nc *NixCleaner) GetStoreSize(ctx context.Context) int64 <span class="cov1" title="1">{
        if !nc.adapter.IsAvailable(ctx) </span><span class="cov1" title="1">{
                return int64(300 * 1024 * 1024 * 1024) // Mock store size
        }</span>

        <span class="cov0" title="0">storeSizeResult := nc.adapter.GetStoreSize(ctx)
        if storeSizeResult.IsErr() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return storeSizeResult.Value()</span>
}

// ValidateSettings validates Nix cleaner settings with type safety
func (nc *NixCleaner) ValidateSettings(settings *domain.OperationSettings) error <span class="cov0" title="0">{
        if settings == nil || settings.NixGenerations == nil </span><span class="cov0" title="0">{
                return nil // Settings are optional
        }</span>

        <span class="cov0" title="0">if settings.NixGenerations.Generations &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("Generations to keep must be at least 1, got: %d", settings.NixGenerations.Generations)
        }</span>

        <span class="cov0" title="0">if settings.NixGenerations.Generations &gt; 10 </span><span class="cov0" title="0">{
                return fmt.Errorf("Generations to keep must not exceed %d, got: %d", 10, settings.NixGenerations.Generations)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListGenerations lists Nix generations with proper type safety
func (nc *NixCleaner) ListGenerations(ctx context.Context) result.Result[[]domain.NixGeneration] <span class="cov8" title="3">{
        // Check availability first
        if !nc.adapter.IsAvailable(ctx) </span><span class="cov8" title="3">{
                // Return mock data for CI/testing - proper adapter pattern eliminates ghost system
                return result.MockSuccess([]domain.NixGeneration{
                        {ID: 300, Path: "/nix/var/nix/profiles/default-300-link", Date: time.Now().Add(-24 * time.Hour), Current: true},
                        {ID: 299, Path: "/nix/var/nix/profiles/default-299-link", Date: time.Now().Add(-48 * time.Hour), Current: false},
                        {ID: 298, Path: "/nix/var/nix/profiles/default-298-link", Date: time.Now().Add(-72 * time.Hour), Current: false},
                        {ID: 297, Path: "/nix/var/nix/profiles/default-297-link", Date: time.Now().Add(-96 * time.Hour), Current: false},
                        {ID: 296, Path: "/nix/var/nix/profiles/default-296-link", Date: time.Now().Add(-120 * time.Hour), Current: false},
                }, "Nix not available - using mock data")
        }</span>

        // Only call adapter if available
        <span class="cov0" title="0">return nc.adapter.ListGenerations(ctx)</span>
}

// CleanOldGenerations removes old Nix generations using centralized conversions
func (nc *NixCleaner) CleanOldGenerations(ctx context.Context, keepCount int) result.Result[domain.CleanResult] <span class="cov1" title="1">{
        // Get generations first
        genResult := nc.ListGenerations(ctx)
        if genResult.IsErr() </span><span class="cov0" title="0">{
                return conversions.ToCleanResultFromError(genResult.Error())
        }</span>

        <span class="cov1" title="1">generations := genResult.Value()

        // Count and remove old generations
        toRemove := countOldGenerations(generations, keepCount)

        if nc.dryRun </span><span class="cov1" title="1">{
                // Use centralized conversion for dry-run
                estimatedBytes := int64(toRemove * 50 * 1024 * 1024) // Use 50MB per generation
                cleanResult := conversions.NewCleanResult(domain.StrategyDryRun, toRemove, estimatedBytes)
                return result.Ok(cleanResult)
        }</span>

        // Real cleaning implementation
        <span class="cov0" title="0">if !nc.dryRun &amp;&amp; toRemove &gt; 0 </span><span class="cov0" title="0">{
                // Remove old generations individually to track what's cleaned
                results := make([]domain.CleanResult, 0, toRemove)
                start := time.Now()

                for i := len(generations) - toRemove; i &lt; len(generations); i++ </span><span class="cov0" title="0">{
                        // Skip current generation
                        if generations[i].Current </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Remove this generation
                        <span class="cov0" title="0">cleanResult := nc.adapter.RemoveGeneration(ctx, generations[i].ID)
                        if cleanResult.IsErr() </span><span class="cov0" title="0">{
                                return conversions.ToCleanResultFromError(cleanResult.Error())
                        }</span>

                        <span class="cov0" title="0">results = append(results, cleanResult.Value())</span>
                }

                // Run garbage collection to clean up references
                <span class="cov0" title="0">gcResult := nc.adapter.CollectGarbage(ctx)
                if gcResult.IsErr() </span><span class="cov0" title="0">{
                        return conversions.ToCleanResultFromError(gcResult.Error())
                }</span>

                <span class="cov0" title="0">results = append(results, gcResult.Value())

                // Combine all results using centralized function
                combinedResult := conversions.CombineCleanResults(results)
                combinedResult.CleanTime = time.Since(start)
                combinedResult.Strategy = domain.StrategyAggressive

                return result.Ok(combinedResult)</span>
        }

        // Dry-run or no generations to remove - use centralized conversion
        <span class="cov0" title="0">estimatedBytes := int64(toRemove * 50 * 1024 * 1024) // Estimated
        cleanResult := conversions.NewCleanResult(domain.StrategyDryRun, toRemove, estimatedBytes)
        return result.Ok(cleanResult)</span>
}

// countOldGenerations counts generations to remove (keeping current + N others)
func countOldGenerations(generations []domain.NixGeneration, keepCount int) int <span class="cov1" title="1">{
        if len(generations) &lt;= keepCount </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return len(generations) - keepCount</span>
}
</pre>

      <pre class="file" id="file17" style="display: none">package config

import (
        "testing"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// BDDFeature represents a BDD feature for behavior-driven development
type BDDFeature struct {
        Name        string
        Description string
        Background  string
        Scenarios   []BDDScenario
}

// BDDScenario represents a single BDD test scenario
type BDDScenario struct {
        Name        string
        Description string
        Given       []BDDGiven
        When        []BDDWhen
        Then        []BDDThen
}

// BDDGiven represents the initial state in BDD
type BDDGiven struct {
        Description string
        Setup       func() (*domain.Config, error)
}

// BDDWhen represents the action in BDD
type BDDWhen struct {
        Description string
        Action      func(*domain.Config) (*ValidationResult, error)
}

// BDDThen represents the expected outcome in BDD
type BDDThen struct {
        Description string
        Validate    func(*ValidationResult) error
}

// BDDTestRunner provides comprehensive BDD test execution
type BDDTestRunner struct {
        t         *testing.T
        feature   BDDFeature
        validator *ConfigValidator
}

// NewBDDTestRunner creates a new BDD test runner
func NewBDDTestRunner(t *testing.T, feature BDDFeature) *BDDTestRunner <span class="cov1" title="1">{
        return &amp;BDDTestRunner{
                t:         t,
                feature:   feature,
                validator: NewConfigValidator(),
        }
}</span>

// RunFeature executes all scenarios in a BDD feature
func (b *BDDTestRunner) RunFeature() <span class="cov1" title="1">{
        b.t.Logf("Feature: %s", b.feature.Name)
        b.t.Logf("Description: %s", b.feature.Description)
        if b.feature.Background != "" </span><span class="cov1" title="1">{
                b.t.Logf("Background: %s", b.feature.Background)
        }</span>

        <span class="cov1" title="1">for _, scenario := range b.feature.Scenarios </span><span class="cov6" title="4">{
                b.runScenario(scenario)
        }</span>
}

// runScenario executes a single BDD scenario
func (b *BDDTestRunner) runScenario(scenario BDDScenario) <span class="cov6" title="4">{
        b.t.Logf("Scenario: %s", scenario.Name)
        b.t.Logf("Description: %s", scenario.Description)

        // Guard checks for required steps
        if len(scenario.Given) == 0 </span><span class="cov0" title="0">{
                b.t.Errorf("scenario must define at least one Given step")
                return
        }</span>
        <span class="cov6" title="4">if len(scenario.When) == 0 </span><span class="cov0" title="0">{
                b.t.Errorf("scenario must define at least one When step")
                return
        }</span>

        // Setup Given conditions
        <span class="cov6" title="4">var cfg *domain.Config
        var setupErr error

        for i, given := range scenario.Given </span><span class="cov6" title="4">{
                b.t.Logf("  Given %d: %s", i+1, given.Description)
                if given.Setup == nil </span><span class="cov0" title="0">{
                        b.t.Errorf("Given step %d has no setup function", i+1)
                        return
                }</span>

                <span class="cov6" title="4">cfg, setupErr = given.Setup()
                if setupErr != nil </span><span class="cov0" title="0">{
                        b.t.Errorf("Given setup failed: %v", setupErr)
                        return
                }</span>
        }

        // Ensure config was created by Given steps
        <span class="cov6" title="4">if cfg == nil </span><span class="cov0" title="0">{
                b.t.Errorf("Given steps did not produce a config")
                return
        }</span>

        // Execute When actions
        <span class="cov6" title="4">var result *ValidationResult
        var actionErr error

        for i, when := range scenario.When </span><span class="cov6" title="4">{
                b.t.Logf("  When %d: %s", i+1, when.Description)
                if when.Action == nil </span><span class="cov0" title="0">{
                        b.t.Errorf("When step %d has no action function", i+1)
                        return
                }</span>

                <span class="cov6" title="4">result, actionErr = when.Action(cfg)
                if actionErr != nil </span><span class="cov0" title="0">{
                        b.t.Errorf("When action failed: %v", actionErr)
                        return
                }</span>
        }

        // Ensure result was created by When steps
        <span class="cov6" title="4">if result == nil </span><span class="cov0" title="0">{
                b.t.Errorf("When steps did not produce a result")
                return
        }</span>

        // Validate Then expectations
        <span class="cov6" title="4">for i, then := range scenario.Then </span><span class="cov10" title="10">{
                b.t.Logf("  Then %d: %s", i+1, then.Description)
                if then.Validate == nil </span><span class="cov0" title="0">{
                        b.t.Errorf("Then step %d has no validation function", i+1)
                        return
                }</span>

                <span class="cov10" title="10">if err := then.Validate(result); err != nil </span><span class="cov0" title="0">{
                        b.t.Errorf("Then validation failed: %v", err)
                        return
                }</span>
        }

        <span class="cov6" title="4">b.t.Logf("‚úì Scenario passed: %s", scenario.Name)</span>
}
</pre>

      <pre class="file" id="file18" style="display: none">package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        pkgerrors "github.com/LarsArtmann/clean-wizard/internal/pkg/errors"
        "github.com/sirupsen/logrus"
        "github.com/spf13/viper"
)

const (
        configName = ".clean-wizard"
        configType = "yaml"
)

// Load loads the configuration from file or creates default
func Load() (*domain.Config, error) <span class="cov0" title="0">{
        return LoadWithContext(context.Background())
}</span>

// LoadWithContext loads configuration with context support
func LoadWithContext(ctx context.Context) (*domain.Config, error) <span class="cov0" title="0">{
        v := viper.New()
        v.SetConfigName(configName)
        v.SetConfigType(configType)
        v.AddConfigPath("$HOME")
        v.AddConfigPath("/etc/clean-wizard")

        // Check for CONFIG_PATH environment variable
        if configPath := os.Getenv("CONFIG_PATH"); configPath != "" </span><span class="cov0" title="0">{
                v.SetConfigFile(configPath)
        }</span>

        // Set defaults
        <span class="cov0" title="0">v.SetDefault("version", "1.0.0")
        v.SetDefault("safe_mode", true)
        v.SetDefault("max_disk_usage_percent", 50)
        v.SetDefault("protected", []string{"/System", "/Library"}) // Basic protection

        // Try to read configuration file
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0">
                if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        if _, ok := err.(viper.ConfigFileNotFoundError); ok </span><span class="cov0" title="0">{
                                // Config file not found, return default config
                                return getDefaultConfig(), nil
                        }</span>
                        <span class="cov0" title="0">return nil, pkgerrors.HandleConfigError("LoadWithContext", err)</span>
                }
        }

        // Unmarshal profiles section
        <span class="cov0" title="0">var config domain.Config

        // Manually unmarshal fields to avoid YAML tag issues
        config.Version = v.GetString("version")
        config.SafeMode = v.GetBool("safe_mode")
        config.MaxDiskUsage = v.GetInt("max_disk_usage_percent")
        config.Protected = v.GetStringSlice("protected")

        // Unmarshal profiles section
        if err := v.UnmarshalKey("profiles", &amp;config.Profiles); err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("Failed to unmarshal profiles")
                return nil, pkgerrors.HandleConfigError("LoadWithContext", err)
        }</span>

        // Fix risk levels and settings after unmarshaling (workaround for custom type unmarshaling)
        <span class="cov0" title="0">for name, profile := range config.Profiles </span><span class="cov0" title="0">{
                for i := range profile.Operations </span><span class="cov0" title="0">{
                        op := &amp;profile.Operations[i] // Get pointer to actual operation
                        
                        // Convert string risk level to RiskLevel enum
                        var riskLevelStr string
                        v.UnmarshalKey(fmt.Sprintf("profiles.%s.operations.%d.risk_level", name, i), &amp;riskLevelStr)

                        switch strings.ToUpper(riskLevelStr) </span>{
                        case "LOW":<span class="cov0" title="0">
                                op.RiskLevel = domain.RiskLow</span>
                        case "MEDIUM":<span class="cov0" title="0">
                                op.RiskLevel = domain.RiskMedium</span>
                        case "HIGH":<span class="cov0" title="0">
                                op.RiskLevel = domain.RiskHigh</span>
                        case "CRITICAL":<span class="cov0" title="0">
                                op.RiskLevel = domain.RiskCritical</span>
                        default:<span class="cov0" title="0">
                                logrus.WithField("risk_level", riskLevelStr).Warn("Invalid risk level, defaulting to LOW")
                                op.RiskLevel = domain.RiskLow</span>
                        }

                        // Explicitly unmarshal settings for each operation type
                        <span class="cov0" title="0">settingsKey := fmt.Sprintf("profiles.%s.operations.%d.settings", name, i)
                        settingsMap := v.GetStringMap(settingsKey)
                        logrus.WithField("settingsKey", settingsKey).WithField("settingsMap", settingsMap).Debug("Checking settings")
                        
                        if len(settingsMap) &gt; 0 </span><span class="cov0" title="0">{
                                // Check for nix_generations settings
                                if _, exists := settingsMap["nix_generations"]; exists </span><span class="cov0" title="0">{
                                        nixGenSettings := &amp;domain.NixGenerationsSettings{}
                                        nixGenKey := settingsKey + ".nix_generations"
                                        logrus.WithField("nixGenKey", nixGenKey).Debug("Unmarshaling Nix generations settings")
                                        
                                        if err := v.UnmarshalKey(nixGenKey, nixGenSettings); err == nil </span><span class="cov0" title="0">{
                                                logrus.WithField("nixGenSettings", nixGenSettings).Debug("Assigning Nix generations settings")
                                                
                                                // Use direct field assignment to actual operation
                                                op.Settings = &amp;domain.OperationSettings{}
                                                op.Settings.NixGenerations = nixGenSettings
                                                logrus.WithField("opSettings", op.Settings.NixGenerations).Debug("Set operation settings")
                                        }</span> else<span class="cov0" title="0"> {
                                                logrus.WithError(err).Error("Failed to unmarshal nix_generations settings")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logrus.Debug("No nix_generations settings found")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                logrus.Debug("No settings map found")
                        }</span>
                }
        }

        // IMMEDIATE DEBUG: Check settings RIGHT after assignment loop
        <span class="cov0" title="0">logrus.Debug("=== CHECKING SETTINGS IMMEDIATELY AFTER ASSIGNMENT ===")
        for name, profile := range config.Profiles </span><span class="cov0" title="0">{
                for i, op := range profile.Operations </span><span class="cov0" title="0">{
                        if op.Name == "nix-generations" </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "profile": name,
                                        "operation": i,
                                        "hasSettings": op.Settings != nil,
                                        "settings": op.Settings,
                                }).Debug("IMMEDIATE: Settings after assignment")
                        }</span>
                }
        }

        // Enable comprehensive validation - CRITICAL for production safety
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleConfigError("LoadWithContext", err)
        }</span>

        // DEBUG: Verify settings are preserved after validation
        <span class="cov0" title="0">logrus.Debug("=== CHECKING SETTINGS AFTER VALIDATION ===")
        for name, profile := range config.Profiles </span><span class="cov0" title="0">{
                for i, op := range profile.Operations </span><span class="cov0" title="0">{
                        if op.Name == "nix-generations" &amp;&amp; op.Settings != nil &amp;&amp; op.Settings.NixGenerations != nil </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "profile": name,
                                        "operation": i,
                                        "settings": op.Settings.NixGenerations,
                                }).Debug("Settings preserved after validation")
                        }</span>
                }
        }

        // Apply comprehensive validation with strict enforcement
        <span class="cov0" title="0">if validator := NewConfigValidator(); validator != nil </span><span class="cov0" title="0">{
                validationResult := validator.ValidateConfig(&amp;config)
                if !validationResult.IsValid </span><span class="cov0" title="0">{
                        // CRITICAL: Fail fast on validation errors for production safety
                        for _, err := range validationResult.Errors </span><span class="cov0" title="0">{
                                logrus.WithField("field", err.Field).WithError(fmt.Errorf("%s", err.Message)).Error("Configuration validation error")
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("configuration validation failed with %d errors", len(validationResult.Errors))</span>
                }
        }

        // FINAL DEBUG: Check settings before returning config
        <span class="cov0" title="0">for name, profile := range config.Profiles </span><span class="cov0" title="0">{
                for i, op := range profile.Operations </span><span class="cov0" title="0">{
                        if op.Name == "nix-generations" </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "profile": name,
                                        "operation": i,
                                        "hasSettings": op.Settings != nil,
                                        "settings": op.Settings,
                                }).Debug("FINAL: Settings before returning config")
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// Save saves the configuration to file
func Save(config *domain.Config) error <span class="cov0" title="0">{
        v := viper.New()

        // Set configuration file properties
        v.SetConfigName(configName)
        v.SetConfigType(configType)

        // Set configuration path
        configPath := filepath.Join(os.Getenv("HOME"), configName+"."+configType)

        // Set configuration values
        v.Set("version", config.Version)
        v.Set("safe_mode", config.SafeMode)
        v.Set("max_disk_usage_percent", config.MaxDiskUsage)
        v.Set("protected", config.Protected)
        v.Set("last_clean", config.LastClean)
        v.Set("updated", config.Updated)

        // Set profiles
        for name, profile := range config.Profiles </span><span class="cov0" title="0">{
                v.Set("profiles."+name+".name", profile.Name)
                v.Set("profiles."+name+".description", profile.Description)
                v.Set("profiles."+name+".enabled", profile.Enabled)

                for i, op := range profile.Operations </span><span class="cov0" title="0">{
                        opKey := fmt.Sprintf("profiles.%s.operations.%d", name, i)
                        v.Set(opKey+".name", op.Name)
                        v.Set(opKey+".description", op.Description)
                        v.Set(opKey+".risk_level", op.RiskLevel)
                        v.Set(opKey+".enabled", op.Enabled)
                        if op.Settings != nil </span><span class="cov0" title="0">{
                                v.Set(opKey+".settings", op.Settings)
                        }</span>
                }
        }

        // Ensure config directory exists
        <span class="cov0" title="0">configDir := filepath.Dir(configPath)
        if err := os.MkdirAll(configDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.HandleConfigError("Save", err)
        }</span>

        // Write configuration file
        <span class="cov0" title="0">if err := v.WriteConfigAs(configPath); err != nil </span><span class="cov0" title="0">{
                return pkgerrors.HandleConfigError("Save", err)
        }</span>

        <span class="cov0" title="0">logrus.WithField("config_path", configPath).Info("Configuration saved successfully")
        return nil</span>
}

// GetCurrentTime returns current time (helper for testing)
func GetCurrentTime() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

// getDefaultConfig returns the default configuration
func getDefaultConfig() *domain.Config <span class="cov0" title="0">{
        now := GetCurrentTime()

        return &amp;domain.Config{
                Version:      "1.0.0",
                SafeMode:     true, // Default to safe mode
                MaxDiskUsage: 50,
                Protected: []string{
                        "/System",
                        "/Applications",
                        "/Library",
                },
                Profiles: map[string]*domain.Profile{
                        "daily": {
                                Name:        "daily",
                                Description: "Quick daily cleanup",
                                Operations: []domain.CleanupOperation{
                                        {
                                                Name:        "nix-generations",
                                                Description: "Clean old Nix generations",
                                                RiskLevel:   domain.RiskLow,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
                                        },
                                        {
                                                Name:        "temp-files",
                                                Description: "Clean temporary files",
                                                RiskLevel:   domain.RiskLow,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeTempFiles),
                                        },
                                },
                                Enabled: true,
                        },
                        "aggressive": {
                                Name:        "aggressive",
                                Description: "Deep aggressive cleanup",
                                Operations: []domain.CleanupOperation{
                                        {
                                                Name:        "nix-generations",
                                                Description: "Clean old Nix generations",
                                                RiskLevel:   domain.RiskHigh,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
                                        },
                                        {
                                                Name:        "homebrew-cleanup",
                                                Description: "Clean old Homebrew packages",
                                                RiskLevel:   domain.RiskMedium,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeHomebrew),
                                        },
                                },
                                Enabled: true,
                        },
                        "comprehensive": {
                                Name:        "comprehensive",
                                Description: "Complete system cleanup",
                                Operations: []domain.CleanupOperation{
                                        {
                                                Name:        "nix-generations",
                                                Description: "Clean old Nix generations",
                                                RiskLevel:   domain.RiskCritical,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeNixGenerations),
                                        },
                                        {
                                                Name:        "homebrew-cleanup",
                                                Description: "Clean old Homebrew packages",
                                                RiskLevel:   domain.RiskMedium,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeHomebrew),
                                        },
                                        {
                                                Name:        "system-temp",
                                                Description: "Clean system temporary files",
                                                RiskLevel:   domain.RiskMedium,
                                                Enabled:     true,
                                                Settings:    domain.DefaultSettings(domain.OperationTypeSystemTemp),
                                        },
                                },
                                Enabled: true,
                        },
                },
                LastClean: now,
                Updated:   now,
        }
}</span>
</pre>

      <pre class="file" id="file19" style="display: none">package config

import (
        "context"
        "fmt"
        "slices"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// applyValidation applies validation at the specified level
func (ecl *EnhancedConfigLoader) applyValidation(ctx context.Context, config *domain.Config, level ValidationLevel) *ValidationResult <span class="cov0" title="0">{
        switch level </span>{
        case ValidationLevelNone:<span class="cov0" title="0">
                return &amp;ValidationResult{IsValid: true, Timestamp: time.Now()}</span>
        case ValidationLevelBasic:<span class="cov0" title="0">
                return ecl.validator.ValidateConfig(config)</span> // Use existing validator
        case ValidationLevelComprehensive:<span class="cov0" title="0">
                // Add additional validation rules
                result := ecl.validator.ValidateConfig(config)
                ecl.applyComprehensiveValidation(config, result)
                return result</span>
        case ValidationLevelStrict:<span class="cov0" title="0">
                // Apply all validation including strict checks
                result := ecl.validator.ValidateConfig(config)
                ecl.applyComprehensiveValidation(config, result)
                ecl.applyStrictValidation(config, result)
                return result</span>
        default:<span class="cov0" title="0">
                return ecl.validator.ValidateConfig(config)</span>
        }
}

// applyComprehensiveValidation applies comprehensive validation rules
func (ecl *EnhancedConfigLoader) applyComprehensiveValidation(config *domain.Config, result *ValidationResult) <span class="cov0" title="0">{
        // Additional comprehensive validation rules

        // Check for configuration consistency
        if config.SafeMode &amp;&amp; ecl.hasCriticalRiskOperations(config) </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Field:      "safe_mode",
                        Message:    "Safe mode is enabled but critical risk operations exist",
                        Suggestion: "Review critical operations or consider increasing risk tolerance",
                })
        }</span>

        // Check for performance implications
        <span class="cov0" title="0">if len(config.Profiles) &gt; 20 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Field:      "profiles",
                        Message:    "Large number of profiles may impact performance",
                        Suggestion: "Consider consolidating similar profiles",
                })
        }</span>
}

// applyStrictValidation applies strict validation rules
func (ecl *EnhancedConfigLoader) applyStrictValidation(config *domain.Config, result *ValidationResult) <span class="cov0" title="0">{
        // Strict validation rules that might fail

        // Require explicit profiles (no auto-generation)
        if len(config.Profiles) == 0 </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, ValidationError{
                        Field:    "profiles",
                        Rule:     "strict",
                        Value:    config.Profiles,
                        Message:  "Strict mode requires at least one explicit profile",
                        Severity: SeverityError,
                })
                result.IsValid = false
        }</span>

        // Require specific protected paths
        <span class="cov0" title="0">requiredPaths := ecl.validator.rules.ProtectedSystemPaths
        // Fallback to DefaultProtectedPaths if rules slice is nil/empty (maintaining consistency with sanitizer)
        if len(requiredPaths) == 0 </span><span class="cov0" title="0">{
                requiredPaths = ecl.validator.rules.DefaultProtectedPaths
                if len(requiredPaths) == 0 </span><span class="cov0" title="0">{
                        requiredPaths = []string{"/System", "/Library"} // Final fallback
                }</span>
        }
        <span class="cov0" title="0">for _, required := range requiredPaths </span><span class="cov0" title="0">{
                if !ecl.isPathProtected(config.Protected, required) </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Field:    "protected",
                                Rule:     "strict",
                                Value:    config.Protected,
                                Message:  fmt.Sprintf("Strict mode requires path: %s", required),
                                Severity: SeverityError,
                        })
                        result.IsValid = false
                }</span>
        }
}

// hasCriticalRiskOperations checks if config contains critical risk operations
func (ecl *EnhancedConfigLoader) hasCriticalRiskOperations(config *domain.Config) bool <span class="cov0" title="0">{
        for _, profile := range config.Profiles </span><span class="cov0" title="0">{
                // Guard against nil profiles (e.g., from "profile: null" in YAML)
                if profile == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, op := range profile.Operations </span><span class="cov0" title="0">{
                        if op.RiskLevel == domain.RiskCritical </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// isPathProtected checks if a path is in the protected list
func (ecl *EnhancedConfigLoader) isPathProtected(protected []string, target string) bool <span class="cov0" title="0">{
        return slices.Contains(protected, target)
}</span>

// mapValidatorRulesToSchemaRules converts validator rules to stable schema rules
func (ecl *EnhancedConfigLoader) mapValidatorRulesToSchemaRules() *ConfigValidationRules <span class="cov0" title="0">{
        rules := ecl.validator.rules

        // Create a copy to prevent external modifications to internal state
        schemaRules := &amp;ConfigValidationRules{
                // Numeric Constraints
                MaxDiskUsage:      rules.MaxDiskUsage,
                MinProtectedPaths: rules.MinProtectedPaths,
                MaxProfiles:       rules.MaxProfiles,
                MaxOperations:     rules.MaxOperations,

                // String Constraints
                ProfileNamePattern: rules.ProfileNamePattern,
                PathPattern:        rules.PathPattern,

                // Array Constraints
                UniquePaths:    rules.UniquePaths,
                UniqueProfiles: rules.UniqueProfiles,

                // Safety Constraints
                ProtectedSystemPaths: make([]string, len(rules.ProtectedSystemPaths)),
                RequireSafeMode:      rules.RequireSafeMode,

                // Risk Constraints
                MaxRiskLevel:   rules.MaxRiskLevel,
                BackupRequired: rules.BackupRequired,
        }

        // Deep copy slice to prevent modifications
        copy(schemaRules.ProtectedSystemPaths, rules.ProtectedSystemPaths)

        return schemaRules
}</span>

// getSchemaMinimum returns the minimum value for max_disk_usage from rules
func (ecl *EnhancedConfigLoader) getSchemaMinimum() *float64 <span class="cov0" title="0">{
        if ecl.validator.rules.MaxDiskUsage != nil &amp;&amp; ecl.validator.rules.MaxDiskUsage.Min != nil </span><span class="cov0" title="0">{
                v := float64(*ecl.validator.rules.MaxDiskUsage.Min)
                return &amp;v
        }</span>
        <span class="cov0" title="0">v := 10.0 // fallback to current literal
        return &amp;v</span>
}

// getSchemaMaximum returns the maximum value for max_disk_usage from rules
func (ecl *EnhancedConfigLoader) getSchemaMaximum() *float64 <span class="cov0" title="0">{
        if ecl.validator.rules.MaxDiskUsage != nil &amp;&amp; ecl.validator.rules.MaxDiskUsage.Max != nil </span><span class="cov0" title="0">{
                v := float64(*ecl.validator.rules.MaxDiskUsage.Max)
                return &amp;v
        }</span>
        <span class="cov0" title="0">v := 95.0 // fallback to current literal
        return &amp;v</span>
}

// formatValidationErrors formats validation errors for display
func (ecl *EnhancedConfigLoader) formatValidationErrors(errors []ValidationError) string <span class="cov0" title="0">{
        if len(errors) == 0 </span><span class="cov0" title="0">{
                return "no errors"
        }</span>

        <span class="cov0" title="0">var messages []string
        for _, err := range errors </span><span class="cov0" title="0">{
                messages = append(messages, fmt.Sprintf("%s: %s", err.Field, err.Message))
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%d validation errors: %s", len(errors), fmt.Sprintf("%v", messages))</span>
}
</pre>

      <pre class="file" id="file20" style="display: none">package config

import (
        "context"
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        pkgerrors "github.com/LarsArtmann/clean-wizard/internal/pkg/errors"
)

// LoadConfig loads configuration with comprehensive validation and caching
func (ecl *EnhancedConfigLoader) LoadConfig(ctx context.Context, options *ConfigLoadOptions) (*domain.Config, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = getDefaultLoadOptions()
        }</span>

        <span class="cov0" title="0">start := time.Now()

        // Check cache first
        if options.EnableCache &amp;&amp; !options.ForceRefresh </span><span class="cov0" title="0">{
                if cached := ecl.cache.Get(); cached != nil </span><span class="cov0" title="0">{
                        return cached, nil
                }</span>
        }

        // Load configuration with retry
        <span class="cov0" title="0">config, err := ecl.loadConfigWithRetry(ctx, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Apply validation based on level
        <span class="cov0" title="0">validationResult := ecl.applyValidation(ctx, config, ValidationLevel(options.ValidationLevel))
        if !validationResult.IsValid </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleValidationError("LoadConfig",
                        fmt.Errorf("validation failed: %s", ecl.formatValidationErrors(validationResult.Errors)))
        }</span>

        // Apply sanitization if enabled
        <span class="cov0" title="0">if options.EnableSanitization </span><span class="cov0" title="0">{
                ecl.sanitizer.SanitizeConfig(config, validationResult)
        }</span>

        // Update cache
        <span class="cov0" title="0">if options.EnableCache </span><span class="cov0" title="0">{
                ecl.cache.Set(config)
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        if ecl.enableMonitoring </span><span class="cov0" title="0">{
                fmt.Printf("üìä Config loaded in %v (validation: %s, sanitization: %v)\n",
                        duration, options.ValidationLevel, options.EnableSanitization)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// SaveConfig saves configuration with validation and cache update
func (ecl *EnhancedConfigLoader) SaveConfig(ctx context.Context, config *domain.Config, options *ConfigSaveOptions) (*domain.Config, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = getDefaultSaveOptions()
        }</span>

        // Create backup if requested (independent of monitoring)
        <span class="cov0" title="0">if options.CreateBackup || options.BackupEnabled </span><span class="cov0" title="0">{
                if err := ecl.createBackup(ctx, config); err != nil </span><span class="cov0" title="0">{
                        if ecl.enableMonitoring </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è Backup failed: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> if ecl.enableMonitoring </span><span class="cov0" title="0">{
                        fmt.Printf("üíæ Configuration backup created\n")
                }</span>
        }

        // Always run validation at requested level
        <span class="cov0" title="0">validationResult := ecl.applyValidation(ctx, config, ValidationLevel(options.ValidationLevel))

        // Apply sanitization if enabled (after initial validation)
        if options.EnableSanitization </span><span class="cov0" title="0">{
                ecl.sanitizer.SanitizeConfig(config, validationResult)
                // Re-check validity after sanitization
                validationResult = ecl.applyValidation(ctx, config, ValidationLevel(options.ValidationLevel))
        }</span>

        // Check final validation state
        <span class="cov0" title="0">if !validationResult.IsValid </span><span class="cov0" title="0">{
                if options.ForceSave </span><span class="cov0" title="0">{
                        if ecl.enableMonitoring </span><span class="cov0" title="0">{
                                fmt.Printf("‚ö†Ô∏è Validation failed, forcing save: %s\n", ecl.formatValidationErrors(validationResult.Errors))
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("validation failed: %s", ecl.formatValidationErrors(validationResult.Errors))
                }</span>
        }

        // Only call saveConfigWithRetry when validation permits saving
        <span class="cov0" title="0">err := ecl.saveConfigWithRetry(ctx, config, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update cache
        <span class="cov0" title="0">ecl.cache.Set(config)

        if ecl.enableMonitoring </span><span class="cov0" title="0">{
                if options.ForceSave &amp;&amp; !validationResult.IsValid </span><span class="cov0" title="0">{
                        fmt.Printf("üíæ Config saved (forced) despite validation failures\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("üíæ Config saved successfully\n")
                }</span>
        }

        <span class="cov0" title="0">return config, nil</span>
}

// ValidateConfig validates configuration at specified level
func (ecl *EnhancedConfigLoader) ValidateConfig(ctx context.Context, config *domain.Config, level domain.ValidationLevelType) *ValidationResult <span class="cov0" title="0">{
        return ecl.applyValidation(ctx, config, ValidationLevel(level))
}</span>
</pre>

      <pre class="file" id="file21" style="display: none">package config

import (
        "sync"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// ConfigCache provides configuration caching with TTL
type ConfigCache struct {
        mu        sync.RWMutex
        config    *domain.Config
        loadedAt  time.Time
        ttl       time.Duration
        validator *ConfigValidator
}

// NewConfigCache creates a new configuration cache with specified TTL
func NewConfigCache(ttl time.Duration) *ConfigCache <span class="cov0" title="0">{
        return &amp;ConfigCache{
                ttl:       ttl,
                validator: NewConfigValidator(),
        }
}</span>

// Get retrieves cached configuration if valid and not expired
func (cc *ConfigCache) Get() *domain.Config <span class="cov0" title="0">{
        cc.mu.RLock()
        if cc.config == nil || time.Since(cc.loadedAt) &gt; cc.ttl </span><span class="cov0" title="0">{
                cc.mu.RUnlock()
                return nil
        }</span>

        // Validate cached config
        <span class="cov0" title="0">validator := cc.validator
        config := cc.config
        cc.mu.RUnlock()

        result := validator.ValidateConfig(config)
        if !result.IsValid </span><span class="cov0" title="0">{
                cc.mu.Lock()
                cc.config = nil // Invalidate cache
                cc.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">return config</span>
}

// Set stores configuration in cache with current timestamp
func (cc *ConfigCache) Set(config *domain.Config) <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        cc.config = config
        cc.loadedAt = time.Now()
}</span>
</pre>

      <pre class="file" id="file22" style="display: none">package config

import (
        "time"
)

// getDefaultLoadOptions returns default load options
func getDefaultLoadOptions() *ConfigLoadOptions <span class="cov0" title="0">{
        return &amp;ConfigLoadOptions{
                ForceRefresh:       false,
                EnableCache:        true,
                EnableSanitization: true,
                ValidationLevel:    ValidationLevelComprehensive,
                Timeout:            30 * time.Second,
        }
}</span>

// getDefaultSaveOptions returns default save options
func getDefaultSaveOptions() *ConfigSaveOptions <span class="cov0" title="0">{
        return &amp;ConfigSaveOptions{
                EnableSanitization: true,
                BackupEnabled:      true,
                ValidationLevel:    ValidationLevelComprehensive,
                CreateBackup:       false,
                ForceSave:          false,
        }
}</span>

// getDefaultRetryPolicy returns default retry policy
func getDefaultRetryPolicy() *RetryPolicy <span class="cov0" title="0">{
        return &amp;RetryPolicy{
                MaxRetries:    3,
                InitialDelay:  100 * time.Millisecond,
                MaxDelay:      5 * time.Second,
                BackoffFactor: 2.0,
        }
}</span>
</pre>

      <pre class="file" id="file23" style="display: none">package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// loadConfigWithRetry loads configuration with retry logic
func (ecl *EnhancedConfigLoader) loadConfigWithRetry(ctx context.Context, options *ConfigLoadOptions) (*domain.Config, error) <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= ecl.retryPolicy.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        delay := ecl.calculateDelay(attempt)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        }
                }

                // Use existing Load function with timeout context
                <span class="cov0" title="0">timeoutCtx, cancel := context.WithTimeout(ctx, options.Timeout)
                config, err := LoadWithContext(timeoutCtx)
                cancel()

                if err == nil </span><span class="cov0" title="0">{
                        return config, nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                if !ecl.shouldRetry(err) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to load config after %d attempts: %w", ecl.retryPolicy.MaxRetries+1, lastErr)</span>
}

// saveConfigWithRetry saves configuration with retry logic
func (ecl *EnhancedConfigLoader) saveConfigWithRetry(ctx context.Context, config *domain.Config, options *ConfigSaveOptions) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 0; attempt &lt;= ecl.retryPolicy.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        delay := ecl.calculateDelay(attempt)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">err := Save(config)
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err

                if !ecl.shouldRetry(err) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("failed to save config after %d attempts: %w", ecl.retryPolicy.MaxRetries+1, lastErr)</span>
}

// createBackup creates a backup of the current configuration
func (ecl *EnhancedConfigLoader) createBackup(ctx context.Context, config *domain.Config) error <span class="cov0" title="0">{
        // Read current config file and copy to backup location
        originalConfigPath := filepath.Join(os.Getenv("HOME"), ".clean-wizard.yaml")
        backupPath := fmt.Sprintf("%s.backup.%d", originalConfigPath, time.Now().Unix())

        // Read current config file
        configData, err := os.ReadFile(originalConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read current config for backup: %w", err)
        }</span>

        // Write backup copy
        <span class="cov0" title="0">err = os.WriteFile(backupPath, configData, 0o644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup at %s: %w", backupPath, err)
        }</span>

        <span class="cov0" title="0">if ecl.enableMonitoring </span><span class="cov0" title="0">{
                fmt.Printf("üíæ Configuration backup created\n")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// shouldRetry determines if an error should trigger a retry
func (ecl *EnhancedConfigLoader) shouldRetry(err error) bool <span class="cov0" title="0">{
        // Don't retry on certain errors
        if err.Error() == "validation failed" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// calculateDelay calculates exponential backoff delay
func (ecl *EnhancedConfigLoader) calculateDelay(attempt int) time.Duration <span class="cov0" title="0">{
        delay := float64(ecl.retryPolicy.InitialDelay) *
                float64(ecl.retryPolicy.BackoffFactor) *
                float64(attempt)

        if delay &gt; float64(ecl.retryPolicy.MaxDelay) </span><span class="cov0" title="0">{
                delay = float64(ecl.retryPolicy.MaxDelay)
        }</span>

        <span class="cov0" title="0">return time.Duration(delay)</span>
}
</pre>

      <pre class="file" id="file24" style="display: none">package config

import (
        "time"
)

// ValidationLevel defines validation strictness (backward compatibility)
//
// IMPORTANT: These integer values MUST remain in sync with domain.ValidationLevelType
// See: internal/domain/type_safe_enums.go:116-123
// When changing numeric values, update BOTH locations to prevent drift.
// Consider aliasing the domain type directly to avoid duplication in the future.
type ValidationLevel int

const (
        ValidationLevelNone          ValidationLevel = 0
        ValidationLevelBasic         ValidationLevel = 1
        ValidationLevelComprehensive ValidationLevel = 2
        ValidationLevelStrict        ValidationLevel = 3
)

// String returns string representation
func (vl ValidationLevel) String() string <span class="cov10" title="2">{
        switch vl </span>{
        case ValidationLevelNone:<span class="cov0" title="0">
                return "NONE"</span>
        case ValidationLevelBasic:<span class="cov10" title="2">
                return "BASIC"</span>
        case ValidationLevelComprehensive:<span class="cov0" title="0">
                return "COMPREHENSIVE"</span>
        case ValidationLevelStrict:<span class="cov0" title="0">
                return "STRICT"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// EnhancedConfigLoader provides comprehensive configuration loading with validation
type EnhancedConfigLoader struct {
        middleware       *ValidationMiddleware
        validator        *ConfigValidator
        sanitizer        *ConfigSanitizer
        cache            *ConfigCache
        retryPolicy      *RetryPolicy
        enableMonitoring bool
}

// ConfigLoadOptions provides options for configuration loading
type ConfigLoadOptions struct {
        ForceRefresh       bool            `json:"force_refresh"`
        EnableCache        bool            `json:"enable_cache"`
        EnableSanitization bool            `json:"enable_sanitization"`
        ValidationLevel    ValidationLevel `json:"validation_level"`
        Timeout            time.Duration   `json:"timeout"`
}

// ConfigSaveOptions provides options for configuration saving
type ConfigSaveOptions struct {
        EnableSanitization bool            `json:"enable_sanitization"`
        BackupEnabled      bool            `json:"backup_enabled"`
        ValidationLevel    ValidationLevel `json:"validation_level"`
        CreateBackup       bool            `json:"create_backup"`
        ForceSave          bool            `json:"force_save"` // Override validation failures
}

// RetryPolicy defines retry behavior for configuration operations
type RetryPolicy struct {
        MaxRetries    int           `json:"max_retries"`
        InitialDelay  time.Duration `json:"initial_delay"`
        MaxDelay      time.Duration `json:"max_delay"`
        BackoffFactor float64       `json:"backoff_factor"`
}

// NewEnhancedConfigLoader creates a new enhanced config loader
func NewEnhancedConfigLoader(options ...func(*EnhancedConfigLoader)) *EnhancedConfigLoader <span class="cov0" title="0">{
        validator := NewConfigValidator()
        sanitizer := NewConfigSanitizer()
        middleware := NewValidationMiddleware()

        ecl := &amp;EnhancedConfigLoader{
                middleware:       middleware,
                validator:        validator,
                sanitizer:        sanitizer,
                cache:            NewConfigCache(30 * time.Minute),
                retryPolicy:      getDefaultRetryPolicy(),
                enableMonitoring: false,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(ecl)
        }</span>

        <span class="cov0" title="0">return ecl</span>
}

// WithMonitoring enables monitoring output
func WithMonitoring(enabled bool) func(*EnhancedConfigLoader) <span class="cov0" title="0">{
        return func(ecl *EnhancedConfigLoader) </span><span class="cov0" title="0">{
                ecl.enableMonitoring = enabled
        }</span>
}

// WithRetryPolicy sets custom retry policy
func WithRetryPolicy(policy *RetryPolicy) func(*EnhancedConfigLoader) <span class="cov0" title="0">{
        return func(ecl *EnhancedConfigLoader) </span><span class="cov0" title="0">{
                // Guard against nil policy to preserve defaults
                if policy == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ecl.retryPolicy = policy</span>
        }
}
</pre>

      <pre class="file" id="file25" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// SafeConfig represents a validated cleaning configuration
type SafeConfig struct {
        safeMode bool
        dryRun   bool
        backup   bool
        maxRisk  domain.RiskLevel
        profiles []SafeProfile
        created  time.Time
}

// SafeProfile represents a validated cleaning profile
type SafeProfile struct {
        name        string
        description string
        operations  []SafeOperation
        maxRisk     domain.RiskLevel
}

// SafeOperation represents a validated cleaning operation
type SafeOperation struct {
        name    CleanType
        risk    domain.RiskLevel
        enabled bool
        backup  bool
}

// String returns string representation (removed - use domain.RiskLevel methods)

// Icon returns emoji for risk level - moved to domain package

// CleanType represents type-safe cleaning types
type CleanType string

const (
        CleanTypeNixStore     CleanType = "nix_store"
        CleanTypeHomebrew     CleanType = "homebrew"
        CleanTypePackageCache CleanType = "package_cache"
        CleanTypeTempFiles    CleanType = "temp_files"
)

// IsValid checks if clean type is valid
func (ct CleanType) IsValid() bool <span class="cov10" title="11">{
        switch ct </span>{
        case CleanTypeNixStore, CleanTypeHomebrew, CleanTypePackageCache, CleanTypeTempFiles:<span class="cov9" title="9">
                return true</span>
        default:<span class="cov3" title="2">
                return false</span>
        }
}

// NewSafeConfigBuilder creates a type-safe configuration builder
func NewSafeConfigBuilder() *SafeConfigBuilder <span class="cov8" title="7">{
        return &amp;SafeConfigBuilder{
                profiles: []SafeProfile{},
                maxRisk:  domain.RiskLow,
        }
}</span>

// SafeConfigBuilder builds type-safe configurations
type SafeConfigBuilder struct {
        safeMode bool
        dryRun   bool
        backup   bool
        maxRisk  domain.RiskLevel
        profiles []SafeProfile
        err      error
}

// SafeMode enables safe mode
func (scb *SafeConfigBuilder) SafeMode() *SafeConfigBuilder <span class="cov0" title="0">{
        scb.safeMode = true
        return scb
}</span>

// DryRun enables dry-run mode
func (scb *SafeConfigBuilder) DryRun() *SafeConfigBuilder <span class="cov0" title="0">{
        scb.dryRun = true
        return scb
}</span>

// Backup enables backup mode
func (scb *SafeConfigBuilder) Backup() *SafeConfigBuilder <span class="cov0" title="0">{
        scb.backup = true
        return scb
}</span>

// AddProfile adds a safe profile
func (scb *SafeConfigBuilder) AddProfile(name, description string) *SafeProfileBuilder <span class="cov7" title="6">{
        if scb.err != nil </span><span class="cov0" title="0">{
                return &amp;SafeProfileBuilder{err: scb.err}
        }</span>

        <span class="cov7" title="6">return &amp;SafeProfileBuilder{
                name:        name,
                description: description,
                config:      scb,
                operations:  []SafeOperation{},
                maxRisk:     domain.RiskLow,
        }</span>
}

// Build creates safe configuration
func (scb *SafeConfigBuilder) Build() (SafeConfig, error) <span class="cov8" title="7">{
        if scb.err != nil </span><span class="cov3" title="2">{
                return SafeConfig{}, scb.err
        }</span>

        <span class="cov7" title="5">if len(scb.profiles) == 0 </span><span class="cov1" title="1">{
                return SafeConfig{}, fmt.Errorf("config must have at least one profile")
        }</span>

        <span class="cov6" title="4">if !scb.maxRisk.IsValid() </span><span class="cov0" title="0">{
                return SafeConfig{}, fmt.Errorf("invalid risk level: %s", scb.maxRisk)
        }</span>

        <span class="cov6" title="4">return SafeConfig{
                safeMode: scb.safeMode,
                dryRun:   scb.dryRun,
                backup:   scb.backup,
                maxRisk:  scb.maxRisk,
                profiles: scb.profiles,
                created:  time.Now(),
        }, nil</span>
}

// SafeProfileBuilder builds type-safe profiles
type SafeProfileBuilder struct {
        name        string
        description string
        config      *SafeConfigBuilder
        operations  []SafeOperation
        maxRisk     domain.RiskLevel
        err         error
}

// AddOperation adds a safe operation
func (spb *SafeProfileBuilder) AddOperation(opType CleanType, risk domain.RiskLevel) *SafeProfileBuilder <span class="cov7" title="5">{
        if spb.err != nil </span><span class="cov0" title="0">{
                return spb
        }</span>

        <span class="cov7" title="5">if !opType.IsValid() </span><span class="cov0" title="0">{
                spb.err = fmt.Errorf("invalid clean type: %s", opType)
                return spb
        }</span>

        <span class="cov7" title="5">if !risk.IsValid() </span><span class="cov0" title="0">{
                spb.err = fmt.Errorf("invalid risk level: %s", risk)
                return spb
        }</span>

        <span class="cov7" title="5">if risk.IsHigherThan(domain.RiskHigh) &amp;&amp; spb.err == nil </span><span class="cov1" title="1">{
                spb.err = fmt.Errorf("cannot add critical risk operation to profile")
                return spb
        }</span>

        <span class="cov6" title="4">op := SafeOperation{
                name:    opType,
                risk:    risk,
                enabled: true,
                backup:  risk.IsHigherOrEqualThan(domain.RiskMedium),
        }

        spb.operations = append(spb.operations, op)
        if risk.IsHigherThan(spb.maxRisk) </span><span class="cov1" title="1">{
                spb.maxRisk = risk
        }</span>

        <span class="cov6" title="4">return spb</span>
}

// Done finishes profile building
func (spb *SafeProfileBuilder) Done() *SafeConfigBuilder <span class="cov7" title="6">{
        if spb.err != nil </span><span class="cov1" title="1">{
                spb.config.err = spb.err
                return spb.config
        }</span>

        <span class="cov7" title="5">if len(spb.operations) == 0 </span><span class="cov1" title="1">{
                spb.config.err = fmt.Errorf("profile must have at least one operation")
                return spb.config
        }</span>

        <span class="cov6" title="4">if spb.maxRisk.IsHigherThan(domain.RiskHigh) </span><span class="cov0" title="0">{
                spb.config.err = fmt.Errorf("profile risk level cannot exceed HIGH")
                return spb.config
        }</span>

        <span class="cov6" title="4">profile := SafeProfile{
                name:        spb.name,
                description: spb.description,
                operations:  spb.operations,
                maxRisk:     spb.maxRisk,
        }

        spb.config.profiles = append(spb.config.profiles, profile)
        if spb.maxRisk &gt; spb.config.maxRisk </span><span class="cov1" title="1">{
                spb.config.maxRisk = spb.maxRisk
        }</span>

        <span class="cov6" title="4">return spb.config</span>
}
</pre>

      <pre class="file" id="file26" style="display: none">package config

import (
        "fmt"
        "strings"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// ConfigSanitizer provides configuration sanitization and normalization
type ConfigSanitizer struct {
        rules *SanitizationRules
}

// SanitizationRules defines how to sanitize different configuration aspects
type SanitizationRules struct {
        // Path sanitization
        NormalizePaths bool `json:"normalize_paths"`
        ExpandHomeDir  bool `json:"expand_home_dir"`
        ValidateExists bool `json:"validate_exists"`

        // Numeric sanitization
        ClampValues      bool `json:"clamp_values"`
        RoundPercentages bool `json:"round_percentages"`

        // String sanitization
        TrimWhitespace bool `json:"trim_whitespace"`
        NormalizeCase  bool `json:"normalize_case"`

        // Structural sanitization
        SortArrays       bool `json:"sort_arrays"`
        RemoveDuplicates bool `json:"remove_duplicates"`
        AddDefaults      bool `json:"add_defaults"`

        // Safety defaults
        DefaultSafeMode       bool          `json:"default_safe_mode"`
        DefaultMaxDiskUsage   int           `json:"default_max_disk_usage"`
        DefaultBackup         time.Duration `json:"default_backup"`
        DefaultProtectedPaths []string      `json:"default_protected_paths"`
}

// SanitizationChange represents a specific field change with context
type SanitizationChange struct {
        Original  any       `json:"original"`
        Sanitized any       `json:"sanitized"`
        Reason    string    `json:"reason"`
        Timestamp time.Time `json:"timestamp"`
}

// SanitizationResult contains sanitization outcomes
type SanitizationResult struct {
        SanitizedFields []string                       `json:"sanitized_fields"`
        Warnings        []SanitizationWarning          `json:"warnings"`
        Changes         map[string]*SanitizationChange `json:"changes"`
        Timestamp       time.Time                      `json:"timestamp"`
}

// SanitizationWarning represents a sanitization warning
type SanitizationWarning struct {
        Field     string `json:"field"`
        Original  any    `json:"original"`
        Sanitized any    `json:"sanitized"`
        Reason    string `json:"reason"`
}

// NewConfigSanitizer creates a configuration sanitizer with default rules
func NewConfigSanitizer() *ConfigSanitizer <span class="cov9" title="10">{
        return &amp;ConfigSanitizer{
                rules: getDefaultSanitizationRules(),
        }
}</span>

// NewConfigSanitizerWithRules creates a sanitizer with custom rules
func NewConfigSanitizerWithRules(rules *SanitizationRules) *ConfigSanitizer <span class="cov0" title="0">{
        return &amp;ConfigSanitizer{
                rules: rules,
        }
}</span>

// SanitizeConfig performs comprehensive configuration sanitization
func (cs *ConfigSanitizer) SanitizeConfig(cfg *domain.Config, validationResult *ValidationResult) <span class="cov5" title="4">{
        start := time.Now()
        defer func() </span><span class="cov5" title="4">{
                // Update validation result duration if provided
                if validationResult != nil </span><span class="cov5" title="4">{
                        validationResult.Duration = time.Since(start)
                }</span>
        }()

        <span class="cov5" title="4">result := &amp;SanitizationResult{
                SanitizedFields: []string{},
                Warnings:        []SanitizationWarning{},
                Changes:         make(map[string]*SanitizationChange),
                Timestamp:       time.Now(),
        }

        // Sanitize basic fields
        cs.sanitizeBasicFields(cfg, result)

        // Sanitize protected paths
        cs.sanitizeProtectedPaths(cfg, result)

        // Sanitize profiles
        cs.sanitizeProfiles(cfg, result)

        // Apply defaults
        if cs.rules.AddDefaults </span><span class="cov5" title="4">{
                cs.applyDefaults(cfg, result)
        }</span>

        // Update validation result with sanitization info
        <span class="cov5" title="4">if validationResult != nil </span><span class="cov5" title="4">{
                validationResult.Sanitized = &amp;ValidationSanitizedData{
                        FieldsModified: result.SanitizedFields,
                        RulesApplied:   []string{"basic_sanitization", "default_values"},
                        Metadata: map[string]string{
                                "sanitized_count": fmt.Sprintf("%d", len(result.SanitizedFields)),
                                "warnings_count":  fmt.Sprintf("%d", len(result.Warnings)),
                        },
                }

                // Copy sanitization warnings to validation result
                for _, warning := range result.Warnings </span><span class="cov1" title="1">{
                        validationResult.Warnings = append(validationResult.Warnings, ValidationWarning{
                                Field:      warning.Field,
                                Message:    warning.Reason,
                                Suggestion: fmt.Sprintf("Value was changed from %v to %v", warning.Original, warning.Sanitized),
                                Context: &amp;ValidationContext{
                                        Metadata: map[string]string{
                                                "original":  fmt.Sprintf("%v", warning.Original),
                                                "sanitized": fmt.Sprintf("%v", warning.Sanitized),
                                                "field":     warning.Field,
                                        },
                                },
                        })
                }</span>
        }
}

// sanitizeBasicFields sanitizes basic configuration fields
func (cs *ConfigSanitizer) sanitizeBasicFields(cfg *domain.Config, result *SanitizationResult) <span class="cov5" title="4">{
        // Sanitize version
        if cs.rules.TrimWhitespace </span><span class="cov5" title="4">{
                original := cfg.Version
                cfg.Version = strings.TrimSpace(cfg.Version)
                if original != cfg.Version </span><span class="cov3" title="2">{
                        result.addChange("version", original, cfg.Version, "trimmed whitespace")
                }</span>
        }

        <span class="cov5" title="4">if cs.rules.NormalizeCase </span><span class="cov0" title="0">{
                original := cfg.Version
                cfg.Version = strings.ToLower(cfg.Version)
                if original != cfg.Version </span><span class="cov0" title="0">{
                        result.addChange("version", original, cfg.Version, "normalized to lowercase")
                }</span>
        }

        // Sanitize max_disk_usage
        <span class="cov5" title="4">if cs.rules.ClampValues </span><span class="cov5" title="4">{
                original := cfg.MaxDiskUsage
                if cfg.MaxDiskUsage &lt; MinDiskUsagePercent </span><span class="cov0" title="0">{
                        cfg.MaxDiskUsage = MinDiskUsagePercent
                        result.addWarning("max_disk_usage", original, cfg.MaxDiskUsage, "clamped to minimum value")
                }</span> else<span class="cov5" title="4"> if cfg.MaxDiskUsage &gt; MaxDiskUsagePercent </span><span class="cov1" title="1">{
                        cfg.MaxDiskUsage = MaxDiskUsagePercent
                        result.addWarning("max_disk_usage", original, cfg.MaxDiskUsage, "clamped to maximum value")
                }</span>
        }

        <span class="cov5" title="4">if cs.rules.RoundPercentages </span><span class="cov5" title="4">{
                original := cfg.MaxDiskUsage
                cfg.MaxDiskUsage = int(float64(cfg.MaxDiskUsage+RoundingIncrement/2)/RoundingIncrement) * RoundingIncrement // Round to nearest increment
                if original != cfg.MaxDiskUsage </span><span class="cov3" title="2">{
                        result.addChange("max_disk_usage", original, cfg.MaxDiskUsage, "rounded to nearest 10%")
                }</span>
        }

        // Ensure safe mode defaults
        <span class="cov5" title="4">if cs.rules.DefaultSafeMode &amp;&amp; !cfg.SafeMode </span><span class="cov0" title="0">{
                original := cfg.SafeMode
                cfg.SafeMode = true
                result.addChange("safe_mode", original, cfg.SafeMode, "enabled safe mode for security")
        }</span>
}

// Helper methods

func (r *SanitizationResult) addChange(field string, original, sanitized any, reason string) <span class="cov10" title="13">{
        r.SanitizedFields = append(r.SanitizedFields, field)
        r.Changes[field] = &amp;SanitizationChange{
                Original:  original,
                Sanitized: sanitized,
                Reason:    reason,
                Timestamp: time.Now(),
        }
}</span>

func (r *SanitizationResult) addWarning(field string, original, sanitized any, reason string) <span class="cov1" title="1">{
        r.Warnings = append(r.Warnings, SanitizationWarning{
                Field:     field,
                Original:  original,
                Sanitized: sanitized,
                Reason:    reason,
        })
}</span>

// getDefaultSanitizationRules returns default sanitization configuration
func getDefaultSanitizationRules() *SanitizationRules <span class="cov9" title="10">{
        return &amp;SanitizationRules{
                NormalizePaths:        true,
                ExpandHomeDir:         true,
                ValidateExists:        false, // Don't validate exists by default as paths may not exist yet
                ClampValues:           true,
                RoundPercentages:      true,
                TrimWhitespace:        true,
                NormalizeCase:         false, // Preserve case for paths and names
                SortArrays:            true,
                RemoveDuplicates:      true,
                AddDefaults:           true,
                DefaultSafeMode:       true,
                DefaultMaxDiskUsage:   50,
                DefaultBackup:         24 * time.Hour,
                DefaultProtectedPaths: []string{"/System", "/Applications", "/Library"},
        }
}</span>
</pre>

      <pre class="file" id="file27" style="display: none">package config

import (
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeHomebrewSettings sanitizes Homebrew settings
func (cs *ConfigSanitizer) sanitizeHomebrewSettings(fieldPrefix string, settings *domain.HomebrewSettings, result *SanitizationResult) <span class="cov8" title="1">{
        if settings == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Sanitize prune field
        <span class="cov8" title="1">if cs.rules.TrimWhitespace &amp;&amp; settings.Prune != "" </span><span class="cov8" title="1">{
                original := settings.Prune
                settings.Prune = strings.TrimSpace(settings.Prune)
                if original != settings.Prune </span><span class="cov8" title="1">{
                        result.addChange(fieldPrefix+".prune", original, settings.Prune, "trimmed whitespace")
                }</span>
        }

        <span class="cov8" title="1">result.SanitizedFields = append(result.SanitizedFields, fieldPrefix+".homebrew")</span>
}
</pre>

      <pre class="file" id="file28" style="display: none">package config

import (
        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeNixGenerationsSettings sanitizes Nix generations settings
func (cs *ConfigSanitizer) sanitizeNixGenerationsSettings(fieldPrefix string, settings *domain.NixGenerationsSettings, result *SanitizationResult) <span class="cov10" title="2">{
        if settings == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Sanitize generations range (ensure 1-10)
        <span class="cov10" title="2">original := settings.Generations
        if settings.Generations &lt; 1 </span><span class="cov0" title="0">{
                settings.Generations = 1
                result.addChange(fieldPrefix+".generations", original, settings.Generations, "clamped to minimum value")
        }</span> else<span class="cov10" title="2"> if settings.Generations &gt; 10 </span><span class="cov0" title="0">{
                settings.Generations = 10
                result.addChange(fieldPrefix+".generations", original, settings.Generations, "clamped to maximum value")
        }</span>

        <span class="cov10" title="2">result.SanitizedFields = append(result.SanitizedFields, fieldPrefix+".nix_generations")</span>
}
</pre>

      <pre class="file" id="file29" style="display: none">package config

import (
        "fmt"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeOperationSettings sanitizes operation settings with type safety
func (cs *ConfigSanitizer) sanitizeOperationSettings(fieldPrefix, operationName string, settings *domain.OperationSettings, result *SanitizationResult) <span class="cov10" title="5">{
        opType := domain.GetOperationType(operationName)

        // Validate settings first
        if err := settings.ValidateSettings(opType); err != nil </span><span class="cov0" title="0">{
                // Convert validation errors to warnings since the result type doesn't have an Errors field
                if validationErr, ok := err.(*domain.ValidationError); ok </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, SanitizationWarning{
                                Field:     fieldPrefix + "." + validationErr.Field,
                                Original:  validationErr.Value,
                                Sanitized: validationErr.Value,
                                Reason:    validationErr.Message,
                        })
                }</span> else<span class="cov0" title="0"> {
                        result.Warnings = append(result.Warnings, SanitizationWarning{
                                Field:     fieldPrefix,
                                Original:  "settings validation",
                                Sanitized: "settings validation",
                                Reason:    fmt.Sprintf("validation error: %v", err),
                        })
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Type-aware sanitization based on operation type
        <span class="cov10" title="5">switch opType </span>{
        case domain.OperationTypeNixGenerations:<span class="cov4" title="2">
                cs.sanitizeNixGenerationsSettings(fieldPrefix, settings.NixGenerations, result)</span>

        case domain.OperationTypeTempFiles:<span class="cov1" title="1">
                cs.sanitizeTempFilesSettings(fieldPrefix, settings.TempFiles, result)</span>

        case domain.OperationTypeHomebrew:<span class="cov1" title="1">
                cs.sanitizeHomebrewSettings(fieldPrefix, settings.Homebrew, result)</span>

        case domain.OperationTypeSystemTemp:<span class="cov1" title="1">
                cs.sanitizeSystemTempSettings(fieldPrefix, settings.SystemTemp, result)</span>

        default:<span class="cov0" title="0">
                // For custom operation types, just record that they were processed
                result.Warnings = append(result.Warnings, SanitizationWarning{
                        Field:     fieldPrefix,
                        Original:  "custom operation settings",
                        Sanitized: "custom operation settings",
                        Reason:    "custom operation type - no specific sanitization applied",
                })</span>
        }
}
</pre>

      <pre class="file" id="file30" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeProtectedPaths sanitizes protected paths array
func (cs *ConfigSanitizer) sanitizeProtectedPaths(cfg *domain.Config, result *SanitizationResult) <span class="cov5" title="4">{
        sanitizedPaths := make([]string, 0, len(cfg.Protected))

        for i, path := range cfg.Protected </span><span class="cov8" title="11">{
                original := path

                // Trim whitespace
                if cs.rules.TrimWhitespace </span><span class="cov8" title="11">{
                        path = strings.TrimSpace(path)
                }</span>

                // Expand home directory
                <span class="cov8" title="11">if cs.rules.ExpandHomeDir </span><span class="cov8" title="11">{
                        if strings.HasPrefix(path, "~/") </span><span class="cov0" title="0">{
                                home, err := os.UserHomeDir()
                                if err == nil </span><span class="cov0" title="0">{
                                        path = filepath.Join(home, path[2:])
                                }</span>
                        }
                }

                // Normalize path
                <span class="cov8" title="11">if cs.rules.NormalizePaths </span><span class="cov8" title="11">{
                        path = filepath.Clean(path)
                }</span>

                // Validate absolute path requirement
                <span class="cov8" title="11">if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, SanitizationWarning{
                                Field:     fmt.Sprintf("protected[%d]", i),
                                Original:  original,
                                Sanitized: path,
                                Reason:    fmt.Sprintf("protected path must be absolute: %s", original),
                        })
                        continue</span> // Skip processing invalid path
                }

                // Validate existence if enabled
                <span class="cov8" title="11">if cs.rules.ValidateExists </span><span class="cov0" title="0">{
                        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, SanitizationWarning{
                                        Field:     fmt.Sprintf("protected[%d]", i),
                                        Original:  original,
                                        Sanitized: path,
                                        Reason:    "path does not exist but will be protected",
                                })
                        }</span>
                }

                <span class="cov8" title="11">if original != path </span><span class="cov0" title="0">{
                        result.addChange(fmt.Sprintf("protected[%d]", i), original, path, "path normalized")
                }</span>

                <span class="cov8" title="11">sanitizedPaths = append(sanitizedPaths, path)</span>
        }

        // Remove duplicates
        <span class="cov5" title="4">if cs.rules.RemoveDuplicates </span><span class="cov5" title="4">{
                sanitizedPaths = cs.removeDuplicates(sanitizedPaths)
        }</span>

        // Sort paths
        <span class="cov5" title="4">if cs.rules.SortArrays </span><span class="cov5" title="4">{
                cs.sortStrings(sanitizedPaths)
        }</span>

        <span class="cov5" title="4">cfg.Protected = sanitizedPaths</span>
}

// Helper methods for path sanitization

func (cs *ConfigSanitizer) removeDuplicates(slice []string) []string <span class="cov6" title="6">{
        seen := make(map[string]bool)
        result := []string{}

        for _, item := range slice </span><span class="cov10" title="18">{
                if !seen[item] </span><span class="cov9" title="14">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov6" title="6">return result</span>
}

func (cs *ConfigSanitizer) sortStrings(slice []string) <span class="cov6" title="6">{
        sort.Strings(slice)
}</span>
</pre>

      <pre class="file" id="file31" style="display: none">package config

import (
        "fmt"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeProfiles sanitizes profiles and their operations
func (cs *ConfigSanitizer) sanitizeProfiles(cfg *domain.Config, result *SanitizationResult) <span class="cov7" title="4">{
        for name, profile := range cfg.Profiles </span><span class="cov7" title="5">{
                // Sanitize profile name
                if cs.rules.TrimWhitespace </span><span class="cov7" title="5">{
                        original := profile.Name
                        profile.Name = strings.TrimSpace(profile.Name)
                        if original != profile.Name </span><span class="cov4" title="2">{
                                result.addChange(fmt.Sprintf("profiles.%s.name", name), original, profile.Name, "trimmed whitespace")
                        }</span>
                }

                // Sanitize profile description
                <span class="cov7" title="5">if cs.rules.TrimWhitespace </span><span class="cov7" title="5">{
                        original := profile.Description
                        profile.Description = strings.TrimSpace(profile.Description)
                        if original != profile.Description </span><span class="cov0" title="0">{
                                result.addChange(fmt.Sprintf("profiles.%s.description", name), original, profile.Description, "trimmed whitespace")
                        }</span>
                }

                // Sanitize operations
                <span class="cov7" title="5">cs.sanitizeOperations(name, profile.Operations, result)</span>
        }
}

// sanitizeOperations sanitizes cleanup operations
func (cs *ConfigSanitizer) sanitizeOperations(profileName string, operations []domain.CleanupOperation, result *SanitizationResult) <span class="cov7" title="5">{
        for i := range operations </span><span class="cov10" title="8">{
                op := &amp;operations[i] // Get pointer to mutate slice element in place
                fieldPrefix := fmt.Sprintf("profiles.%s.operations[%d]", profileName, i)

                // Sanitize operation name
                if cs.rules.TrimWhitespace </span><span class="cov10" title="8">{
                        original := op.Name
                        op.Name = strings.TrimSpace(op.Name)
                        if original != op.Name </span><span class="cov0" title="0">{
                                result.addChange(fieldPrefix+".name", original, op.Name, "trimmed whitespace")
                        }</span>
                }

                // Sanitize operation description
                <span class="cov10" title="8">if cs.rules.TrimWhitespace </span><span class="cov10" title="8">{
                        original := op.Description
                        op.Description = strings.TrimSpace(op.Description)
                        if original != op.Description </span><span class="cov1" title="1">{
                                result.addChange(fieldPrefix+".description", original, op.Description, "trimmed whitespace")
                        }</span>
                }

                // Sanitize settings
                <span class="cov10" title="8">if op.Settings != nil </span><span class="cov7" title="5">{
                        cs.sanitizeOperationSettings(fieldPrefix+".settings", op.Name, op.Settings, result)
                }</span>
        }
}

// applyDefaults applies default values to missing fields
func (cs *ConfigSanitizer) applyDefaults(cfg *domain.Config, result *SanitizationResult) <span class="cov7" title="4">{
        // Set default version if empty
        if cfg.Version == "" </span><span class="cov0" title="0">{
                cfg.Version = "1.0.0"
                result.addChange("version", "", cfg.Version, "applied default version")
        }</span>

        // Set default max disk usage
        <span class="cov7" title="4">if cfg.MaxDiskUsage == 0 </span><span class="cov0" title="0">{
                cfg.MaxDiskUsage = cs.rules.DefaultMaxDiskUsage
                result.addChange("max_disk_usage", 0, cfg.MaxDiskUsage, "applied default max disk usage")
        }</span>

        // Ensure default protected paths using centralized source
        <span class="cov7" title="4">if len(cfg.Protected) == 0 </span><span class="cov0" title="0">{
                cfg.Protected = cs.rules.DefaultProtectedPaths
                result.addChange("protected", []string{}, cfg.Protected, "applied default protected paths")
        }</span>

        // Apply defaults to profiles
        <span class="cov7" title="4">for name, profile := range cfg.Profiles </span><span class="cov7" title="5">{
                if profile.Name == "" </span><span class="cov0" title="0">{
                        profile.Name = name
                        result.addChange(fmt.Sprintf("profiles.%s.name", name), "", profile.Name, "applied default profile name")
                }</span>

                <span class="cov7" title="5">if profile.Description == "" </span><span class="cov0" title="0">{
                        profile.Description = "Auto-generated profile description"
                        result.addChange(fmt.Sprintf("profiles.%s.description", name), "", profile.Description, "applied default description")
                }</span>

                // Apply defaults to operations
                <span class="cov7" title="5">for i := range profile.Operations </span><span class="cov10" title="8">{
                        op := &amp;profile.Operations[i] // Get pointer to mutate slice element in place
                        fieldPrefix := fmt.Sprintf("profiles.%s.operations[%d]", name, i)

                        if op.Settings == nil </span><span class="cov5" title="3">{
                                opType := domain.GetOperationType(op.Name)
                                op.Settings = domain.DefaultSettings(opType)
                                result.addChange(fieldPrefix+".settings", nil, op.Settings, "initialized type-safe settings")
                        }</span>
                }
        }
}
</pre>

      <pre class="file" id="file32" style="display: none">package config

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeSystemTempSettings sanitizes system temp settings
func (cs *ConfigSanitizer) sanitizeSystemTempSettings(fieldPrefix string, settings *domain.SystemTempSettings, result *SanitizationResult) <span class="cov1" title="1">{
        if settings == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Sanitize paths array
        <span class="cov1" title="1">if len(settings.Paths) &gt; 0 </span><span class="cov1" title="1">{
                sanitizedPaths := make([]string, 0, len(settings.Paths))
                for i, path := range settings.Paths </span><span class="cov10" title="4">{
                        original := path

                        if cs.rules.TrimWhitespace </span><span class="cov10" title="4">{
                                path = strings.TrimSpace(path)
                        }</span>

                        <span class="cov10" title="4">if cs.rules.NormalizePaths </span><span class="cov10" title="4">{
                                path = filepath.Clean(path)
                        }</span>

                        // Validate absolute path requirement
                        <span class="cov10" title="4">if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, SanitizationWarning{
                                        Field:     fmt.Sprintf("%s.paths[%d]", fieldPrefix, i),
                                        Original:  original,
                                        Sanitized: path,
                                        Reason:    fmt.Sprintf("system temp path must be absolute: %s", original),
                                })
                                continue</span> // Skip processing invalid path
                        }

                        <span class="cov10" title="4">if original != path </span><span class="cov1" title="1">{
                                result.addChange(fmt.Sprintf("%s.paths[%d]", fieldPrefix, i), original, path, "sanitized system temp path")
                        }</span>

                        <span class="cov10" title="4">sanitizedPaths = append(sanitizedPaths, path)</span>
                }

                // Remove duplicates and sort
                <span class="cov1" title="1">if cs.rules.RemoveDuplicates </span><span class="cov1" title="1">{
                        sanitizedPaths = cs.removeDuplicates(sanitizedPaths)
                }</span>
                <span class="cov1" title="1">if cs.rules.SortArrays </span><span class="cov1" title="1">{
                        cs.sortStrings(sanitizedPaths)
                }</span>

                <span class="cov1" title="1">settings.Paths = sanitizedPaths</span>
        }

        // Sanitize older_than duration
        <span class="cov1" title="1">if cs.rules.TrimWhitespace &amp;&amp; settings.OlderThan != "" </span><span class="cov1" title="1">{
                original := settings.OlderThan
                settings.OlderThan = strings.TrimSpace(settings.OlderThan)
                if original != settings.OlderThan </span><span class="cov0" title="0">{
                        result.addChange(fieldPrefix+".older_than", original, settings.OlderThan, "trimmed whitespace")
                }</span>

                // Validate duration format using custom parser
                <span class="cov1" title="1">if _, err := domain.ParseCustomDuration(settings.OlderThan); err != nil </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, SanitizationWarning{
                                Field:     fieldPrefix + ".older_than",
                                Original:  settings.OlderThan,
                                Sanitized: settings.OlderThan,
                                Reason:    fmt.Sprintf("invalid duration format: %v", err),
                        })
                }</span>
        }

        <span class="cov1" title="1">result.SanitizedFields = append(result.SanitizedFields, fieldPrefix+".system_temp")</span>
}
</pre>

      <pre class="file" id="file33" style="display: none">package config

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// sanitizeTempFilesSettings sanitizes temporary files settings
func (cs *ConfigSanitizer) sanitizeTempFilesSettings(fieldPrefix string, settings *domain.TempFilesSettings, result *SanitizationResult) <span class="cov1" title="1">{
        if settings == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Sanitize older_than duration
        <span class="cov1" title="1">if cs.rules.TrimWhitespace &amp;&amp; settings.OlderThan != "" </span><span class="cov1" title="1">{
                original := settings.OlderThan
                settings.OlderThan = strings.TrimSpace(settings.OlderThan)
                if original != settings.OlderThan </span><span class="cov1" title="1">{
                        result.addChange(fieldPrefix+".older_than", original, settings.OlderThan, "trimmed whitespace")
                }</span>

                // Validate duration format using custom parser
                <span class="cov1" title="1">if _, err := domain.ParseCustomDuration(settings.OlderThan); err != nil </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, SanitizationWarning{
                                Field:     fieldPrefix + ".older_than",
                                Original:  settings.OlderThan,
                                Sanitized: settings.OlderThan,
                                Reason:    fmt.Sprintf("invalid duration format: %v", err),
                        })
                }</span>
        }

        // Sanitize excludes array
        <span class="cov1" title="1">if len(settings.Excludes) &gt; 0 </span><span class="cov1" title="1">{
                sanitizedExcludes := make([]string, 0, len(settings.Excludes))
                for i, exclude := range settings.Excludes </span><span class="cov10" title="3">{
                        original := exclude

                        if cs.rules.TrimWhitespace </span><span class="cov10" title="3">{
                                exclude = strings.TrimSpace(exclude)
                        }</span>

                        <span class="cov10" title="3">if cs.rules.NormalizePaths </span><span class="cov10" title="3">{
                                exclude = filepath.Clean(exclude)
                        }</span>

                        <span class="cov10" title="3">if original != exclude </span><span class="cov0" title="0">{
                                result.addChange(fmt.Sprintf("%s.excludes[%d]", fieldPrefix, i), original, exclude, "sanitized exclude path")
                        }</span>

                        <span class="cov10" title="3">sanitizedExcludes = append(sanitizedExcludes, exclude)</span>
                }

                // Remove duplicates and sort
                <span class="cov1" title="1">if cs.rules.RemoveDuplicates </span><span class="cov1" title="1">{
                        sanitizedExcludes = cs.removeDuplicates(sanitizedExcludes)
                }</span>
                <span class="cov1" title="1">if cs.rules.SortArrays </span><span class="cov1" title="1">{
                        cs.sortStrings(sanitizedExcludes)
                }</span>

                <span class="cov1" title="1">settings.Excludes = sanitizedExcludes</span>
        }

        <span class="cov1" title="1">result.SanitizedFields = append(result.SanitizedFields, fieldPrefix+".temp_files")</span>
}
</pre>

      <pre class="file" id="file34" style="display: none">package config

import (
        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// TypeSafeValidationRules defines validation constraints with compile-time type safety
type TypeSafeValidationRules struct {
        // Numeric Constraints - using proper typed bounds
        MaxDiskUsage      *NumericValidationRule `json:"max_disk_usage"`
        MinProtectedPaths *NumericValidationRule `json:"min_protected_paths"`
        MaxProfiles       *NumericValidationRule `json:"max_profiles"`
        MaxOperations     *NumericValidationRule `json:"max_operations"`

        // String Constraints - using proper typed patterns
        ProfileNamePattern *StringValidationRule `json:"profile_name_pattern"`
        PathPattern        *StringValidationRule `json:"path_pattern"`

        // Array Constraints - using proper typed constraints
        UniquePaths    bool `json:"unique_paths"`
        UniqueProfiles bool `json:"unique_profiles"`

        // Safety Constraints - using typed domain values
        ProtectedSystemPaths  []string `json:"protected_system_paths"`
        DefaultProtectedPaths []string `json:"default_protected_paths"`
        RequireSafeMode       bool     `json:"require_safe_mode"`

        // Risk Constraints - using type-safe enums
        MaxRiskLevel   domain.RiskLevelType `json:"max_risk_level"`
        BackupRequired domain.RiskLevelType `json:"backup_required"`
}

// NumericValidationRule provides type-safe numeric validation
type NumericValidationRule struct {
        Required bool   `json:"required"`
        Min      *int   `json:"min,omitempty"`
        Max      *int   `json:"max,omitempty"`
        Message  string `json:"message,omitempty"`
}

// StringValidationRule provides type-safe string validation
type StringValidationRule struct {
        Required bool   `json:"required"`
        Pattern  string `json:"pattern,omitempty"`
        Message  string `json:"message,omitempty"`
}

// NewTypeSafeValidationRules creates type-safe validation rules with defaults
func NewTypeSafeValidationRules() *TypeSafeValidationRules <span class="cov0" title="0">{
        // Extract constants to variables for reference
        minUsage := 10
        maxUsage := 95
        minPaths := 1
        maxProfiles := 10
        maxOps := 20

        return &amp;TypeSafeValidationRules{
                MaxDiskUsage: &amp;NumericValidationRule{
                        Required: true,
                        Min:      &amp;minUsage,
                        Max:      &amp;maxUsage,
                        Message:  "Max disk usage must be between 10% and 95%",
                },
                MinProtectedPaths: &amp;NumericValidationRule{
                        Required: true,
                        Min:      &amp;minPaths,
                        Message:  "At least one protected path is required",
                },
                MaxProfiles: &amp;NumericValidationRule{
                        Required: false,
                        Max:      &amp;maxProfiles,
                        Message:  "Consider limiting profiles to maintain clarity",
                },
                MaxOperations: &amp;NumericValidationRule{
                        Required: false,
                        Max:      &amp;maxOps,
                        Message:  "Consider limiting operations per profile for better maintainability",
                },
                ProfileNamePattern: &amp;StringValidationRule{
                        Required: true,
                        Pattern:  "^[a-zA-Z0-9_-]+$",
                        Message:  "Profile names must be alphanumeric with underscores and hyphens",
                },
                PathPattern: &amp;StringValidationRule{
                        Required: true,
                        Pattern:  "^/.*",
                        Message:  "Paths must be absolute (starting with '/')",
                },
                UniquePaths:    true,
                UniqueProfiles: true,
                ProtectedSystemPaths: []string{
                        "/",
                        "/System",
                        "/Applications",
                        "/Library",
                        "/usr",
                        "/etc",
                        "/var",
                        "/bin",
                        "/sbin",
                },
                DefaultProtectedPaths: []string{
                        "/System",
                        "/Applications",
                        "/Library",
                },
                RequireSafeMode: true,
                MaxRiskLevel:    domain.RiskHigh,
                BackupRequired:  domain.RiskMedium,
        }
}</span>

// GetTypeSafeSchemaRules returns type-safe schema rules for external consumption
func (tsvr *TypeSafeValidationRules) GetTypeSafeSchemaRules() *TypeSafeValidationRules <span class="cov0" title="0">{
        // Deep copy to prevent external modifications
        copied := &amp;TypeSafeValidationRules{
                UniquePaths:     tsvr.UniquePaths,
                UniqueProfiles:  tsvr.UniqueProfiles,
                RequireSafeMode: tsvr.RequireSafeMode,
                MaxRiskLevel:    tsvr.MaxRiskLevel,
                BackupRequired:  tsvr.BackupRequired,
        }

        // Deep copy slices
        if tsvr.ProtectedSystemPaths != nil </span><span class="cov0" title="0">{
                copied.ProtectedSystemPaths = make([]string, len(tsvr.ProtectedSystemPaths))
                copy(copied.ProtectedSystemPaths, tsvr.ProtectedSystemPaths)
        }</span>

        <span class="cov0" title="0">if tsvr.DefaultProtectedPaths != nil </span><span class="cov0" title="0">{
                copied.DefaultProtectedPaths = make([]string, len(tsvr.DefaultProtectedPaths))
                copy(copied.DefaultProtectedPaths, tsvr.DefaultProtectedPaths)
        }</span>

        // Deep copy numeric rules
        <span class="cov0" title="0">if tsvr.MaxDiskUsage != nil </span><span class="cov0" title="0">{
                copied.MaxDiskUsage = tsvr.copyNumericRule(tsvr.MaxDiskUsage)
        }</span>
        <span class="cov0" title="0">if tsvr.MinProtectedPaths != nil </span><span class="cov0" title="0">{
                copied.MinProtectedPaths = tsvr.copyNumericRule(tsvr.MinProtectedPaths)
        }</span>
        <span class="cov0" title="0">if tsvr.MaxProfiles != nil </span><span class="cov0" title="0">{
                copied.MaxProfiles = tsvr.copyNumericRule(tsvr.MaxProfiles)
        }</span>
        <span class="cov0" title="0">if tsvr.MaxOperations != nil </span><span class="cov0" title="0">{
                copied.MaxOperations = tsvr.copyNumericRule(tsvr.MaxOperations)
        }</span>

        // Deep copy string rules
        <span class="cov0" title="0">if tsvr.ProfileNamePattern != nil </span><span class="cov0" title="0">{
                copied.ProfileNamePattern = tsvr.copyStringRule(tsvr.ProfileNamePattern)
        }</span>
        <span class="cov0" title="0">if tsvr.PathPattern != nil </span><span class="cov0" title="0">{
                copied.PathPattern = tsvr.copyStringRule(tsvr.PathPattern)
        }</span>

        <span class="cov0" title="0">return copied</span>
}

// Helper methods for deep copying
func (tsvr *TypeSafeValidationRules) copyNumericRule(rule *NumericValidationRule) *NumericValidationRule <span class="cov0" title="0">{
        copied := &amp;NumericValidationRule{
                Required: rule.Required,
                Message:  rule.Message,
        }
        if rule.Min != nil </span><span class="cov0" title="0">{
                min := *rule.Min
                copied.Min = &amp;min
        }</span>
        <span class="cov0" title="0">if rule.Max != nil </span><span class="cov0" title="0">{
                max := *rule.Max
                copied.Max = &amp;max
        }</span>
        <span class="cov0" title="0">return copied</span>
}

func (tsvr *TypeSafeValidationRules) copyStringRule(rule *StringValidationRule) *StringValidationRule <span class="cov0" title="0">{
        return &amp;StringValidationRule{
                Required: rule.Required,
                Pattern:  rule.Pattern,
                Message:  rule.Message,
        }
}</span>
</pre>

      <pre class="file" id="file35" style="display: none">package config

import (
        "context"
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        pkgerrors "github.com/LarsArtmann/clean-wizard/internal/pkg/errors"
)

// ChangeOperation represents type of configuration change with type safety
type ChangeOperation string

const (
        OperationAdded    ChangeOperation = "added"
        OperationRemoved  ChangeOperation = "removed"
        OperationModified ChangeOperation = "modified"
)

// IsValid checks if change operation is valid
func (co ChangeOperation) IsValid() bool <span class="cov0" title="0">{
        switch co </span>{
        case OperationAdded, OperationRemoved, OperationModified:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// String returns string representation
func (co ChangeOperation) String() string <span class="cov0" title="0">{
        return string(co)
}</span>

// ValidationMiddleware provides comprehensive validation for configuration operations
type ValidationMiddleware struct {
        validator *ConfigValidator
        sanitizer *ConfigSanitizer
        logger    ValidationLogger
        options   *ValidationMiddlewareOptions
}

// ValidationLogger interface for validation logging
type ValidationLogger interface {
        LogValidation(result *ValidationResult)
        LogSanitization(result *SanitizationResult)
        LogError(field, operation string, err error)
}

// ValidationMiddlewareOptions provides configuration for validation middleware
type ValidationMiddlewareOptions struct {
        RequireSafeModeConfirmation bool   `json:"require_safe_mode_confirmation"`
        EnableDetailedLogging       bool   `json:"enable_detailed_logging"`
        Environment                 string `json:"environment"` // "development", "production", etc.
}

// DefaultValidationLogger provides default logging implementation
type DefaultValidationLogger struct {
        enableDetailedLogging bool
}

// ConfigChangeResult represents configuration change validation result
type ConfigChangeResult struct {
        IsValid   bool                `json:"is_valid"`
        Changes   []ConfigChange      `json:"changes"`
        Errors    []ValidationError   `json:"errors,omitempty"`
        Warnings  []ValidationWarning `json:"warnings,omitempty"`
        Timestamp time.Time           `json:"timestamp"`
}

// ConfigChange represents a single configuration change
type ConfigChange struct {
        Field     string           `json:"field"`
        OldValue  any              `json:"old_value"`
        NewValue  any              `json:"new_value"`
        Operation ChangeOperation  `json:"operation"`
        Risk      domain.RiskLevel `json:"risk"`
}

// ProfileOperationResult represents profile operation validation result
type ProfileOperationResult struct {
        IsValid   bool                     `json:"is_valid"`
        Operation *domain.CleanupOperation `json:"operation,omitempty"`
        Error     error                    `json:"error,omitempty"`
        Timestamp time.Time                `json:"timestamp"`
}

// NewDefaultValidationLogger creates a default validation logger
func NewDefaultValidationLogger(enableDetailed bool) *DefaultValidationLogger <span class="cov0" title="0">{
        return &amp;DefaultValidationLogger{
                enableDetailedLogging: enableDetailed,
        }
}</span>

// WithRequireSafeModeConfirmation enables safe mode confirmation requirement
func WithRequireSafeModeConfirmation(require bool) func(*ValidationMiddlewareOptions) <span class="cov0" title="0">{
        return func(opts *ValidationMiddlewareOptions) </span><span class="cov0" title="0">{
                opts.RequireSafeModeConfirmation = require
        }</span>
}

// WithEnvironment sets the environment for validation middleware
func WithEnvironment(env string) func(*ValidationMiddlewareOptions) <span class="cov0" title="0">{
        return func(opts *ValidationMiddlewareOptions) </span><span class="cov0" title="0">{
                opts.Environment = env
        }</span>
}

// WithDetailedLogging enables detailed logging in validation middleware
func WithDetailedLogging(enable bool) func(*ValidationMiddlewareOptions) <span class="cov0" title="0">{
        return func(opts *ValidationMiddlewareOptions) </span><span class="cov0" title="0">{
                opts.EnableDetailedLogging = enable
        }</span>
}

// LogValidation logs validation results
func (l *DefaultValidationLogger) LogValidation(result *ValidationResult) <span class="cov0" title="0">{
        if l.enableDetailedLogging </span><span class="cov0" title="0">{
                if result.IsValid </span><span class="cov0" title="0">{
                        fmt.Printf("‚úÖ Configuration validation passed in %v\n", result.Duration)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚ùå Configuration validation failed with %d errors\n", len(result.Errors))
                        for _, err := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s: %s\n", err.Field, err.Message)
                        }</span>
                }
        }
}

// LogSanitization logs sanitization results
func (l *DefaultValidationLogger) LogSanitization(result *SanitizationResult) <span class="cov0" title="0">{
        if l.enableDetailedLogging &amp;&amp; len(result.SanitizedFields) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("üîß Configuration sanitized %d fields\n", len(result.SanitizedFields))
        }</span>
}

// LogError logs validation errors
func (l *DefaultValidationLogger) LogError(field, operation string, err error) <span class="cov0" title="0">{
        fmt.Printf("‚ö†Ô∏è  Validation error in %s.%s: %v\n", operation, field, err)
}</span>

// NewValidationMiddleware creates comprehensive validation middleware
func NewValidationMiddleware() *ValidationMiddleware <span class="cov0" title="0">{
        return NewValidationMiddlewareWithOptions()
}</span>

// NewValidationMiddlewareWithOptions creates middleware with custom options
func NewValidationMiddlewareWithOptions(options ...func(*ValidationMiddlewareOptions)) *ValidationMiddleware <span class="cov0" title="0">{
        opts := &amp;ValidationMiddlewareOptions{
                RequireSafeModeConfirmation: false,
                EnableDetailedLogging:       true,
                Environment:                 "development",
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                opt(opts)
        }</span>

        <span class="cov0" title="0">validator := NewConfigValidator()
        logger := NewDefaultValidationLogger(opts.EnableDetailedLogging)

        return &amp;ValidationMiddleware{
                validator: validator,
                sanitizer: NewConfigSanitizer(),
                logger:    logger,
                options:   opts,
        }</span>
}

// NewValidationMiddlewareWithLogger creates middleware with custom logger
func NewValidationMiddlewareWithLogger(logger ValidationLogger) *ValidationMiddleware <span class="cov0" title="0">{
        return &amp;ValidationMiddleware{
                validator: NewConfigValidator(),
                sanitizer: NewConfigSanitizer(),
                logger:    logger,
                options: &amp;ValidationMiddlewareOptions{
                        RequireSafeModeConfirmation: false,
                        EnableDetailedLogging:       false,
                        Environment:                 "development",
                },
        }
}</span>

// ValidateAndLoadConfig loads and validates configuration with comprehensive checks
func (vm *ValidationMiddleware) ValidateAndLoadConfig(ctx context.Context) (*domain.Config, error) <span class="cov0" title="0">{
        // Load configuration using existing loader
        cfg, err := LoadWithContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleConfigError("ValidateAndLoadConfig", err)
        }</span>

        // Perform comprehensive validation
        <span class="cov0" title="0">validationResult := vm.validator.ValidateConfig(cfg)
        vm.logger.LogValidation(validationResult)

        if !validationResult.IsValid </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleValidationError("ValidateAndLoadConfig",
                        fmt.Errorf("validation failed: %s", vm.formatValidationErrors(validationResult.Errors)))
        }</span>

        // Configuration is valid
        <span class="cov0" title="0">return cfg, nil</span>
}

// ValidateAndSaveConfig validates and saves configuration
func (vm *ValidationMiddleware) ValidateAndSaveConfig(ctx context.Context, cfg *domain.Config) (*domain.Config, error) <span class="cov0" title="0">{
        // Perform comprehensive validation first
        validationResult := vm.validator.ValidateConfig(cfg)
        vm.logger.LogValidation(validationResult)

        if !validationResult.IsValid </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleValidationError("ValidateAndSaveConfig",
                        fmt.Errorf("validation failed: %s", vm.formatValidationErrors(validationResult.Errors)))
        }</span>

        // Save configuration
        <span class="cov0" title="0">if err := Save(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, pkgerrors.HandleConfigError("ValidateAndSaveConfig", err)
        }</span>

        // Return saved configuration
        <span class="cov0" title="0">return cfg, nil</span>
}

// ValidateConfigChange validates a specific configuration change
func (vm *ValidationMiddleware) ValidateConfigChange(ctx context.Context, current, proposed *domain.Config) *ConfigChangeResult <span class="cov0" title="0">{
        changeResult := &amp;ConfigChangeResult{
                IsValid:   true,
                Changes:   []ConfigChange{},
                Warnings:  []ValidationWarning{},
                Timestamp: time.Now(),
        }

        // Validate proposed configuration
        validationResult := vm.validator.ValidateConfig(proposed)
        changeResult.IsValid = validationResult.IsValid
        changeResult.Warnings = validationResult.Warnings

        if !validationResult.IsValid </span><span class="cov0" title="0">{
                changeResult.Errors = validationResult.Errors
                return changeResult
        }</span>

        // Analyze changes
        <span class="cov0" title="0">changes := vm.analyzeConfigChanges(current, proposed)
        changeResult.Changes = changes

        // Validate changes against business rules
        if err := vm.validateChangeBusinessRules(changes); err != nil </span><span class="cov0" title="0">{
                changeResult.IsValid = false
                changeResult.Errors = append(changeResult.Errors, ValidationError{
                        Field:    "business_rules",
                        Rule:     "validation",
                        Value:    err.Error(),
                        Message:  err.Error(),
                        Severity: SeverityError,
                })
                return changeResult
        }</span>

        <span class="cov0" title="0">return changeResult</span>
}

// ValidateProfileOperation validates a specific profile operation with type safety
func (vm *ValidationMiddleware) ValidateProfileOperation(ctx context.Context, profileName, operationName string, settings *domain.OperationSettings) *ProfileOperationResult <span class="cov0" title="0">{
        result := &amp;ProfileOperationResult{
                IsValid:   true,
                Timestamp: time.Now(),
        }

        // Validate profile name
        if err := vm.validator.validateProfileName(profileName); err != nil </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Error = err
                return result
        }</span>

        // Create temporary operation for validation
        <span class="cov0" title="0">tempOp := domain.CleanupOperation{
                Name:        operationName,
                Description: "Validation operation",
                RiskLevel:   domain.RiskLow, // Default to low for validation
                Enabled:     true,
                Settings:    settings,
        }

        // Validate operation
        if err := tempOp.Validate(); err != nil </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Error = err
                return result
        }</span>

        // Validate operation-specific settings
        <span class="cov0" title="0">if err := vm.validateOperationSettings(operationName, tempOp); err != nil </span><span class="cov0" title="0">{
                result.IsValid = false
                result.Error = err
                return result
        }</span>

        <span class="cov0" title="0">result.Operation = &amp;tempOp
        return result</span>
}

// formatValidationErrors formats validation errors into a readable string
func (vm *ValidationMiddleware) formatValidationErrors(errors []ValidationError) string <span class="cov0" title="0">{
        if len(errors) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("Validation failed (%d errors):", len(errors))
        for i, err := range errors </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n%d. %s: %s", i+1, err.Field, err.Message)
        }</span>
        <span class="cov0" title="0">return message</span>
}
</pre>

      <pre class="file" id="file36" style="display: none">package config

import (
        "fmt"
        "reflect"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// analyzeConfigChanges analyzes differences between current and proposed configuration
func (vm *ValidationMiddleware) analyzeConfigChanges(current, proposed *domain.Config) []ConfigChange <span class="cov0" title="0">{
        changes := []ConfigChange{}

        // Analyze basic fields
        if current.SafeMode != proposed.SafeMode </span><span class="cov0" title="0">{
                changes = append(changes, ConfigChange{
                        Field:     "safe_mode",
                        OldValue:  current.SafeMode,
                        NewValue:  proposed.SafeMode,
                        Operation: vm.getChangeOperation(current.SafeMode, proposed.SafeMode),
                        Risk:      vm.assessChangeRisk("safe_mode", current.SafeMode, proposed.SafeMode),
                })
        }</span>

        <span class="cov0" title="0">if current.MaxDiskUsage != proposed.MaxDiskUsage </span><span class="cov0" title="0">{
                changes = append(changes, ConfigChange{
                        Field:     "max_disk_usage",
                        OldValue:  current.MaxDiskUsage,
                        NewValue:  proposed.MaxDiskUsage,
                        Operation: vm.getChangeOperation(current.MaxDiskUsage, proposed.MaxDiskUsage),
                        Risk:      vm.assessChangeRisk("max_disk_usage", current.MaxDiskUsage, proposed.MaxDiskUsage),
                })
        }</span>

        // Analyze protected paths
        <span class="cov0" title="0">pathsChanges := vm.analyzePathChanges("protected", current.Protected, proposed.Protected)
        changes = append(changes, pathsChanges...)

        // Analyze profiles
        profilesChanges := vm.analyzeProfileChanges(current.Profiles, proposed.Profiles)
        changes = append(changes, profilesChanges...)

        return changes</span>
}

// analyzePathChanges analyzes path array changes
func (vm *ValidationMiddleware) analyzePathChanges(field string, current, proposed []string) []ConfigChange <span class="cov0" title="0">{
        changes := []ConfigChange{}

        currentSet := vm.makeStringSet(current)
        proposedSet := vm.makeStringSet(proposed)

        // Check for added paths
        for _, path := range proposed </span><span class="cov0" title="0">{
                if !currentSet[path] </span><span class="cov0" title="0">{
                        changes = append(changes, ConfigChange{
                                Field:     field,
                                OldValue:  nil,
                                NewValue:  path,
                                Operation: OperationAdded,
                                Risk:      domain.RiskLow,
                        })
                }</span>
        }

        // Check for removed paths
        <span class="cov0" title="0">for _, path := range current </span><span class="cov0" title="0">{
                if !proposedSet[path] </span><span class="cov0" title="0">{
                        changes = append(changes, ConfigChange{
                                Field:     field,
                                OldValue:  path,
                                NewValue:  nil,
                                Operation: OperationRemoved,
                                Risk:      domain.RiskHigh, // Removing protected paths is risky
                        })
                }</span>
        }

        <span class="cov0" title="0">return changes</span>
}

// analyzeProfileChanges analyzes profile map changes
func (vm *ValidationMiddleware) analyzeProfileChanges(current, proposed map[string]*domain.Profile) []ConfigChange <span class="cov0" title="0">{
        changes := []ConfigChange{}

        // Check for added profiles
        for name, profile := range proposed </span><span class="cov0" title="0">{
                if current[name] == nil </span><span class="cov0" title="0">{
                        // Guard against nil profile before accessing fields
                        if profile == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">changes = append(changes, ConfigChange{
                                Field:     fmt.Sprintf("profiles.%s", name),
                                OldValue:  nil,
                                NewValue:  profile.Name,
                                Operation: OperationAdded,
                                Risk:      vm.assessProfileRisk(profile),
                        })</span>
                }
        }

        // Check for removed profiles
        <span class="cov0" title="0">for name, profile := range current </span><span class="cov0" title="0">{
                if proposed[name] == nil </span><span class="cov0" title="0">{
                        changes = append(changes, ConfigChange{
                                Field:     fmt.Sprintf("profiles.%s", name),
                                OldValue:  profile.Name,
                                NewValue:  nil,
                                Operation: OperationRemoved,
                                Risk:      domain.RiskLow, // Removing profiles is generally safe
                        })
                }</span>
        }

        // Check for modified profiles
        <span class="cov0" title="0">for name, proposedProfile := range proposed </span><span class="cov0" title="0">{
                if currentProfile := current[name]; currentProfile != nil </span><span class="cov0" title="0">{
                        // Guard against nil proposed profile
                        if proposedProfile == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Deep comparison instead of just checking length
                        <span class="cov0" title="0">if currentProfile.Name != proposedProfile.Name ||
                                currentProfile.Description != proposedProfile.Description ||
                                !reflect.DeepEqual(currentProfile.Operations, proposedProfile.Operations) </span><span class="cov0" title="0">{
                                changes = append(changes, ConfigChange{
                                        Field:     fmt.Sprintf("profiles.%s", name),
                                        OldValue:  currentProfile.Name,
                                        NewValue:  proposedProfile.Name,
                                        Operation: OperationModified,
                                        Risk:      vm.assessProfileRisk(proposedProfile),
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return changes</span>
}

// Helper methods for change analysis

func (vm *ValidationMiddleware) getChangeOperation(old, new any) ChangeOperation <span class="cov0" title="0">{
        if old == nil &amp;&amp; new != nil </span><span class="cov0" title="0">{
                return OperationAdded
        }</span>
        <span class="cov0" title="0">if old != nil &amp;&amp; new == nil </span><span class="cov0" title="0">{
                return OperationRemoved
        }</span>
        <span class="cov0" title="0">return OperationModified</span>
}

func (vm *ValidationMiddleware) assessChangeRisk(field string, old, new any) domain.RiskLevel <span class="cov0" title="0">{
        switch field </span>{
        case "safe_mode":<span class="cov0" title="0">
                if old == true &amp;&amp; new == false </span><span class="cov0" title="0">{
                        return domain.RiskHigh
                }</span>
                <span class="cov0" title="0">return domain.RiskLow</span>
        case "max_disk_usage":<span class="cov0" title="0">
                // Safe type assertions
                oldVal, oldOk := old.(int)
                newVal, newOk := new.(int)
                if !oldOk || !newOk </span><span class="cov0" title="0">{
                        return domain.RiskHigh // Conservative risk for unexpected types
                }</span>
                <span class="cov0" title="0">if oldVal &lt; newVal </span><span class="cov0" title="0">{
                        return domain.RiskMedium
                }</span>
                <span class="cov0" title="0">return domain.RiskLow</span>
        case "protected":<span class="cov0" title="0">
                if new == nil </span><span class="cov0" title="0">{
                        return domain.RiskCritical
                }</span>
                <span class="cov0" title="0">return domain.RiskLow</span>
        default:<span class="cov0" title="0">
                return domain.RiskLow</span>
        }
}

func (vm *ValidationMiddleware) assessProfileRisk(profile *domain.Profile) domain.RiskLevel <span class="cov0" title="0">{
        // Guard against nil profile
        if profile == nil </span><span class="cov0" title="0">{
                return domain.RiskHigh
        }</span>

        <span class="cov0" title="0">maxRisk := domain.RiskLow
        for _, op := range profile.Operations </span><span class="cov0" title="0">{
                if op.RiskLevel == domain.RiskCritical </span><span class="cov0" title="0">{
                        return domain.RiskCritical
                }</span>
                <span class="cov0" title="0">if op.RiskLevel == domain.RiskHigh </span><span class="cov0" title="0">{
                        maxRisk = domain.RiskHigh
                }</span> else<span class="cov0" title="0"> if op.RiskLevel == domain.RiskMedium &amp;&amp; maxRisk == domain.RiskLow </span><span class="cov0" title="0">{
                        maxRisk = domain.RiskMedium
                }</span>
        }
        <span class="cov0" title="0">return maxRisk</span>
}

func (vm *ValidationMiddleware) makeStringSet(slice []string) map[string]bool <span class="cov0" title="0">{
        result := make(map[string]bool)
        for _, item := range slice </span><span class="cov0" title="0">{
                result[item] = true
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>

      <pre class="file" id="file37" style="display: none">package config

import (
        "fmt"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// validateChangeBusinessRules validates changes against business rules
func (vm *ValidationMiddleware) validateChangeBusinessRules(changes []ConfigChange) error <span class="cov0" title="0">{
        for _, change := range changes </span><span class="cov0" title="0">{
                // Rule: Cannot remove critical protected paths
                if change.Field == "protected" &amp;&amp; change.Operation == OperationRemoved </span><span class="cov0" title="0">{
                        criticalPaths := []string{"/", "/System", "/usr", "/etc"}
                        for _, critical := range criticalPaths </span><span class="cov0" title="0">{
                                if change.OldValue == critical </span><span class="cov0" title="0">{
                                        return fmt.Errorf("cannot remove critical protected path: %s", critical)
                                }</span>
                        }
                }

                // Rule: Cannot disable safe mode without explicit confirmation
                <span class="cov0" title="0">if change.Field == "safe_mode" &amp;&amp; change.OldValue == true &amp;&amp; change.NewValue == false </span><span class="cov0" title="0">{
                        // Check if safe mode confirmation is required
                        if vm.options != nil &amp;&amp; vm.options.RequireSafeModeConfirmation </span><span class="cov0" title="0">{
                                return fmt.Errorf("disabling safe mode requires explicit confirmation (use --confirm-safe-mode-disable)")
                        }</span>

                        // Log warning in production environments
                        <span class="cov0" title="0">if vm.options != nil &amp;&amp; vm.options.Environment == "production" </span><span class="cov0" title="0">{
                                vm.logger.LogError("safe_mode", "config_change",
                                        fmt.Errorf("safe mode disabled in production environment"))
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateOperationSettings validates operation-specific settings with type safety
func (vm *ValidationMiddleware) validateOperationSettings(operationName string, op domain.CleanupOperation) error <span class="cov0" title="0">{
        // Use the already-validated settings from the operation
        if op.Settings == nil </span><span class="cov0" title="0">{
                return nil // Settings are optional
        }</span>

        <span class="cov0" title="0">opType := domain.GetOperationType(operationName)
        return op.Settings.ValidateSettings(opType)</span>
}
</pre>

      <pre class="file" id="file38" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// ConfigValidator provides comprehensive type-safe configuration validation
type ConfigValidator struct {
        rules     *ConfigValidationRules
        sanitizer *ConfigSanitizer
}

// ValidationResult contains validation results with detailed error information
type ValidationResult struct {
        IsValid   bool                     `json:"is_valid"`
        Errors    []ValidationError        `json:"errors,omitempty"`
        Warnings  []ValidationWarning      `json:"warnings,omitempty"`
        Sanitized *ValidationSanitizedData `json:"sanitized,omitempty"`
        Duration  time.Duration            `json:"duration"`
        Timestamp time.Time                `json:"timestamp"`
}

// ValidationSanitizedData provides type-safe configuration data
// FIXED: Removed map[string]any to improve type safety
type ValidationSanitizedData struct {
        FieldsModified []string          `json:"fields_modified,omitempty"`
        RulesApplied   []string          `json:"rules_applied,omitempty"`
        Metadata       map[string]string `json:"metadata,omitempty"`
        // Type-safe configuration instead of dynamic data
        ConfigVersion   string   `json:"config_version,omitempty"`
        ValidationLevel string   `json:"validation_level,omitempty"`
        AppliedProfiles []string `json:"applied_profiles,omitempty"`
}

// ValidationContext provides strongly-typed validation context information
type ValidationContext struct {
        ConfigPath      string            `json:"config_path,omitempty"`
        ValidationLevel string            `json:"validation_level,omitempty"`
        Profile         string            `json:"profile,omitempty"`
        Section         string            `json:"section,omitempty"`
        MinValue        any               `json:"min_value,omitempty"`
        MaxValue        any               `json:"max_value,omitempty"`
        AllowedValues   []string          `json:"allowed_values,omitempty"`
        ReferencedField string            `json:"referenced_field,omitempty"`
        Constraints     map[string]string `json:"constraints,omitempty"`
        Metadata        map[string]string `json:"metadata,omitempty"`
}

// ValidationError represents a specific validation error
type ValidationError struct {
        Field      string             `json:"field"`
        Rule       string             `json:"rule"`
        Value      any                `json:"value"`
        Message    string             `json:"message"`
        Severity   ValidationSeverity `json:"severity"`
        Suggestion string             `json:"suggestion,omitempty"`
        Context    *ValidationContext `json:"context,omitempty"`
}

// ValidationWarning represents a non-critical validation issue
type ValidationWarning struct {
        Field      string             `json:"field"`
        Message    string             `json:"message"`
        Suggestion string             `json:"suggestion,omitempty"`
        Context    *ValidationContext `json:"context,omitempty"`
}

// NewConfigValidator creates a comprehensive configuration validator
func NewConfigValidator() *ConfigValidator <span class="cov8" title="7">{
        return &amp;ConfigValidator{
                rules:     getDefaultValidationRules(),
                sanitizer: NewConfigSanitizer(),
        }
}</span>

// NewConfigValidatorWithRules creates a validator with custom rules
func NewConfigValidatorWithRules(rules *ConfigValidationRules) *ConfigValidator <span class="cov1" title="1">{
        return &amp;ConfigValidator{
                rules:     rules,
                sanitizer: NewConfigSanitizer(),
        }
}</span>

// ValidateConfig performs comprehensive configuration validation
func (cv *ConfigValidator) ValidateConfig(cfg *domain.Config) *ValidationResult <span class="cov10" title="11">{
        start := time.Now()
        result := &amp;ValidationResult{
                IsValid:   true,
                Errors:    []ValidationError{},
                Warnings:  []ValidationWarning{},
                Sanitized: nil, // Initialize as nil, will be set by sanitizer if needed
                Timestamp: time.Now(),
        }

        // Level 1: Basic structure validation
        cv.validateBasicStructure(cfg, result)

        // Level 2: Field-level validation with rules
        cv.validateFieldConstraints(cfg, result)

        // Level 3: Cross-field validation
        cv.validateCrossFieldConstraints(cfg, result)

        // Level 4: Business logic validation
        cv.validateBusinessLogic(cfg, result)

        // Level 5: Security validation
        cv.validateSecurityConstraints(cfg, result)

        // NOTE: Sanitization is NOT applied here to preserve original values
        // Sanitization should be applied separately after validation succeeds
        // This prevents state mutation during verification

        result.Duration = time.Since(start)
        result.IsValid = len(result.Errors) == 0

        return result
}</span>

// ValidateField validates a specific configuration field
func (cv *ConfigValidator) ValidateField(field string, value any) error <span class="cov8" title="7">{
        switch field </span>{
        case "max_disk_usage":<span class="cov6" title="4">
                return cv.validateMaxDiskUsage(value)</span>
        case "protected":<span class="cov5" title="3">
                return cv.validateProtectedPaths(value)</span>
        case "profiles":<span class="cov0" title="0">
                if cfg, ok := value.(*domain.Config); ok </span><span class="cov0" title="0">{
                        return cv.validateProfiles(cfg)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("profiles validation requires *domain.Config, got %T", value)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown field: %s", field)</span>
        }
}
</pre>

      <pre class="file" id="file39" style="display: none">package config

import (
        "fmt"
        "strings"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// validateBusinessLogic validates business logic constraints
func (cv *ConfigValidator) validateBusinessLogic(cfg *domain.Config, result *ValidationResult) <span class="cov6" title="11">{
        for name, profile := range cfg.Profiles </span><span class="cov7" title="12">{
                // Validate profile business logic
                if len(profile.Operations) == 0 </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Field:      fmt.Sprintf("profiles.%s.operations", name),
                                Rule:       "business_logic",
                                Value:      len(profile.Operations),
                                Message:    fmt.Sprintf("Profile '%s' must have at least one operation", name),
                                Severity:   SeverityError,
                                Suggestion: "Add at least one valid operation to profile",
                        })
                }</span>

                // Validate operations within profile
                <span class="cov7" title="12">for _, op := range profile.Operations </span><span class="cov8" title="18">{
                        // Validate risk vs safe mode
                        if !cfg.SafeMode &amp;&amp; op.RiskLevel == domain.RiskCritical </span><span class="cov1" title="1">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Field:      fmt.Sprintf("profiles.%s.operations.%s.risk_level", name, op.Name),
                                        Rule:       "business_logic",
                                        Value:      op.RiskLevel,
                                        Message:    fmt.Sprintf("Critical risk operation '%s' not allowed in unsafe mode", op.Name),
                                        Severity:   SeverityError,
                                        Suggestion: "Enable safe mode or remove critical risk operation",
                                })
                        }</span>

                        // Validate operation settings
                        <span class="cov8" title="18">if op.Settings != nil </span><span class="cov7" title="14">{
                                opType := domain.GetOperationType(op.Name)
                                if err := op.Settings.ValidateSettings(opType); err != nil </span><span class="cov2" title="2">{
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:      fmt.Sprintf("profiles.%s.operations.%s.settings", name, op.Name),
                                                Rule:       "validation",
                                                Value:      op.Settings,
                                                Message:    fmt.Sprintf("Invalid settings for operation '%s': %v", op.Name, err),
                                                Severity:   SeverityError,
                                                Suggestion: "Fix operation settings according to validation rules",
                                        })
                                }</span>
                        }
                }
        }

        // Validate protected paths don't conflict with operation targets
        <span class="cov6" title="11">for _, profile := range cfg.Profiles </span><span class="cov7" title="12">{
                for _, op := range profile.Operations </span><span class="cov8" title="18">{
                        if err := cv.validateProtectedPathsConflict(cfg.Protected, op); err != nil </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, ValidationWarning{
                                        Field:      fmt.Sprintf("profiles.%s.operations.%s", profile.Name, op.Name),
                                        Message:    fmt.Sprintf("Operation may affect protected paths: %v", err),
                                        Suggestion: "Review operation scope and protected paths configuration",
                                })
                        }</span>
                }
        }
}

// validateSecurityConstraints validates security-related constraints
func (cv *ConfigValidator) validateSecurityConstraints(cfg *domain.Config, result *ValidationResult) <span class="cov6" title="11">{
        // Validate no protected paths contain dangerous patterns
        for _, path := range cfg.Protected </span><span class="cov9" title="40">{
                if path == "/" </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Field:      "protected",
                                Message:    "Protecting root directory '/' may prevent system operations",
                                Suggestion: "Consider protecting specific system directories instead",
                                Context: &amp;ValidationContext{
                                        Metadata: map[string]string{
                                                "protected_path": path,
                                        },
                                },
                        })
                }</span>

                // Check for suspicious path patterns
                <span class="cov9" title="40">if strings.Contains(path, "..") </span><span class="cov0" title="0">{
                        result.Errors = append(result.Errors, ValidationError{
                                Field:      "protected",
                                Rule:       "security",
                                Value:      path,
                                Message:    "Protected path contains parent directory reference '..'",
                                Severity:   SeverityError,
                                Suggestion: "Use absolute paths without parent directory references",
                        })
                }</span>
        }

        // Validate no profiles have critical operations without explicit consent
        <span class="cov6" title="11">for name, profile := range cfg.Profiles </span><span class="cov7" title="12">{
                for _, op := range profile.Operations </span><span class="cov8" title="18">{
                        if op.RiskLevel == domain.RiskCritical &amp;&amp; !cfg.SafeMode </span><span class="cov1" title="1">{
                                result.Errors = append(result.Errors, ValidationError{
                                        Field:      fmt.Sprintf("profiles.%s.operations.%s.risk_level", name, op.Name),
                                        Rule:       "security",
                                        Value:      op.RiskLevel,
                                        Message:    fmt.Sprintf("Critical risk operation '%s' requires safe mode enabled", op.Name),
                                        Severity:   SeverityError,
                                        Suggestion: "Enable safe mode or remove critical risk operations",
                                })
                        }</span>
                }
        }
}

// validateProtectedPathsConflict checks if operations might affect protected paths
func (cv *ConfigValidator) validateProtectedPathsConflict(protected []string, op domain.CleanupOperation) error <span class="cov8" title="18">{
        switch op.Name </span>{
        case "temp-files":<span class="cov2" title="2">
                // Check if temp files cleanup might affect protected paths
                return cv.checkTempFilesConflict(protected, op)</span>
        case "nix-generations":<span class="cov7" title="12">
                // Check if nix cleanup might affect protected paths
                return cv.checkNixConflict(protected, op)</span>
        default:<span class="cov4" title="4">
                // Generic conflict check
                return nil</span> // Skip unknown operations
        }
}

// checkTempFilesConflict checks for temp files conflicts
func (cv *ConfigValidator) checkTempFilesConflict(protected []string, op domain.CleanupOperation) error <span class="cov2" title="2">{
        if op.Settings != nil &amp;&amp; op.Settings.TempFiles != nil </span><span class="cov2" title="2">{
                for _, exclude := range op.Settings.TempFiles.Excludes </span><span class="cov4" title="5">{
                        for _, protectedPath := range protected </span><span class="cov8" title="18">{
                                if strings.HasPrefix(exclude, protectedPath) || strings.HasPrefix(protectedPath, exclude) </span><span class="cov0" title="0">{
                                        return fmt.Errorf("temp files exclude '%s' conflicts with protected path '%s'", exclude, protectedPath)
                                }</span>
                        }
                }
        }
        <span class="cov2" title="2">return nil</span>
}

// checkNixConflict checks for Nix conflicts
func (cv *ConfigValidator) checkNixConflict(protected []string, op domain.CleanupOperation) error <span class="cov7" title="12">{
        // Nix operations typically affect /nix/store, check if protected paths overlap
        nixStorePath := "/nix/store"
        for _, protectedPath := range protected </span><span class="cov10" title="41">{
                if strings.HasPrefix(protectedPath, nixStorePath) || strings.HasPrefix(nixStorePath, protectedPath) </span><span class="cov0" title="0">{
                        return fmt.Errorf("nix operations may conflict with protected path '%s'", protectedPath)
                }</span>
        }
        <span class="cov7" title="12">return nil</span>
}

// findMaxRiskLevel finds the maximum risk level in configuration
func (cv *ConfigValidator) findMaxRiskLevel(cfg *domain.Config) domain.RiskLevel <span class="cov1" title="1">{
        maxRisk := domain.RiskLow
        for _, profile := range cfg.Profiles </span><span class="cov1" title="1">{
                for _, op := range profile.Operations </span><span class="cov1" title="1">{
                        if op.RiskLevel == domain.RiskCritical </span><span class="cov1" title="1">{
                                return domain.RiskCritical
                        }</span>
                        <span class="cov0" title="0">if op.RiskLevel == domain.RiskHigh </span><span class="cov0" title="0">{
                                maxRisk = domain.RiskHigh
                        }</span> else<span class="cov0" title="0"> if op.RiskLevel == domain.RiskMedium &amp;&amp; maxRisk == domain.RiskLow </span><span class="cov0" title="0">{
                                maxRisk = domain.RiskMedium
                        }</span>
                }
        }
        <span class="cov0" title="0">return maxRisk</span>
}

// isPathProtected checks if a path is protected
func (cv *ConfigValidator) isPathProtected(protected []string, targetPath string) bool <span class="cov0" title="0">{
        for _, path := range protected </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, targetPath) || strings.HasPrefix(targetPath, path) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>

      <pre class="file" id="file40" style="display: none">package config

import (
        "fmt"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// validateFieldConstraints validates individual fields against rules
func (cv *ConfigValidator) validateFieldConstraints(cfg *domain.Config, result *ValidationResult) <span class="cov9" title="11">{
        // MaxDiskUsage validation
        if err := cv.validateMaxDiskUsage(cfg.MaxDiskUsage); err != nil </span><span class="cov1" title="1">{
                minUsage, maxUsage := cv.getMaxDiskUsageBounds()

                // Create descriptive suggestion using actual rule values
                suggestion := fmt.Sprintf("Set max_disk_usage between %d and %d", minUsage, maxUsage)
                if cv.rules.MaxDiskUsage != nil &amp;&amp; cv.rules.MaxDiskUsage.Message != "" </span><span class="cov1" title="1">{
                        suggestion = cv.rules.MaxDiskUsage.Message
                }</span>

                <span class="cov1" title="1">result.Errors = append(result.Errors, ValidationError{
                        Field:      "max_disk_usage",
                        Rule:       "range",
                        Value:      cfg.MaxDiskUsage,
                        Message:    err.Error(),
                        Severity:   SeverityError,
                        Suggestion: suggestion,
                        Context: &amp;ValidationContext{
                                MinValue: minUsage,
                                MaxValue: maxUsage,
                        },
                })</span>
        }

        // Protected paths validation
        <span class="cov9" title="11">if err := cv.validateProtectedPaths(cfg.Protected); err != nil </span><span class="cov1" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Field:      "protected",
                        Rule:       "format",
                        Value:      cfg.Protected,
                        Message:    err.Error(),
                        Severity:   SeverityError,
                        Suggestion: "Ensure all paths are valid absolute paths",
                })
        }</span>

        // Check for duplicate paths
        <span class="cov9" title="11">if cv.rules.UniquePaths </span><span class="cov9" title="11">{
                duplicates := cv.findDuplicatePaths(cfg.Protected)
                if len(duplicates) &gt; 0 </span><span class="cov1" title="1">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Field:      "protected",
                                Message:    fmt.Sprintf("Duplicate protected paths found: %v", duplicates),
                                Suggestion: "Remove duplicate paths from protected list",
                        })
                }</span>
        }

        // Check profile count limits
        <span class="cov9" title="11">if cv.rules.MaxProfiles != nil &amp;&amp; cv.rules.MaxProfiles.Max != nil &amp;&amp; len(cfg.Profiles) &gt; *cv.rules.MaxProfiles.Max </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationWarning{
                        Field:      "profiles",
                        Message:    fmt.Sprintf("Profile count (%d) exceeds recommended limit (%d)", len(cfg.Profiles), *cv.rules.MaxProfiles.Max),
                        Suggestion: "Consider consolidating profiles to improve maintainability",
                })
        }</span>
}

// validateCrossFieldConstraints validates relationships between fields
func (cv *ConfigValidator) validateCrossFieldConstraints(cfg *domain.Config, result *ValidationResult) <span class="cov9" title="11">{
        // Safe mode vs risk level consistency
        if !cfg.SafeMode </span><span class="cov1" title="1">{
                maxRisk := cv.findMaxRiskLevel(cfg)
                if maxRisk == domain.RiskCritical </span><span class="cov1" title="1">{
                        result.Warnings = append(result.Warnings, ValidationWarning{
                                Field:      "safe_mode",
                                Message:    "Critical risk operations enabled while safe_mode is false",
                                Suggestion: "Enable safe_mode or review critical risk operations",
                                Context: &amp;ValidationContext{
                                        Metadata: map[string]string{
                                                "max_risk_level": maxRisk.String(),
                                                "safe_mode":      fmt.Sprintf("%v", cfg.SafeMode),
                                        },
                                },
                        })
                }</span>
        }

        // Validate operation count per profile
        <span class="cov9" title="11">for name, profile := range cfg.Profiles </span><span class="cov10" title="12">{
                if cv.rules.MaxOperations != nil &amp;&amp; cv.rules.MaxOperations.Max != nil </span><span class="cov0" title="0">{
                        if len(profile.Operations) &gt; *cv.rules.MaxOperations.Max </span><span class="cov0" title="0">{
                                result.Warnings = append(result.Warnings, ValidationWarning{
                                        Field:      fmt.Sprintf("profiles.%s.operations", name),
                                        Message:    fmt.Sprintf("Profile '%s' has %d operations, exceeding recommended limit (%d)", name, len(profile.Operations), *cv.rules.MaxOperations.Max),
                                        Suggestion: "Consider splitting operations into multiple profiles",
                                        Context: &amp;ValidationContext{
                                                Metadata: map[string]string{
                                                        "operation_count": fmt.Sprintf("%d", len(profile.Operations)),
                                                        "max_operations":  fmt.Sprintf("%d", *cv.rules.MaxOperations.Max),
                                                },
                                        },
                                })
                        }</span>
                }
        }
}
</pre>

      <pre class="file" id="file41" style="display: none">package config

import (
        "fmt"
        "path/filepath"
)

// validateMaxDiskUsage validates max disk usage percentage
func (cv *ConfigValidator) validateMaxDiskUsage(value any) error <span class="cov7" title="15">{
        usage, ok := value.(int)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("max_disk_usage must be an integer, got %T", value)
        }</span>

        <span class="cov7" title="14">min, max := cv.getMaxDiskUsageBounds()
        if usage &lt; min </span><span class="cov1" title="1">{
                return fmt.Errorf("max_disk_usage (%d) below minimum (%d)", usage, min)
        }</span>
        <span class="cov7" title="13">if usage &gt; max </span><span class="cov2" title="2">{
                return fmt.Errorf("max_disk_usage (%d) above maximum (%d)", usage, max)
        }</span>

        <span class="cov6" title="11">return nil</span>
}

// getMaxDiskUsageBounds safely returns min and max bounds for max disk usage
func (cv *ConfigValidator) getMaxDiskUsageBounds() (min, max int) <span class="cov7" title="15">{
        min, max = 0, 100 // Safe defaults

        if cv.rules.MaxDiskUsage != nil </span><span class="cov7" title="15">{
                if cv.rules.MaxDiskUsage.Min != nil </span><span class="cov7" title="15">{
                        min = *cv.rules.MaxDiskUsage.Min
                }</span>
                <span class="cov7" title="15">if cv.rules.MaxDiskUsage.Max != nil </span><span class="cov7" title="15">{
                        max = *cv.rules.MaxDiskUsage.Max
                }</span>
        }
        <span class="cov7" title="15">return min, max</span>
}

// validateProtectedPaths validates protected paths array
func (cv *ConfigValidator) validateProtectedPaths(value any) error <span class="cov7" title="14">{
        paths, ok := value.([]string)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("protected must be a string array, got %T", value)
        }</span>

        // Explicitly reject empty arrays as required field
        <span class="cov7" title="13">if len(paths) == 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("protected paths cannot be empty")
        }</span>

        <span class="cov6" title="11">for i, path := range paths </span><span class="cov10" title="42">{
                if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("protected[%d] cannot be empty", i)
                }</span>
                <span class="cov10" title="42">if !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        return fmt.Errorf("protected[%d] must be absolute path: %s", i, path)
                }</span>
        }

        <span class="cov6" title="11">return nil</span>
}

// findDuplicatePaths finds duplicate paths in the given slice
func (cv *ConfigValidator) findDuplicatePaths(paths []string) []string <span class="cov6" title="11">{
        seen := make(map[string]bool)
        duplicates := []string{}

        for _, path := range paths </span><span class="cov9" title="40">{
                if seen[path] </span><span class="cov1" title="1">{
                        duplicates = append(duplicates, path)
                }</span> else<span class="cov9" title="39"> {
                        seen[path] = true
                }</span>
        }

        <span class="cov6" title="11">return duplicates</span>
}
</pre>

      <pre class="file" id="file42" style="display: none">package config

import (
        "fmt"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// validateProfiles validates all profiles in configuration
func (cv *ConfigValidator) validateProfiles(cfg *domain.Config) error <span class="cov0" title="0">{
        for name, profile := range cfg.Profiles </span><span class="cov0" title="0">{
                // Validate profile name
                if err := cv.validateProfileName(name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile %s: %w", name, err)
                }</span>

                // Check for nil profile to prevent panic
                <span class="cov0" title="0">if profile == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile %s: nil profile", name)
                }</span>

                // Validate profile struct
                <span class="cov0" title="0">if err := profile.Validate(name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile %s: %w", name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateProfileName validates profile name format
func (cv *ConfigValidator) validateProfileName(name string) error <span class="cov0" title="0">{
        // Explicitly reject empty names
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("profile name cannot be empty")
        }</span>

        // Use configured regex pattern if available
        <span class="cov0" title="0">if cv.rules.ProfileNamePattern != nil </span><span class="cov0" title="0">{
                if cv.rules.ProfileNamePattern.Pattern != "" </span><span class="cov0" title="0">{
                        if compiledRegex := cv.rules.ProfileNamePattern.GetCompiledRegex(); compiledRegex != nil </span><span class="cov0" title="0">{
                                if !compiledRegex.MatchString(name) </span><span class="cov0" title="0">{
                                        message := cv.rules.ProfileNamePattern.Message
                                        if message == "" </span><span class="cov0" title="0">{
                                                message = fmt.Sprintf("Profile name '%s' does not match pattern: %s", name, cv.rules.ProfileNamePattern.Pattern)
                                        }</span>
                                        <span class="cov0" title="0">return fmt.Errorf("%s", message)</span>
                                }
                                <span class="cov0" title="0">return nil</span> // Pattern matched successfully
                        } else<span class="cov0" title="0"> {
                                // Regex compilation failed, fall back to pattern in error message
                                return fmt.Errorf("profile name pattern '%s' is invalid and cannot be compiled", cv.rules.ProfileNamePattern.Pattern)
                        }</span>
                }
                // Pattern field exists but is empty - use default validation
                <span class="cov0" title="0">return fmt.Errorf("profile name pattern is configured but empty")</span>
        }

        // No pattern rule configured - use reasonable default validation
        // Only allow alphanumeric characters, underscores, and hyphens
        <span class="cov0" title="0">for _, char := range name </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '_' || char == '-') </span><span class="cov0" title="0">{
                        return fmt.Errorf("profile name '%s' contains invalid character: %c (allowed: alphanumeric, underscore, hyphen)", name, char)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>

      <pre class="file" id="file43" style="display: none">package config

import (
        "regexp"
        "sync"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// ConfigValidationRules defines all validation constraints
type ConfigValidationRules struct {
        // Numeric Constraints
        MaxDiskUsage      *ValidationRule[int] `json:"max_disk_usage"`
        MinProtectedPaths *ValidationRule[int] `json:"min_protected_paths"`
        MaxProfiles       *ValidationRule[int] `json:"max_profiles"`
        MaxOperations     *ValidationRule[int] `json:"max_operations"`

        // String Constraints
        ProfileNamePattern *ValidationRule[string] `json:"profile_name_pattern"`
        PathPattern        *ValidationRule[string] `json:"path_pattern"`

        // Array Constraints
        UniquePaths    bool `json:"unique_paths"`
        UniqueProfiles bool `json:"unique_profiles"`

        // Safety Constraints
        ProtectedSystemPaths  []string `json:"protected_system_paths"`
        DefaultProtectedPaths []string `json:"default_protected_paths"`
        RequireSafeMode       bool     `json:"require_safe_mode"`

        // Risk Constraints
        MaxRiskLevel   domain.RiskLevel `json:"max_risk_level"`
        BackupRequired domain.RiskLevel `json:"backup_required"`
}

// ValidationRule represents a validation constraint for a specific type
type ValidationRule[T comparable] struct {
        Required bool   `json:"required"`
        Min      *T     `json:"min,omitempty"`
        Max      *T     `json:"max,omitempty"`
        Enum     []T    `json:"enum,omitempty"`
        Pattern  string `json:"pattern,omitempty"`
        Message  string `json:"message,omitempty"`

        // Compiled regex for pattern validation (cached)
        compiledRegex *regexp.Regexp
        regexOnce     sync.Once
}

// ValidationSeverity represents error severity levels
type ValidationSeverity string

const (
        SeverityError   ValidationSeverity = "error"
        SeverityWarning ValidationSeverity = "warning"
        SeverityInfo    ValidationSeverity = "info"
)

// GetCompiledRegex returns the compiled regex pattern, creating it once if needed
func (vr *ValidationRule[T]) GetCompiledRegex() *regexp.Regexp <span class="cov0" title="0">{
        vr.regexOnce.Do(func() </span><span class="cov0" title="0">{
                if vr.Pattern != "" </span><span class="cov0" title="0">{
                        if compiled, err := regexp.Compile(vr.Pattern); err == nil </span><span class="cov0" title="0">{
                                vr.compiledRegex = compiled
                        }</span>
                        // Note: If compilation fails, vr.compiledRegex remains nil
                        // and validation will fail gracefully in validateProfileName
                }
        })
        <span class="cov0" title="0">return vr.compiledRegex</span>
}

// getDefaultValidationRules returns default validation constraints
func getDefaultValidationRules() *ConfigValidationRules <span class="cov10" title="7">{
        // Magic numbers extracted to constants for maintainability
        minUsage := 10
        maxUsage := 95
        minPaths := 1
        maxProfiles := 10
        maxOps := 20

        return &amp;ConfigValidationRules{
                MaxDiskUsage: &amp;ValidationRule[int]{
                        Required: true,
                        Min:      &amp;minUsage,
                        Max:      &amp;maxUsage,
                        Message:  "Max disk usage must be between 10% and 95%",
                },
                MinProtectedPaths: &amp;ValidationRule[int]{
                        Required: true,
                        Min:      &amp;minPaths,
                        Message:  "At least one protected path is required",
                },
                MaxProfiles: &amp;ValidationRule[int]{
                        Required: false,
                        Min:      &amp;maxProfiles,
                        Message:  "Consider limiting profiles to maintain clarity",
                },
                MaxOperations: &amp;ValidationRule[int]{
                        Required: false,
                        Min:      &amp;maxOps,
                        Message:  "Consider limiting operations per profile for better maintainability",
                },
                ProfileNamePattern: &amp;ValidationRule[string]{
                        Required: true,
                        Pattern:  "^[a-zA-Z0-9_-]+$",
                        Message:  "Profile names must be alphanumeric with underscores and hyphens",
                },
                UniquePaths:    true,
                UniqueProfiles: true,
                ProtectedSystemPaths: []string{
                        "/",
                        "/System",
                        "/Applications",
                        "/Library",
                        "/usr",
                        "/etc",
                        "/var",
                        "/bin",
                        "/sbin",
                },
                DefaultProtectedPaths: []string{
                        "/System",
                        "/Applications",
                        "/Library",
                },
                RequireSafeMode: true,
                MaxRiskLevel:    domain.RiskHigh,
                BackupRequired:  domain.RiskMedium,
        }
}</span>
</pre>

      <pre class="file" id="file44" style="display: none">package config

import (
        "github.com/LarsArtmann/clean-wizard/internal/domain"
)

// validateBasicStructure validates basic configuration structure
func (cv *ConfigValidator) validateBasicStructure(cfg *domain.Config, result *ValidationResult) <span class="cov10" title="11">{
        // Version validation
        if cfg.Version == "" </span><span class="cov1" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Field:      "version",
                        Rule:       "required",
                        Value:      cfg.Version,
                        Message:    "Configuration version is required",
                        Severity:   SeverityError,
                        Suggestion: "Add version field with semantic version (e.g., '1.0.0')",
                })
        }</span>

        // Profiles validation
        <span class="cov10" title="11">if len(cfg.Profiles) == 0 </span><span class="cov1" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Field:      "profiles",
                        Rule:       "required",
                        Value:      cfg.Profiles,
                        Message:    "At least one profile is required",
                        Severity:   SeverityError,
                        Suggestion: "Add a profile with at least one operation",
                })
        }</span>

        // Protected paths validation
        <span class="cov10" title="11">if len(cfg.Protected) == 0 </span><span class="cov1" title="1">{
                result.Errors = append(result.Errors, ValidationError{
                        Field:      "protected",
                        Rule:       "required",
                        Value:      cfg.Protected,
                        Message:    "Protected paths cannot be empty",
                        Severity:   SeverityError,
                        Suggestion: "Add system paths like /System, /Applications, /Library",
                })
        }</span>
}
</pre>

      <pre class="file" id="file45" style="display: none">package conversions

import (
        "fmt"
        "time"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/result"
)

// DOMAIN BUILDERS - Single source of truth for domain object construction

// NewCleanResult creates a valid CleanResult with basic strategy and metrics.
//
// Parameters:
//   - strategy: The cleaning strategy used (e.g., StrategyAggressive, StrategyDryRun)
//   - itemsRemoved: Number of items successfully removed
//   - freedBytes: Total bytes freed by the operation
//
// Returns:
//   - domain.CleanResult: A fully initialized CleanResult with current timestamp
//
// Example:
//
//        result := NewCleanResult(domain.StrategyAggressive, 5, 1024*1024*100)
//        fmt.Printf("Freed %d bytes", result.FreedBytes)
func NewCleanResult(strategy domain.CleanStrategy, itemsRemoved int, freedBytes int64) domain.CleanResult <span class="cov10" title="9">{
        return domain.CleanResult{
                FreedBytes:   uint64(freedBytes),
                ItemsRemoved: uint(itemsRemoved),
                ItemsFailed:  0,
                CleanTime:    0, // Will be set by caller
                CleanedAt:    time.Now(),
                Strategy:     strategy,
        }
}</span>

// NewCleanResultWithTiming creates a CleanResult with custom timing information.
//
// Use this function when you have precise timing measurements for the operation.
// This provides more accurate metrics than the basic NewCleanResult function.
//
// Parameters:
//   - strategy: The cleaning strategy used
//   - itemsRemoved: Number of items successfully removed
//   - freedBytes: Total bytes freed by the operation
//   - cleanTime: Time duration of the cleaning operation
//
// Returns:
//   - domain.CleanResult: A fully initialized CleanResult with timing data
//
// Example:
//
//        startTime := time.Now()
//        // ... perform cleaning ...
//        cleanTime := time.Since(startTime)
//        result := NewCleanResultWithTiming(domain.StrategyAggressive, 5, 1024*1024*100, cleanTime)
func NewCleanResultWithTiming(strategy domain.CleanStrategy, itemsRemoved int, freedBytes int64, cleanTime time.Duration) domain.CleanResult <span class="cov3" title="2">{
        return domain.CleanResult{
                FreedBytes:   uint64(freedBytes),
                ItemsRemoved: uint(itemsRemoved),
                ItemsFailed:  0,
                CleanTime:    cleanTime,
                CleanedAt:    time.Now(),
                Strategy:     strategy,
        }
}</span>

// NewCleanResultWithFailures creates a CleanResult with failure tracking for detailed reporting.
//
// Use this function when some operations failed and you need to track both successful
// and failed operations separately. This is useful for complex multi-step cleaning operations.
//
// Parameters:
//   - strategy: The cleaning strategy used
//   - itemsRemoved: Number of items successfully removed
//   - itemsFailed: Number of items that failed to remove
//   - freedBytes: Total bytes freed by successful operations
//   - cleanTime: Time duration of the cleaning operation
//
// Returns:
//   - domain.CleanResult: A fully initialized CleanResult with failure tracking
//
// Example:
//
//        result := NewCleanResultWithFailures(domain.StrategyConservative, 5, 2, 1024*1024*100, time.Second*30)
//        fmt.Printf("Success: %d, Failed: %d", result.ItemsRemoved, result.ItemsFailed)
func NewCleanResultWithFailures(strategy domain.CleanStrategy, itemsRemoved, itemsFailed int, freedBytes int64, cleanTime time.Duration) domain.CleanResult <span class="cov7" title="5">{
        return domain.CleanResult{
                FreedBytes:   uint64(freedBytes),
                ItemsRemoved: uint(itemsRemoved),
                ItemsFailed:  uint(itemsFailed),
                CleanTime:    cleanTime,
                CleanedAt:    time.Now(),
                Strategy:     strategy,
        }
}</span>

// NewScanResult creates a valid ScanResult with all required metrics and metadata.
//
// This is the central function for creating scan results throughout the application.
// All scanning operations should use this function to ensure consistent data.
//
// Parameters:
//   - totalBytes: Total bytes found during scanning
//   - totalItems: Total number of items discovered
//   - scannedPaths: List of paths that were scanned
//   - scanDuration: Time taken to perform the scan
//
// Returns:
//   - domain.ScanResult: A fully initialized ScanResult with current timestamp
//
// Example:
//
//        paths := []string{"/nix/store", "/tmp"}
//        result := NewScanResult(1024*1024*500, 1000, paths, time.Second*10)
//        fmt.Printf("Scanned %d items in %v", result.TotalItems, result.ScanTime)
func NewScanResult(totalBytes int64, totalItems int, scannedPaths []string, scanDuration time.Duration) domain.ScanResult <span class="cov3" title="2">{
        return domain.ScanResult{
                TotalBytes:   totalBytes,
                TotalItems:   totalItems,
                ScannedPaths: scannedPaths,
                ScanTime:     scanDuration,
                ScannedAt:    time.Now(),
        }
}</span>

// GENERIC CONVERSION FUNCTIONS - Centralized primitive‚Üídomain transformations

// ToCleanResult converts primitive Result[int64] to domain Result[domain.CleanResult] with conservative strategy.
//
// This is the simplest conversion function that automatically uses conservative strategy.
// Use this when you don't need custom strategy information.
//
// Parameters:
//   - bytesResult: Result[int64] containing bytes freed from primitive operation
//
// Returns:
//   - result.Result[domain.CleanResult]: Converted result with conservative strategy
//
// Example:
//
//        bytesResult := adapter.GetStoreSize(ctx)
//        cleanResult := ToCleanResult(bytesResult)
//        if cleanResult.IsOk() {
//                fmt.Printf("Freed %d bytes", cleanResult.Value().FreedBytes)
//        }
func ToCleanResult(bytesResult result.Result[int64]) result.Result[domain.CleanResult] <span class="cov3" title="2">{
        return ToCleanResultWithStrategy(bytesResult, domain.StrategyConservative)
}</span>

// ToCleanResultWithStrategy converts primitive Result[int64] to domain.Result[domain.CleanResult] with custom strategy.
//
// Use this function when you need to specify the cleaning strategy used.
// This provides more detailed tracking of which operation type was performed.
//
// Parameters:
//   - bytesResult: Result[int64] containing bytes freed from primitive operation
//   - strategy: CleanStrategy enum value (e.g., StrategyAggressive, StrategyConservative, StrategyDryRun)
//
// Returns:
//   - result.Result[domain.CleanResult]: Converted result with specified strategy
//
// Example:
//
//        bytesResult := adapter.CollectGarbage(ctx)
//        cleanResult := ToCleanResultWithStrategy(bytesResult, domain.StrategyAggressive)
func ToCleanResultWithStrategy(bytesResult result.Result[int64], strategy domain.CleanStrategy) result.Result[domain.CleanResult] <span class="cov5" title="3">{
        if bytesResult.IsErr() </span><span class="cov1" title="1">{
                return result.Err[domain.CleanResult](bytesResult.Error())
        }</span>

        <span class="cov3" title="2">bytes := bytesResult.Value()
        cleanResult := NewCleanResult(strategy, 1, bytes)
        return result.Ok(cleanResult)</span>
}

// ToCleanResultFromItems converts items count and bytes to domain Result[domain.CleanResult].
//
// Use this function when you have both the number of items removed and the bytes freed.
// This provides more detailed metrics than just bytes conversion alone.
//
// Parameters:
//   - itemsRemoved: Number of items successfully removed
//   - bytesResult: Result[int64] containing bytes freed from operation
//   - strategy: CleanStrategy enum value for the cleaning strategy
//
// Returns:
//   - result.Result[domain.CleanResult]: Converted result with items and bytes data
//
// Example:
//
//        bytesResult := adapter.CollectGarbage(ctx)
//        cleanResult := ToCleanResultFromItems(5, bytesResult, domain.StrategyAggressive)
//        if cleanResult.IsOk() {
//                fmt.Printf("Removed %d items, freed %d bytes",
//                        cleanResult.Value().ItemsRemoved, cleanResult.Value().FreedBytes)
//        }
func ToCleanResultFromItems(itemsRemoved int, bytesResult result.Result[int64], strategy domain.CleanStrategy) result.Result[domain.CleanResult] <span class="cov1" title="1">{
        if bytesResult.IsErr() </span><span class="cov0" title="0">{
                return result.Err[domain.CleanResult](bytesResult.Error())
        }</span>

        <span class="cov1" title="1">bytes := bytesResult.Value()
        cleanResult := NewCleanResult(strategy, itemsRemoved, bytes)
        return result.Ok(cleanResult)</span>
}

// ToTimedCleanResult creates a timed CleanResult from bytes and duration
func ToTimedCleanResult(bytesResult result.Result[int64], strategy domain.CleanStrategy, cleanTime time.Duration) result.Result[domain.CleanResult] <span class="cov1" title="1">{
        if bytesResult.IsErr() </span><span class="cov0" title="0">{
                return result.Err[domain.CleanResult](bytesResult.Error())
        }</span>

        <span class="cov1" title="1">bytes := bytesResult.Value()
        cleanResult := NewCleanResultWithTiming(strategy, 1, bytes, cleanTime)
        return result.Ok(cleanResult)</span>
}

// ToScanResult converts primitive scanning results to domain.ScanResult
func ToScanResult(totalBytes int64, totalItems int, scannedPaths []string, scanDuration time.Duration) domain.ScanResult <span class="cov1" title="1">{
        return NewScanResult(totalBytes, totalItems, scannedPaths, scanDuration)
}</span>

// UTILITY FUNCTIONS - Helper transformations

// CombineCleanResults combines multiple CleanResults into one
func CombineCleanResults(results []domain.CleanResult) domain.CleanResult <span class="cov5" title="3">{
        if len(results) == 0 </span><span class="cov1" title="1">{
                return NewCleanResult(domain.StrategyConservative, 0, 0)
        }</span>

        <span class="cov3" title="2">totalItems := 0
        totalFailed := 0
        totalBytes := uint64(0)
        maxTime := time.Duration(0)

        // Track strategies to determine combined strategy
        firstStrategy := results[0].Strategy
        allSameStrategy := true

        for _, result := range results </span><span class="cov6" title="4">{
                totalItems += int(result.ItemsRemoved)
                totalFailed += int(result.ItemsFailed)
                totalBytes += result.FreedBytes
                if result.CleanTime &gt; maxTime </span><span class="cov3" title="2">{
                        maxTime = result.CleanTime
                }</span>
                <span class="cov6" title="4">if result.Strategy != firstStrategy </span><span class="cov3" title="2">{
                        allSameStrategy = false
                }</span>
        }

        // If all strategies are the same, use that strategy
        // Otherwise, use conservative as the safest default for mixed operations
        <span class="cov3" title="2">combinedStrategy := firstStrategy
        if !allSameStrategy </span><span class="cov3" title="2">{
                combinedStrategy = domain.StrategyConservative
        }</span>

        <span class="cov3" title="2">return NewCleanResultWithFailures(combinedStrategy, totalItems, totalFailed, int64(totalBytes), maxTime)</span>
}

// ExtractBytesFromCleanResult extracts int64 from domain.CleanResult (for adapter compatibility)
func ExtractBytesFromCleanResult(cleanResult result.Result[domain.CleanResult]) result.Result[int64] <span class="cov3" title="2">{
        if cleanResult.IsErr() </span><span class="cov1" title="1">{
                return result.Err[int64](cleanResult.Error())
        }</span>

        <span class="cov1" title="1">cleanValue := cleanResult.Value()
        return result.Ok[int64](int64(cleanValue.FreedBytes))</span>
}

// ToCleanResultFromError converts error to Result[domain.CleanResult]
func ToCleanResultFromError(err error) result.Result[domain.CleanResult] <span class="cov1" title="1">{
        return result.Err[domain.CleanResult](err)
}</span>

// ToScanResultFromError converts error to Result[domain.ScanResult]
func ToScanResultFromError(err error) result.Result[domain.ScanResult] <span class="cov0" title="0">{
        return result.Err[domain.ScanResult](err)
}</span>

// VALIDATION HELPERS

// ValidateAndConvertCleanResult ensures CleanResult is valid before returning
func ValidateAndConvertCleanResult(cleanResult domain.CleanResult) result.Result[domain.CleanResult] <span class="cov3" title="2">{
        if err := cleanResult.Validate(); err != nil </span><span class="cov1" title="1">{
                return result.Err[domain.CleanResult](fmt.Errorf("invalid CleanResult: %w", err))
        }</span>
        <span class="cov1" title="1">return result.Ok(cleanResult)</span>
}

// ValidateAndConvertScanResult ensures ScanResult is valid before returning
func ValidateAndConvertScanResult(scanResult domain.ScanResult) result.Result[domain.ScanResult] <span class="cov0" title="0">{
        if err := scanResult.Validate(); err != nil </span><span class="cov0" title="0">{
                return result.Err[domain.ScanResult](fmt.Errorf("invalid ScanResult: %w", err))
        }</span>
        <span class="cov0" title="0">return result.Ok(scanResult)</span>
}
</pre>

      <pre class="file" id="file46" style="display: none">package domain

import (
        "fmt"
        "time"
)

// Config represents application configuration with type safety
type Config struct {
        Version        string              `json:"version" yaml:"version"`
        SafeMode       bool                `json:"safe_mode" yaml:"safe_mode"`
        MaxDiskUsage   int                 `json:"max_disk_usage" yaml:"max_disk_usage"`
        Protected      []string            `json:"protected" yaml:"protected"`
        Profiles       map[string]*Profile `json:"profiles" yaml:"profiles"`
        CurrentProfile string              `json:"current_profile,omitempty" yaml:"current_profile,omitempty"`
        LastClean      time.Time           `json:"last_clean" yaml:"last_clean"`
        Updated        time.Time           `json:"updated" yaml:"updated"`
}

// IsValid validates configuration
func (c *Config) IsValid() bool <span class="cov0" title="0">{
        if c.MaxDiskUsage &lt; 0 || c.MaxDiskUsage &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(c.Protected) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(c.Profiles) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for name, profile := range c.Profiles </span><span class="cov0" title="0">{
                if !profile.IsValid(name) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Validate returns errors for invalid configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.MaxDiskUsage &lt; 0 || c.MaxDiskUsage &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("MaxDiskUsage must be between 0 and 100, got: %d", c.MaxDiskUsage)
        }</span>

        <span class="cov0" title="0">if len(c.Protected) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Protected paths cannot be empty")
        }</span>

        <span class="cov0" title="0">for i, path := range c.Protected </span><span class="cov0" title="0">{
                if path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Protected path %d cannot be empty", i)
                }</span>
        }

        <span class="cov0" title="0">if len(c.Profiles) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Configuration must have at least one profile")
        }</span>

        <span class="cov0" title="0">for name, profile := range c.Profiles </span><span class="cov0" title="0">{
                if err := profile.Validate(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Profile represents cleanup profile
type Profile struct {
        Name        string             `json:"name" yaml:"name"`
        Description string             `json:"description" yaml:"description"`
        Operations  []CleanupOperation `json:"operations" yaml:"operations"`
        Enabled     bool               `json:"enabled" yaml:"enabled"`
}

// IsValid validates profile
func (p *Profile) IsValid(name string) bool <span class="cov0" title="0">{
        if p.Name == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if p.Description == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if len(p.Operations) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, op := range p.Operations </span><span class="cov0" title="0">{
                if !op.IsValid() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// Validate returns errors for invalid profile
func (p *Profile) Validate(name string) error <span class="cov0" title="0">{
        if p.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Profile %s: name cannot be empty", name)
        }</span>
        <span class="cov0" title="0">if p.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Profile %s: description cannot be empty", name)
        }</span>
        <span class="cov0" title="0">if len(p.Operations) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Profile %s: must have at least one operation", name)
        }</span>

        <span class="cov0" title="0">for i, op := range p.Operations </span><span class="cov0" title="0">{
                if err := op.Validate(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Profile %s: operation %d invalid: %w", name, i, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CleanupOperation represents single cleanup operation with type-safe settings
type CleanupOperation struct {
        Name        string             `json:"name" yaml:"name"`
        Description string             `json:"description" yaml:"description"`
        RiskLevel   RiskLevel          `json:"risk_level" yaml:"risk_level"`
        Enabled     bool               `json:"enabled" yaml:"enabled"`
        Settings    *OperationSettings `json:"settings,omitempty" yaml:"settings,omitempty"`
}

// IsValid validates cleanup operation
func (op CleanupOperation) IsValid() bool <span class="cov0" title="0">{
        if op.Name == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if op.Description == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !op.RiskLevel.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Validate returns errors for invalid cleanup operation
func (op CleanupOperation) Validate() error <span class="cov0" title="0">{
        if op.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Operation name cannot be empty")
        }</span>
        <span class="cov0" title="0">if op.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Operation description cannot be empty")
        }</span>

        // Validate settings if present
        <span class="cov0" title="0">if op.Settings != nil </span><span class="cov0" title="0">{
                opType := GetOperationType(op.Name)
                if err := op.Settings.ValidateSettings(opType); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Operation settings validation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>

      <pre class="file" id="file47" style="display: none">package domain

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"
)

// ParseCustomDuration parses human-readable duration formats like "7d", "24h", "30m"
// and converts them to Go time.Duration
func ParseCustomDuration(durationStr string) (time.Duration, error) <span class="cov10" title="17">{
        // Trim whitespace first
        durationStr = strings.TrimSpace(durationStr)

        if durationStr == "" </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("empty duration string")
        }</span>

        // Check if it's already a valid Go duration
        <span class="cov9" title="16">if goDuration, err := time.ParseDuration(durationStr); err == nil </span><span class="cov6" title="5">{
                return goDuration, nil
        }</span>

        // Custom parsing for "d" (days) unit
        <span class="cov8" title="11">if strings.HasSuffix(durationStr, "d") </span><span class="cov7" title="9">{
                return parseDaysDuration(durationStr)
        }</span>

        // Try other custom formats
        <span class="cov3" title="2">return parseComplexDuration(durationStr)</span>
}

// parseDaysDuration parses duration with "d" suffix
func parseDaysDuration(durationStr string) (time.Duration, error) <span class="cov7" title="9">{
        re := regexp.MustCompile(`^(\d+(?:\.\d+)?)d$`)
        matches := re.FindStringSubmatch(durationStr)
        if len(matches) != 2 </span><span class="cov4" title="3">{
                return 0, fmt.Errorf("invalid days duration format: %s", durationStr)
        }</span>

        <span class="cov6" title="6">days, err := strconv.ParseFloat(matches[1], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid days value: %v", err)
        }</span>

        // Convert days to hours (24 hours per day)
        <span class="cov6" title="6">hours := days * 24
        goDurationStr := fmt.Sprintf("%.0fh", hours)

        return time.ParseDuration(goDurationStr)</span>
}

// parseComplexDuration parses combined durations like "7d12h"
func parseComplexDuration(durationStr string) (time.Duration, error) <span class="cov3" title="2">{
        // This could be extended to support complex formats
        // For now, focus on the most common case: days only
        return 0, fmt.Errorf("unsupported duration format: %s (supported formats: '7d', '24h', '30m', '1h30m')", durationStr)
}</span>

// ValidateCustomDuration checks if a duration string is valid for this system
func ValidateCustomDuration(durationStr string) error <span class="cov5" title="4">{
        if durationStr == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("duration cannot be empty")
        }</span>

        <span class="cov4" title="3">_, err := ParseCustomDuration(durationStr)
        return err</span>
}
</pre>

      <pre class="file" id="file48" style="display: none">package domain

// OperationSettings provides type-safe configuration for different operation types
// This eliminates map[string]any violations while maintaining flexibility
type OperationSettings struct {
        // Nix Generations Settings
        NixGenerations *NixGenerationsSettings `json:"nix_generations,omitempty" yaml:"nix_generations,omitempty"`

        // Temp Files Settings
        TempFiles *TempFilesSettings `json:"temp_files,omitempty" yaml:"temp_files,omitempty"`

        // Homebrew Settings
        Homebrew *HomebrewSettings `json:"homebrew,omitempty" yaml:"homebrew,omitempty"`

        // System Temp Settings
        SystemTemp *SystemTempSettings `json:"system_temp,omitempty" yaml:"system_temp,omitempty"`
}

// NixGenerationsSettings provides type-safe settings for Nix generations cleanup
type NixGenerationsSettings struct {
        Generations int  `json:"generations" yaml:"generations"`
        Optimize    bool `json:"optimize" yaml:"optimize"`
        DryRun     bool `json:"dry_run,omitempty" yaml:"dry_run,omitempty"`
}

// TempFilesSettings provides type-safe settings for temporary files cleanup
type TempFilesSettings struct {
        OlderThan string   `json:"older_than" yaml:"older_than"`
        Excludes  []string `json:"excludes,omitempty" yaml:"excludes,omitempty"`
}

// HomebrewSettings provides type-safe settings for Homebrew cleanup
type HomebrewSettings struct {
        UnusedOnly bool   `json:"unused_only" yaml:"unused_only"`
        Prune      string `json:"prune,omitempty" yaml:"prune,omitempty"`
}

// SystemTempSettings provides type-safe settings for system temp cleanup
type SystemTempSettings struct {
        Paths     []string `json:"paths" yaml:"paths"`
        OlderThan string   `json:"older_than" yaml:"older_than"`
}

// OperationType represents different types of cleanup operations
type OperationType string

const (
        OperationTypeNixGenerations OperationType = "nix-generations"
        OperationTypeTempFiles      OperationType = "temp-files"
        OperationTypeHomebrew       OperationType = "homebrew-cleanup"
        OperationTypeSystemTemp     OperationType = "system-temp"
)

// GetOperationType returns the operation type from operation name
func GetOperationType(name string) OperationType <span class="cov0" title="0">{
        switch name </span>{
        case "nix-generations":<span class="cov0" title="0">
                return OperationTypeNixGenerations</span>
        case "temp-files":<span class="cov0" title="0">
                return OperationTypeTempFiles</span>
        case "homebrew-cleanup":<span class="cov0" title="0">
                return OperationTypeHomebrew</span>
        case "system-temp":<span class="cov0" title="0">
                return OperationTypeSystemTemp</span>
        default:<span class="cov0" title="0">
                return OperationType(name)</span> // Fallback for custom types
        }
}

// DefaultSettings returns default settings for the given operation type
func DefaultSettings(opType OperationType) *OperationSettings <span class="cov0" title="0">{
        switch opType </span>{
        case OperationTypeNixGenerations:<span class="cov0" title="0">
                return &amp;OperationSettings{
                        NixGenerations: &amp;NixGenerationsSettings{
                                Generations: 1,
                                Optimize:    false,
                        },
                }</span>
        case OperationTypeTempFiles:<span class="cov0" title="0">
                return &amp;OperationSettings{
                        TempFiles: &amp;TempFilesSettings{
                                OlderThan: "7d",
                                Excludes:  []string{"/tmp/keep"},
                        },
                }</span>
        case OperationTypeHomebrew:<span class="cov0" title="0">
                return &amp;OperationSettings{
                        Homebrew: &amp;HomebrewSettings{
                                UnusedOnly: true,
                        },
                }</span>
        case OperationTypeSystemTemp:<span class="cov0" title="0">
                return &amp;OperationSettings{
                        SystemTemp: &amp;SystemTempSettings{
                                Paths:     []string{"/tmp", "/var/tmp"},
                                OlderThan: "30d",
                        },
                }</span>
        default:<span class="cov0" title="0">
                return &amp;OperationSettings{}</span> // Empty settings for custom types
        }
}

// ValidateSettings validates settings for the given operation type
func (os *OperationSettings) ValidateSettings(opType OperationType) error <span class="cov0" title="0">{
        switch opType </span>{
        case OperationTypeNixGenerations:<span class="cov0" title="0">
                if os.NixGenerations == nil </span><span class="cov0" title="0">{
                        return nil // Optional settings
                }</span>
                <span class="cov0" title="0">if os.NixGenerations.Generations &lt; 1 || os.NixGenerations.Generations &gt; 10 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   "nix_generations.generations",
                                Message: "generations must be between 1 and 10",
                                Value:   os.NixGenerations.Generations,
                        }
                }</span>
        case OperationTypeTempFiles:<span class="cov0" title="0">
                if os.TempFiles == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if os.TempFiles.OlderThan == "" </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   "temp_files.older_than",
                                Message: "older_than is required",
                                Value:   os.TempFiles.OlderThan,
                        }
                }</span>
                <span class="cov0" title="0">if _, err := ParseCustomDuration(os.TempFiles.OlderThan); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   "temp_files.older_than",
                                Message: "older_than must be a valid duration (e.g., '7d', '24h')",
                                Value:   os.TempFiles.OlderThan,
                        }
                }</span>
        case OperationTypeHomebrew:<span class="cov0" title="0"></span>
                // Homebrew settings are always valid
        case OperationTypeSystemTemp:<span class="cov0" title="0">
                if os.SystemTemp == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if len(os.SystemTemp.Paths) == 0 </span><span class="cov0" title="0">{
                        return &amp;ValidationError{
                                Field:   "system_temp.paths",
                                Message: "paths are required",
                                Value:   os.SystemTemp.Paths,
                        }
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ValidationError represents a settings validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
        Value   any    `json:"value"`
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>

      <pre class="file" id="file49" style="display: none">package domain

import (
        "encoding/json"
        "fmt"
        "strings"
)

// TypeSafeEnum provides compile-time guaranteed enums with JSON serialization
type TypeSafeEnum[T any] interface {
        String() string
        IsValid() bool
        Values() []T
}

// RiskLevelType represents the risk level enum with compile-time safety
type RiskLevelType int

const (
        RiskLevelLowType RiskLevelType = iota
        RiskLevelMediumType
        RiskLevelHighType
        RiskLevelCriticalType
)

// String returns the string representation
func (rl RiskLevelType) String() string <span class="cov7" title="5">{
        switch rl </span>{
        case RiskLevelLowType:<span class="cov1" title="1">
                return "LOW"</span>
        case RiskLevelMediumType:<span class="cov1" title="1">
                return "MEDIUM"</span>
        case RiskLevelHighType:<span class="cov1" title="1">
                return "HIGH"</span>
        case RiskLevelCriticalType:<span class="cov4" title="2">
                return "CRITICAL"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// IsValid checks if risk level is valid
func (rl RiskLevelType) IsValid() bool <span class="cov10" title="8">{
        return rl &gt;= RiskLevelLowType &amp;&amp; rl &lt;= RiskLevelCriticalType
}</span>

// Values returns all possible values
func (rl RiskLevelType) Values() []RiskLevelType <span class="cov0" title="0">{
        return []RiskLevelType{
                RiskLevelLowType,
                RiskLevelMediumType,
                RiskLevelHighType,
                RiskLevelCriticalType,
        }
}</span>

// MarshalJSON implements json.Marshaler
func (rl RiskLevelType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if !rl.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid risk level: %d", rl)
        }</span>
        <span class="cov0" title="0">return json.Marshal(rl.String())</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (rl *RiskLevelType) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(s) </span>{
        case "LOW":<span class="cov0" title="0">
                *rl = RiskLevelLowType</span>
        case "MEDIUM":<span class="cov0" title="0">
                *rl = RiskLevelMediumType</span>
        case "HIGH":<span class="cov0" title="0">
                *rl = RiskLevelHighType</span>
        case "CRITICAL":<span class="cov0" title="0">
                *rl = RiskLevelCriticalType</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid risk level: %s", s)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Icon returns emoji for risk level
func (rl RiskLevelType) Icon() string <span class="cov7" title="4">{
        switch rl </span>{
        case RiskLevelLowType:<span class="cov0" title="0">
                return "üü¢"</span>
        case RiskLevelMediumType:<span class="cov0" title="0">
                return "üü°"</span>
        case RiskLevelHighType:<span class="cov0" title="0">
                return "üü†"</span>
        case RiskLevelCriticalType:<span class="cov1" title="1">
                return "üî¥"</span>
        default:<span class="cov5" title="3">
                return "‚ö™"</span>
        }
}

// IsHigherThan returns true if this risk level is higher than comparison
func (rl RiskLevelType) IsHigherThan(other RiskLevelType) bool <span class="cov0" title="0">{
        return rl &gt; other
}</span>

// IsHigherOrEqualThan returns true if this risk level is higher or equal than comparison
func (rl RiskLevelType) IsHigherOrEqualThan(other RiskLevelType) bool <span class="cov0" title="0">{
        return rl &gt;= other
}</span>

// Convenience constants for backward compatibility are now in types.go

// ValidationLevelType represents validation levels with compile-time safety
type ValidationLevelType int

const (
        ValidationLevelNoneType ValidationLevelType = iota
        ValidationLevelBasicType
        ValidationLevelComprehensiveType
        ValidationLevelStrictType
)

// String returns the string representation
func (vl ValidationLevelType) String() string <span class="cov0" title="0">{
        switch vl </span>{
        case ValidationLevelNoneType:<span class="cov0" title="0">
                return "NONE"</span>
        case ValidationLevelBasicType:<span class="cov0" title="0">
                return "BASIC"</span>
        case ValidationLevelComprehensiveType:<span class="cov0" title="0">
                return "COMPREHENSIVE"</span>
        case ValidationLevelStrictType:<span class="cov0" title="0">
                return "STRICT"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// IsValid checks if validation level is valid
func (vl ValidationLevelType) IsValid() bool <span class="cov0" title="0">{
        return vl &gt;= ValidationLevelNoneType &amp;&amp; vl &lt;= ValidationLevelStrictType
}</span>

// Values returns all possible values
func (vl ValidationLevelType) Values() []ValidationLevelType <span class="cov0" title="0">{
        return []ValidationLevelType{
                ValidationLevelNoneType,
                ValidationLevelBasicType,
                ValidationLevelComprehensiveType,
                ValidationLevelStrictType,
        }
}</span>

// MarshalJSON implements json.Marshaler
func (vl ValidationLevelType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if !vl.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid validation level: %d", vl)
        }</span>
        <span class="cov0" title="0">return json.Marshal(vl.String())</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (vl *ValidationLevelType) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(s) </span>{
        case "NONE":<span class="cov0" title="0">
                *vl = ValidationLevelNoneType</span>
        case "BASIC":<span class="cov0" title="0">
                *vl = ValidationLevelBasicType</span>
        case "COMPREHENSIVE":<span class="cov0" title="0">
                *vl = ValidationLevelComprehensiveType</span>
        case "STRICT":<span class="cov0" title="0">
                *vl = ValidationLevelStrictType</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid validation level: %s", s)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Convenience constants for backward compatibility are now in types.go

// ChangeOperationType represents change operations with compile-time safety
type ChangeOperationType int

const (
        ChangeOperationAddedType ChangeOperationType = iota
        ChangeOperationRemovedType
        ChangeOperationModifiedType
)

// String returns the string representation
func (co ChangeOperationType) String() string <span class="cov0" title="0">{
        switch co </span>{
        case ChangeOperationAddedType:<span class="cov0" title="0">
                return "ADDED"</span>
        case ChangeOperationRemovedType:<span class="cov0" title="0">
                return "REMOVED"</span>
        case ChangeOperationModifiedType:<span class="cov0" title="0">
                return "MODIFIED"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// IsValid checks if change operation is valid
func (co ChangeOperationType) IsValid() bool <span class="cov0" title="0">{
        return co &gt;= ChangeOperationAddedType &amp;&amp; co &lt;= ChangeOperationModifiedType
}</span>

// Values returns all possible values
func (co ChangeOperationType) Values() []ChangeOperationType <span class="cov0" title="0">{
        return []ChangeOperationType{
                ChangeOperationAddedType,
                ChangeOperationRemovedType,
                ChangeOperationModifiedType,
        }
}</span>

// MarshalJSON implements json.Marshaler
func (co ChangeOperationType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if !co.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid change operation: %d", co)
        }</span>
        <span class="cov0" title="0">return json.Marshal(co.String())</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (co *ChangeOperationType) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch strings.ToUpper(s) </span>{
        case "ADDED":<span class="cov0" title="0">
                *co = ChangeOperationAddedType</span>
        case "REMOVED":<span class="cov0" title="0">
                *co = ChangeOperationRemovedType</span>
        case "MODIFIED":<span class="cov0" title="0">
                *co = ChangeOperationModifiedType</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid change operation: %s", s)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CleanStrategyType represents cleaning strategies with compile-time safety
type CleanStrategyType int

const (
        StrategyAggressiveType CleanStrategyType = iota
        StrategyConservativeType
        StrategyDryRunType
)

// String returns string representation
func (cs CleanStrategyType) String() string <span class="cov1" title="1">{
        switch cs </span>{
        case StrategyAggressiveType:<span class="cov0" title="0">
                return "aggressive"</span>
        case StrategyConservativeType:<span class="cov0" title="0">
                return "conservative"</span>
        case StrategyDryRunType:<span class="cov0" title="0">
                return "dry-run"</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// IsValid checks if clean strategy is valid
func (cs CleanStrategyType) IsValid() bool <span class="cov10" title="8">{
        return cs &gt;= StrategyAggressiveType &amp;&amp; cs &lt;= StrategyDryRunType
}</span>

// Values returns all possible values
func (cs CleanStrategyType) Values() []CleanStrategyType <span class="cov0" title="0">{
        return []CleanStrategyType{
                StrategyAggressiveType,
                StrategyConservativeType,
                StrategyDryRunType,
        }
}</span>

// MarshalJSON implements json.Marshaler
func (cs CleanStrategyType) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if !cs.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid clean strategy: %d", cs)
        }</span>
        <span class="cov0" title="0">return json.Marshal(cs.String())</span>
}

// UnmarshalJSON implements json.Unmarshaler
func (cs *CleanStrategyType) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch strings.ToLower(s) </span>{
        case "aggressive":<span class="cov0" title="0">
                *cs = StrategyAggressiveType</span>
        case "conservative":<span class="cov0" title="0">
                *cs = StrategyConservativeType</span>
        case "dry-run", "dryrun":<span class="cov0" title="0">
                *cs = StrategyDryRunType</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid clean strategy: %s", s)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Icon returns emoji for clean strategy
func (cs CleanStrategyType) Icon() string <span class="cov0" title="0">{
        switch cs </span>{
        case StrategyAggressiveType:<span class="cov0" title="0">
                return "üî•"</span>
        case StrategyConservativeType:<span class="cov0" title="0">
                return "üõ°Ô∏è"</span>
        case StrategyDryRunType:<span class="cov0" title="0">
                return "üîç"</span>
        default:<span class="cov0" title="0">
                return "‚ùì"</span>
        }
}

// Convenience constants for backward compatibility are now in types.go
</pre>

      <pre class="file" id="file50" style="display: none">package domain

import (
        "fmt"
        "time"
)

// Backward compatibility aliases - delegate to type-safe enums
type (
        RiskLevel       = RiskLevelType
        ValidationLevel = ValidationLevelType
        ChangeOperation = ChangeOperationType
)

// Backward compatibility constants - point to type-safe enums
var (
        RiskLow      = RiskLevelType(RiskLevelLowType)
        RiskMedium   = RiskLevelType(RiskLevelMediumType)
        RiskHigh     = RiskLevelType(RiskLevelHighType)
        RiskCritical = RiskLevelType(RiskLevelCriticalType)

        ValidationLevelNone          = ValidationLevelType(ValidationLevelNoneType)
        ValidationLevelBasic         = ValidationLevelType(ValidationLevelBasicType)
        ValidationLevelComprehensive = ValidationLevelType(ValidationLevelComprehensiveType)
        ValidationLevelStrict        = ValidationLevelType(ValidationLevelStrictType)

        OperationAdded    = ChangeOperationType(ChangeOperationAddedType)
        OperationRemoved  = ChangeOperationType(ChangeOperationRemovedType)
        OperationModified = ChangeOperationType(ChangeOperationModifiedType)
)

// CleanStrategy represents cleaning strategy with type safety
type CleanStrategy = CleanStrategyType

// Backward compatibility constants - delegate to type-safe enums
var (
        StrategyAggressive   = CleanStrategyType(StrategyAggressiveType)
        StrategyConservative = CleanStrategyType(StrategyConservativeType)
        StrategyDryRun       = CleanStrategyType(StrategyDryRunType)
)

// NixGeneration represents Nix store generation
type NixGeneration struct {
        ID      int       `json:"id"`
        Path    string    `json:"path"`
        Date    time.Time `json:"date"`
        Current bool      `json:"current"`
}

// IsValid validates generation
func (g NixGeneration) IsValid() bool <span class="cov1" title="1">{
        return g.ID &gt; 0 &amp;&amp; g.Path != "" &amp;&amp; !g.Date.IsZero()
}</span>

// Validate returns errors for invalid generation
func (g NixGeneration) Validate() error <span class="cov0" title="0">{
        if g.ID &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Generation ID must be positive, got: %d", g.ID)
        }</span>
        <span class="cov0" title="0">if g.Path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Generation path cannot be empty")
        }</span>
        <span class="cov0" title="0">if g.Date.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("Generation date cannot be zero")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// EstimateSize estimates the size of this generation in bytes
// This is a rough estimate used when actual size calculation is not available
func (g NixGeneration) EstimateSize() int64 <span class="cov0" title="0">{
        // Rough estimate: 50MB per generation as baseline with adjustments
        // Older generations tend to be larger, newer ones smaller
        baseSize := int64(50 * 1024 * 1024) // 50MB base
        age := time.Since(g.Date)
        ageFactor := int64(age.Hours() / 24 / 30)        // Age in months
        return baseSize + (ageFactor * 10 * 1024 * 1024) // Add 10MB per month
}</span>

// ScanType represents different scanning domains
type ScanType string

const (
        ScanTypeNixStore ScanType = "nix_store"
        ScanTypeHomebrew ScanType = "homebrew"
        ScanTypeSystem   ScanType = "system"
        ScanTypeTemp     ScanType = "temp_files"
)

// IsValid validates ScanType
func (st ScanType) IsValid() bool <span class="cov0" title="0">{
        switch st </span>{
        case ScanTypeNixStore, ScanTypeHomebrew, ScanTypeSystem, ScanTypeTemp:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// ScanRequest represents scanning command
type ScanRequest struct {
        Type      ScanType `json:"type"`
        Recursive bool     `json:"recursive"`
        Limit     int      `json:"limit"`
}

// Validate returns errors for invalid scan request
func (sr ScanRequest) Validate() error <span class="cov0" title="0">{
        if !sr.Type.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid scan type: %s", sr.Type)
        }</span>
        <span class="cov0" title="0">if sr.Limit &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Limit cannot be negative, got: %d", sr.Limit)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ScanItem represents item found during scanning
type ScanItem struct {
        Path     string    `json:"path"`
        Size     int64     `json:"size"`
        Created  time.Time `json:"created"`
        ScanType ScanType  `json:"scan_type"`
}

// CleanRequest represents cleaning command
type CleanRequest struct {
        Items    []ScanItem    `json:"items"`
        Strategy CleanStrategy `json:"strategy"`
}

// Validate returns errors for invalid clean request
func (cr CleanRequest) Validate() error <span class="cov0" title="0">{
        if !cr.Strategy.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid strategy: %s (must be 'aggressive', 'conservative', or 'dry-run')", cr.Strategy)
        }</span>
        <span class="cov0" title="0">if len(cr.Items) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Items cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ScanResult represents successful scan outcome
type ScanResult struct {
        TotalBytes   int64         `json:"total_bytes"`
        TotalItems   int           `json:"total_items"`
        ScannedPaths []string      `json:"scanned_paths"`
        ScanTime     time.Duration `json:"scan_time"`
        ScannedAt    time.Time     `json:"scanned_at"`
}

// IsValid checks if scan result is valid
func (sr ScanResult) IsValid() bool <span class="cov0" title="0">{
        return sr.TotalBytes &gt;= 0 &amp;&amp; sr.TotalItems &gt;= 0 &amp;&amp; sr.ScanTime &gt;= 0 &amp;&amp; !sr.ScannedAt.IsZero()
}</span>

// Validate returns errors for invalid scan result
func (sr ScanResult) Validate() error <span class="cov0" title="0">{
        if sr.TotalBytes &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("TotalBytes cannot be negative, got: %d", sr.TotalBytes)
        }</span>
        <span class="cov0" title="0">if sr.TotalItems &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("TotalItems cannot be negative, got: %d", sr.TotalItems)
        }</span>
        <span class="cov0" title="0">if sr.ScanTime &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ScanTime cannot be negative, got: %d", sr.ScanTime)
        }</span>
        <span class="cov0" title="0">if sr.ScannedAt.IsZero() </span><span class="cov0" title="0">{
                return fmt.Errorf("ScannedAt cannot be zero")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CleanResult represents successful clean outcome
type CleanResult struct {
        FreedBytes   uint64        `json:"freed_bytes"`
        ItemsRemoved uint          `json:"items_removed"`
        ItemsFailed  uint          `json:"items_failed"`
        CleanTime    time.Duration `json:"clean_time"`
        CleanedAt    time.Time     `json:"cleaned_at"`
        Strategy     CleanStrategy `json:"strategy"`
}

// IsValid checks if clean result is valid
func (cr CleanResult) IsValid() bool <span class="cov10" title="7">{
        // Cannot remove items without freeing bytes
        if cr.ItemsRemoved &gt; 0 &amp;&amp; cr.FreedBytes == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        // Cannot fail items without any activity
        <span class="cov9" title="6">if cr.ItemsFailed &gt; 0 &amp;&amp; cr.ItemsRemoved == 0 &amp;&amp; cr.FreedBytes == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        // Other validations
        <span class="cov8" title="5">return cr.CleanedAt.IsZero() == false &amp;&amp; cr.Strategy.IsValid()</span>
}

// Validate returns errors for invalid clean result
func (cr CleanResult) Validate() error <span class="cov10" title="7">{
        // Cannot remove items without freeing bytes
        if cr.ItemsRemoved &gt; 0 &amp;&amp; cr.FreedBytes == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot have zero FreedBytes when ItemsRemoved is &gt; 0")
        }</span>
        // Cannot fail items without any activity (removed or freed)
        <span class="cov9" title="6">if cr.ItemsFailed &gt; 0 &amp;&amp; cr.ItemsRemoved == 0 &amp;&amp; cr.FreedBytes == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("cannot have failed items when no items were processed")
        }</span>
        <span class="cov8" title="5">if cr.CleanedAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("CleanedAt cannot be zero")
        }</span>
        <span class="cov7" title="4">if !cr.Strategy.IsValid() </span><span class="cov1" title="1">{
                return fmt.Errorf("Invalid strategy: %s (must be 'aggressive', 'conservative', or 'dry-run')", cr.Strategy)
        }</span>
        <span class="cov6" title="3">return nil</span>
}
</pre>

      <pre class="file" id="file51" style="display: none">package errors

import (
        "fmt"
)

// ConfigLoadError creates a configuration loading error
func ConfigLoadError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("config load error: %w", err)
}</span>

// ConfigSaveError creates a configuration saving error
func ConfigSaveError(err error) error <span class="cov0" title="0">{
        return fmt.Errorf("config save error: %w", err)
}</span>

// ConfigValidateError creates a configuration validation error
func ConfigValidateError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("config validation error: %s", message)
}</span>

// CleanOperationError creates a cleaning operation error
func CleanOperationError(operation string, err error) error <span class="cov0" title="0">{
        return fmt.Errorf("clean operation '%s' failed: %w", operation, err)
}</span>

// ScanOperationError creates a scanning operation error
func ScanOperationError(scanner string, err error) error <span class="cov0" title="0">{
        return fmt.Errorf("scan operation '%s' failed: %w", scanner, err)
}</span>

// SafetyError creates a safety check error
func SafetyError(message string) error <span class="cov0" title="0">{
        return fmt.Errorf("safety check failed: %s", message)
}</span>

// InputValidationError creates an input validation error
func InputValidationError(field, value string) error <span class="cov0" title="0">{
        return fmt.Errorf("invalid input for field '%s': %s", field, value)
}</span>
</pre>

      <pre class="file" id="file52" style="display: none">package format

// Bytes formats bytes for display (alias for Size for consistency)
func Bytes(bytes int64) string <span class="cov0" title="0">{
        return Size(bytes)
}</span>
</pre>

      <pre class="file" id="file53" style="display: none">package format

import (
        "fmt"
        "time"
)

// Size formats bytes for human reading
func Size(bytes int64) string <span class="cov6" title="9">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov3" title="3">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov5" title="6">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov7" title="15">{
                div *= unit
                exp++
        }</span>
        <span class="cov5" title="6">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// Duration formats duration for human reading
func Duration(d time.Duration) string <span class="cov6" title="7">{
        if d &lt; time.Millisecond </span><span class="cov3" title="3">{
                return fmt.Sprintf("%.0f ns", float64(d.Nanoseconds()))
        }</span>
        <span class="cov4" title="4">if d &lt; time.Second </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.1f ms", float64(d.Nanoseconds())/1e6)
        }</span>
        <span class="cov3" title="3">if d &lt; time.Minute </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.1f s", d.Seconds())
        }</span>
        <span class="cov2" title="2">if d &lt; time.Hour </span><span class="cov1" title="1">{
                return fmt.Sprintf("%.1f m", d.Minutes())
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%.1f h", d.Hours())</span>
}

// Date formats date for human reading
func Date(t time.Time) string <span class="cov3" title="3">{
        if t.IsZero() </span><span class="cov1" title="1">{
                return "never"
        }</span>
        <span class="cov2" title="2">return t.Format("2006-01-02")</span>
}

// DateTime formats date and time for human reading
func DateTime(t time.Time) string <span class="cov3" title="3">{
        if t.IsZero() </span><span class="cov1" title="1">{
                return "never"
        }</span>
        <span class="cov2" title="2">return t.Format("2006-01-02 15:04:05")</span>
}

// Number formats number with thousand separators
func Number(n int64) string <span class="cov6" title="8">{
        s := fmt.Sprintf("%d", n)

        // Add commas for thousands
        var result []rune
        for i, r := range s </span><span class="cov10" title="33">{
                if i &gt; 0 &amp;&amp; (len(s)-i)%3 == 0 </span><span class="cov6" title="7">{
                        result = append(result, ',')
                }</span>
                <span class="cov10" title="33">result = append(result, r)</span>
        }

        <span class="cov6" title="8">return string(result)</span>
}
</pre>

      <pre class="file" id="file54" style="display: none">package middleware

import (
        "context"
        "fmt"

        "github.com/LarsArtmann/clean-wizard/internal/domain"
        "github.com/LarsArtmann/clean-wizard/internal/result"
)

// ValidationMiddleware provides validation for all operations
type ValidationMiddleware struct{}

// NewValidationMiddleware creates validation middleware
func NewValidationMiddleware() *ValidationMiddleware <span class="cov1" title="1">{
        return &amp;ValidationMiddleware{}
}</span>

// ValidateScanRequest validates scan request before processing
func (vm *ValidationMiddleware) ValidateScanRequest(ctx context.Context, req domain.ScanRequest) result.Result[domain.ScanRequest] <span class="cov10" title="2">{
        if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                return result.Err[domain.ScanRequest](fmt.Errorf("invalid scan request: %w", err))
        }</span>
        <span class="cov1" title="1">return result.Ok(req)</span>
}

// ValidateCleanRequest validates clean request before processing
func (vm *ValidationMiddleware) ValidateCleanRequest(ctx context.Context, req domain.CleanRequest) result.Result[domain.CleanRequest] <span class="cov10" title="2">{
        if err := req.Validate(); err != nil </span><span class="cov1" title="1">{
                return result.Err[domain.CleanRequest](fmt.Errorf("invalid clean request: %w", err))
        }</span>
        <span class="cov1" title="1">return result.Ok(req)</span>
}

// ValidateCleanerSettings validates cleaner settings with type safety
func (vm *ValidationMiddleware) ValidateCleanerSettings(ctx context.Context, cleaner domain.Cleaner, settings *domain.OperationSettings) result.Result[*domain.OperationSettings] <span class="cov10" title="2">{
        if err := cleaner.ValidateSettings(settings); err != nil </span><span class="cov1" title="1">{
                return result.Err[*domain.OperationSettings](fmt.Errorf("invalid cleaner settings: %w", err))
        }</span>
        <span class="cov1" title="1">return result.Ok(settings)</span>
}
</pre>

      <pre class="file" id="file55" style="display: none">package errors

import (
        "fmt"
        "runtime"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// ErrorCode represents standardized error codes
type ErrorCode int

const (
        // General errors
        ErrUnknown ErrorCode = iota
        ErrInvalidInput
        ErrNotFound
        ErrPermissionDenied
        ErrTimeout

        // Configuration errors
        ErrConfigLoad
        ErrConfigSave
        ErrConfigValidation

        // Nix-specific errors
        ErrNixNotAvailable
        ErrNixCommandFailed
        ErrNixStoreCorrupted

        // Cleaning errors
        ErrCleaningFailed
        ErrCleaningTimeout
        ErrCleanupRollback
)

// String returns string representation of error code
func (e ErrorCode) String() string <span class="cov0" title="0">{
        switch e </span>{
        case ErrUnknown:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        case ErrInvalidInput:<span class="cov0" title="0">
                return "INVALID_INPUT"</span>
        case ErrNotFound:<span class="cov0" title="0">
                return "NOT_FOUND"</span>
        case ErrPermissionDenied:<span class="cov0" title="0">
                return "PERMISSION_DENIED"</span>
        case ErrTimeout:<span class="cov0" title="0">
                return "TIMEOUT"</span>
        case ErrConfigLoad:<span class="cov0" title="0">
                return "CONFIG_LOAD"</span>
        case ErrConfigSave:<span class="cov0" title="0">
                return "CONFIG_SAVE"</span>
        case ErrConfigValidation:<span class="cov0" title="0">
                return "CONFIG_VALIDATION"</span>
        case ErrNixNotAvailable:<span class="cov0" title="0">
                return "NIX_NOT_AVAILABLE"</span>
        case ErrNixCommandFailed:<span class="cov0" title="0">
                return "NIX_COMMAND_FAILED"</span>
        case ErrNixStoreCorrupted:<span class="cov0" title="0">
                return "NIX_STORE_CORRUPTED"</span>
        case ErrCleaningFailed:<span class="cov0" title="0">
                return "CLEANING_FAILED"</span>
        case ErrCleaningTimeout:<span class="cov0" title="0">
                return "CLEANING_TIMEOUT"</span>
        case ErrCleanupRollback:<span class="cov0" title="0">
                return "CLEANUP_ROLLBACK"</span>
        default:<span class="cov0" title="0">
                return "UNDEFINED"</span>
        }
}

// ErrorLevel represents severity of error
type ErrorLevel int

const (
        LevelInfo ErrorLevel = iota
        LevelWarn
        LevelError
        LevelFatal
)

// String returns string representation of error level
func (e ErrorLevel) String() string <span class="cov0" title="0">{
        switch e </span>{
        case LevelInfo:<span class="cov0" title="0">
                return "INFO"</span>
        case LevelWarn:<span class="cov0" title="0">
                return "WARN"</span>
        case LevelError:<span class="cov0" title="0">
                return "ERROR"</span>
        case LevelFatal:<span class="cov0" title="0">
                return "FATAL"</span>
        default:<span class="cov0" title="0">
                return "UNDEFINED"</span>
        }
}

// ErrorDetails represents strongly-typed error context information
type ErrorDetails struct {
        Field      string            `json:"field,omitempty"`
        Value      string            `json:"value,omitempty"`
        Expected   string            `json:"expected,omitempty"`
        Actual     string            `json:"actual,omitempty"`
        Operation  string            `json:"operation,omitempty"`
        FilePath   string            `json:"file_path,omitempty"`
        LineNumber int               `json:"line_number,omitempty"`
        RetryCount int               `json:"retry_count,omitempty"`
        Duration   string            `json:"duration,omitempty"`
        Metadata   map[string]string `json:"metadata,omitempty"`
}

// CleanWizardError represents structured error with context
type CleanWizardError struct {
        Code      ErrorCode
        Level     ErrorLevel
        Message   string
        Operation string
        Details   *ErrorDetails `json:"details,omitempty"`
        Timestamp time.Time
        Stack     string
}

// Error implements error interface
func (e *CleanWizardError) Error() string <span class="cov0" title="0">{
        if e.Details == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("[%s] %s: %s", e.Level.String(), e.Code.String(), e.Message)
        }</span>

        <span class="cov0" title="0">var details []string
        if e.Details.Field != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("field=%s", e.Details.Field))
        }</span>
        <span class="cov0" title="0">if e.Details.Value != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("value=%s", e.Details.Value))
        }</span>
        <span class="cov0" title="0">if e.Details.Expected != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("expected=%s", e.Details.Expected))
        }</span>
        <span class="cov0" title="0">if e.Details.Actual != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("actual=%s", e.Details.Actual))
        }</span>
        <span class="cov0" title="0">if e.Details.Operation != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("operation=%s", e.Details.Operation))
        }</span>
        <span class="cov0" title="0">if e.Details.FilePath != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("file=%s", e.Details.FilePath))
        }</span>
        <span class="cov0" title="0">if e.Details.LineNumber &gt; 0 </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("line=%d", e.Details.LineNumber))
        }</span>
        <span class="cov0" title="0">if e.Details.RetryCount &gt; 0 </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("retries=%d", e.Details.RetryCount))
        }</span>
        <span class="cov0" title="0">if e.Details.Duration != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("duration=%s", e.Details.Duration))
        }</span>

        // Add metadata details
        <span class="cov0" title="0">for key, value := range e.Details.Metadata </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("%s=%s", key, value))
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[%s] %s: %s (details: %s)",
                e.Level.String(), e.Code.String(), e.Message, strings.Join(details, ", "))</span>
}

// Unwrap returns underlying error if any
func (e *CleanWizardError) Unwrap() error <span class="cov0" title="0">{
        return nil
}</span>

// NewError creates new CleanWizardError
func NewError(code ErrorCode, message string) *CleanWizardError <span class="cov0" title="0">{
        return &amp;CleanWizardError{
                Code:      code,
                Level:     LevelError,
                Message:   message,
                Details:   nil,
                Timestamp: time.Now(),
                Stack:     captureStack(),
        }
}</span>

// NewErrorWithLevel creates new CleanWizardError with custom level
func NewErrorWithLevel(code ErrorCode, level ErrorLevel, message string) *CleanWizardError <span class="cov0" title="0">{
        return &amp;CleanWizardError{
                Code:      code,
                Level:     level,
                Message:   message,
                Details:   nil,
                Timestamp: time.Now(),
                Stack:     captureStack(),
        }
}</span>

// NewErrorWithDetails creates new CleanWizardError with context details
func NewErrorWithDetails(code ErrorCode, message string, details *ErrorDetails) *CleanWizardError <span class="cov0" title="0">{
        err := &amp;CleanWizardError{
                Code:      code,
                Level:     LevelError,
                Message:   message,
                Details:   details,
                Timestamp: time.Now(),
                Stack:     captureStack(),
        }

        return err
}</span>

// WithOperation adds operation context to error
func (e *CleanWizardError) WithOperation(operation string) *CleanWizardError <span class="cov0" title="0">{
        e.Operation = operation
        return e
}</span>

// WithDetail adds single detail to error
func (e *CleanWizardError) WithDetail(key string, value any) *CleanWizardError <span class="cov0" title="0">{
        if e.Details == nil </span><span class="cov0" title="0">{
                e.Details = &amp;ErrorDetails{
                        Metadata: make(map[string]string),
                }
        }</span>

        <span class="cov0" title="0">switch key </span>{
        case "field":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Field = v
                }</span>
        case "value":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Value = v
                }</span> else<span class="cov0" title="0"> {
                        e.Details.Value = fmt.Sprintf("%v", value)
                }</span>
        case "expected":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Expected = v
                }</span> else<span class="cov0" title="0"> {
                        e.Details.Expected = fmt.Sprintf("%v", value)
                }</span>
        case "actual":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Actual = v
                }</span> else<span class="cov0" title="0"> {
                        e.Details.Actual = fmt.Sprintf("%v", value)
                }</span>
        case "operation":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Operation = v
                }</span>
        case "file_path":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.FilePath = v
                }</span>
        case "line_number":<span class="cov0" title="0">
                if v, ok := value.(int); ok </span><span class="cov0" title="0">{
                        e.Details.LineNumber = v
                }</span>
        case "retry_count":<span class="cov0" title="0">
                if v, ok := value.(int); ok </span><span class="cov0" title="0">{
                        e.Details.RetryCount = v
                }</span>
        case "duration":<span class="cov0" title="0">
                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                        e.Details.Duration = v
                }</span> else<span class="cov0" title="0"> if d, ok := value.(time.Duration); ok </span><span class="cov0" title="0">{
                        e.Details.Duration = d.String()
                }</span> else<span class="cov0" title="0"> {
                        e.Details.Duration = fmt.Sprintf("%v", value)
                }</span>
        default:<span class="cov0" title="0">
                // Store unknown keys in metadata
                if e.Details.Metadata == nil </span><span class="cov0" title="0">{
                        e.Details.Metadata = make(map[string]string)
                }</span>
                <span class="cov0" title="0">e.Details.Metadata[key] = fmt.Sprintf("%v", value)</span>
        }

        <span class="cov0" title="0">return e</span>
}

// WithLevel updates error level
func (e *CleanWizardError) WithLevel(level ErrorLevel) *CleanWizardError <span class="cov0" title="0">{
        e.Level = level
        return e
}</span>

// IsLevel checks if error is at or above specified level
func (e *CleanWizardError) IsLevel(level ErrorLevel) bool <span class="cov0" title="0">{
        return e.Level &gt;= level
}</span>

// IsErrorCode checks if error has specific code
func (e *CleanWizardError) IsErrorCode(code ErrorCode) bool <span class="cov0" title="0">{
        return e.Code == code
}</span>

// captureStack captures current stack trace
func captureStack() string <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        if n &gt; 0 &amp;&amp; n &lt; len(buf) </span><span class="cov0" title="0">{
                return string(buf[:n])
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IsRetryable determines if error operation can be retried
func (e *CleanWizardError) IsRetryable() bool <span class="cov0" title="0">{
        switch e.Code </span>{
        case ErrTimeout, ErrNixCommandFailed:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsUserFriendly determines if error is suitable for end-user display
func (e *CleanWizardError) IsUserFriendly() bool <span class="cov0" title="0">{
        switch e.Level </span>{
        case LevelInfo, LevelWarn:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return e.Code == ErrNixNotAvailable || e.Code == ErrConfigValidation</span>
        }
}

// Log logs error with appropriate level
func (e *CleanWizardError) Log() <span class="cov0" title="0">{
        fields := logrus.Fields{
                "code":      e.Code.String(),
                "level":     e.Level.String(),
                "operation": e.Operation,
                "timestamp": e.Timestamp,
        }

        if e.Details != nil </span><span class="cov0" title="0">{
                if e.Details.Field != "" </span><span class="cov0" title="0">{
                        fields["detail_field"] = e.Details.Field
                }</span>
                <span class="cov0" title="0">if e.Details.Value != "" </span><span class="cov0" title="0">{
                        fields["detail_value"] = e.Details.Value
                }</span>
                <span class="cov0" title="0">if e.Details.Expected != "" </span><span class="cov0" title="0">{
                        fields["detail_expected"] = e.Details.Expected
                }</span>
                <span class="cov0" title="0">if e.Details.Actual != "" </span><span class="cov0" title="0">{
                        fields["detail_actual"] = e.Details.Actual
                }</span>
                <span class="cov0" title="0">if e.Details.Operation != "" </span><span class="cov0" title="0">{
                        fields["detail_operation"] = e.Details.Operation
                }</span>
                <span class="cov0" title="0">if e.Details.FilePath != "" </span><span class="cov0" title="0">{
                        fields["detail_file_path"] = e.Details.FilePath
                }</span>
                <span class="cov0" title="0">if e.Details.LineNumber &gt; 0 </span><span class="cov0" title="0">{
                        fields["detail_line_number"] = e.Details.LineNumber
                }</span>
                <span class="cov0" title="0">if e.Details.RetryCount &gt; 0 </span><span class="cov0" title="0">{
                        fields["detail_retry_count"] = e.Details.RetryCount
                }</span>
                <span class="cov0" title="0">if e.Details.Duration != "" </span><span class="cov0" title="0">{
                        fields["detail_duration"] = e.Details.Duration
                }</span>

                // Add metadata
                <span class="cov0" title="0">for key, value := range e.Details.Metadata </span><span class="cov0" title="0">{
                        fields["meta_"+key] = value
                }</span>
        }

        <span class="cov0" title="0">entry := logrus.WithFields(fields)

        switch e.Level </span>{
        case LevelInfo:<span class="cov0" title="0">
                entry.Info(e.Message)</span>
        case LevelWarn:<span class="cov0" title="0">
                entry.Warn(e.Message)</span>
        case LevelError:<span class="cov0" title="0">
                entry.Error(e.Message)</span>
        case LevelFatal:<span class="cov0" title="0">
                entry.Fatal(e.Message)</span>
        }
}
</pre>

      <pre class="file" id="file56" style="display: none">package errors

import (
        "fmt"
        "os/exec"
)

// HandleCommandError standardizes command execution errors
func HandleCommandError(cmd *exec.Cmd, err error) *CleanWizardError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create base error
        <span class="cov0" title="0">baseErr := NewError(ErrNixCommandFailed, fmt.Sprintf("Command failed: %s", err.Error()))

        // Add command context
        baseErr = baseErr.
                WithOperation(fmt.Sprintf("exec: %s", cmd.String())).
                WithDetail("command", cmd.Args).
                WithDetail("path", cmd.Path)

        // Add specific error details based on error type
        if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                baseErr = baseErr.
                        WithDetail("exit_code", exitErr.ExitCode).
                        WithDetail("signal", exitErr.ProcessState.String())
        }</span>

        <span class="cov0" title="0">return baseErr</span>
}

// HandleNixNotAvailable standardizes Nix availability errors
func HandleNixNotAvailable(operation string) *CleanWizardError <span class="cov0" title="0">{
        return NewErrorWithLevel(ErrNixNotAvailable, LevelWarn,
                "Nix package manager is not available on this system").
                WithOperation(operation).
                WithDetail("suggestion", "Please install Nix or use mock mode for testing").
                WithDetail("documentation", "https://nixos.org/download.html")
}</span>

// HandleConfigError standardizes configuration errors
func HandleConfigError(operation string, err error) *CleanWizardError <span class="cov0" title="0">{
        baseErr := NewError(ErrConfigLoad, fmt.Sprintf("Configuration error: %s", err.Error()))
        baseErr.Operation = operation
        return baseErr
}</span>

// HandleValidationError standardizes validation errors
func HandleValidationError(operation string, err error) *CleanWizardError <span class="cov0" title="0">{
        baseErr := NewError(ErrConfigValidation, fmt.Sprintf("Validation error: %s", err.Error()))
        baseErr.Operation = operation
        baseErr.WithDetail("validation_type", "comprehensive")
        return baseErr
}</span>

// HandleValidationErrorWithDetails standardizes validation errors with detailed context
func HandleValidationErrorWithDetails(operation, field string, value any, reason string) *CleanWizardError <span class="cov0" title="0">{
        return NewErrorWithDetails(ErrConfigValidation,
                fmt.Sprintf("Validation failed for %s: %s", field, reason),
                &amp;ErrorDetails{
                        Operation: operation,
                        Field:     field,
                        Value:     fmt.Sprintf("%v", value),
                        Metadata: map[string]string{
                                "reason": reason,
                        },
                })
}</span>

// WrapError wraps existing error with CleanWizardError context
func WrapError(err error, code ErrorCode, operation string) *CleanWizardError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">cleanErr := NewError(code, err.Error())
        cleanErr.Operation = operation
        cleanErr.WithDetail("wrapped_error", err.Error())

        // If it's already a CleanWizardError, preserve details
        if wizardErr, ok := err.(*CleanWizardError); ok </span><span class="cov0" title="0">{
                cleanErr.Details = wizardErr.Details
                cleanErr.Stack = wizardErr.Stack
                cleanErr.Timestamp = wizardErr.Timestamp
        }</span>

        <span class="cov0" title="0">return cleanErr</span>
}

// IsNixAvailable checks if Nix is available on the system
func IsNixAvailable() bool <span class="cov0" title="0">{
        _, err := exec.LookPath("nix")
        return err == nil
}</span>
</pre>

      <pre class="file" id="file57" style="display: none">package result

// Result is a type-safe way to return values or errors
type Result[T any] struct {
        value T
        err   error
}

// Ok creates a successful result
func Ok[T any](value T) Result[T] <span class="cov9" title="10">{
        return Result[T]{value: value}
}</span>

// Err creates an error result
func Err[T any](err error) Result[T] <span class="cov9" title="10">{
        var zero T
        return Result[T]{value: zero, err: err}
}</span>

// IsOk returns true if result is successful
func (r Result[T]) IsOk() bool <span class="cov10" title="11">{
        return r.err == nil
}</span>

// IsErr returns true if result has error
func (r Result[T]) IsErr() bool <span class="cov6" title="4">{
        return r.err != nil
}</span>

// Unwrap returns value and error
func (r Result[T]) Unwrap() (T, error) <span class="cov0" title="0">{
        return r.value, r.err
}</span>

// Value returns value (panics if error)
func (r Result[T]) Value() T <span class="cov7" title="6">{
        if r.err != nil </span><span class="cov1" title="1">{
                panic("attempted to get value from error result: " + r.err.Error())</span>
        }
        <span class="cov7" title="5">return r.value</span>
}

// SafeValue returns value and error (never panics)
func (r Result[T]) SafeValue() (T, error) <span class="cov0" title="0">{
        if r.err != nil </span><span class="cov0" title="0">{
                var zero T
                return zero, r.err
        }</span>
        <span class="cov0" title="0">return r.value, nil</span>
}

// Error returns error (panics on success)
func (r Result[T]) Error() error <span class="cov7" title="6">{
        if r.err == nil </span><span class="cov1" title="1">{
                panic("attempted to get error from success result")</span>
        }
        <span class="cov7" title="5">return r.err</span>
}

// SafeError returns error and ok boolean (never panics)
func (r Result[T]) SafeError() (error, bool) <span class="cov0" title="0">{
        return r.err, r.err != nil
}</span>

// UnwrapOr returns value or default if error
func (r Result[T]) UnwrapOr(default_ T) T <span class="cov3" title="2">{
        if r.err != nil </span><span class="cov1" title="1">{
                return default_
        }</span>
        <span class="cov1" title="1">return r.value</span>
}

// Map applies function to value if successful, passes through error
func Map[T, U any](r Result[T], fn func(T) U) Result[U] <span class="cov3" title="2">{
        if r.err != nil </span><span class="cov1" title="1">{
                return Err[U](r.err)
        }</span>
        <span class="cov1" title="1">return Ok(fn(r.value))</span>
}

// MockSuccess creates a successful result with warning message
func MockSuccess[T any](value T, message string) Result[T] <span class="cov0" title="0">{
        return Ok(value)
}</span>
</pre>
    </div>
  </body>
  <script>
    (function() {
    	var files = document.getElementById('files');
    	var visible;
    	files.addEventListener('change', onChange, false);
    	function select(part) {
    		if (visible)
    			visible.style.display = 'none';
    		visible = document.getElementById(part);
    		if (!visible)
    			return;
    		files.value = part;
    		visible.style.display = 'block';
    		location.hash = part;
    	}
    	function onChange() {
    		select(files.value);
    		window.scrollTo(0, 0);
    	}
    	if (location.hash != "") {
    		select(location.hash.substr(1));
    	}
    	if (!visible) {
    		select("file0");
    	}
    })();
  </script>
</html>
